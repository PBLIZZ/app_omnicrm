===== src/app/(authorisedRoute)/omni-momentum/_components/DailyPulseWidget.tsx =====
"use client";

import { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle, Button, Textarea, Label } from "@/components/ui";
import { Zap, Battery, Clock, Plus, Trash2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";

/**
 * Daily Pulse Widget - Time-based Wellness Pulse Tracking
 *
 * Based on wellness practitioner research:
 * - Time-stamped pulses (AM, PM, Night) for pattern analysis
 * - Battery-style energy indicator (red to green)
 * - Optional notes for context
 * - Historical pulse tracking for trend analysis
 * - Empty state is OK - practitioners can skip pulses
 */

interface PulseData {
  id: string;
  time: string;
  energy: number;
  mood: string;
  notes: string;
  timestamp: string;
}

const MOOD_OPTIONS = [
  { emoji: "🤩", value: "amazing", label: "Amazing" },
  { emoji: "😄", value: "excellent", label: "Excellent" },
  { emoji: "😊", value: "good", label: "Good" },
  { emoji: "😌", value: "calm", label: "Calm" },
  { emoji: "😐", value: "okay", label: "Okay" },
  { emoji: "😴", value: "tired", label: "Tired" },
  { emoji: "😔", value: "low", label: "Low" },
  { emoji: "😫", value: "drained", label: "Drained" },
  { emoji: "😤", value: "frustrated", label: "Frustrated" },
];

export function DailyPulseWidget(): JSX.Element {
  const [currentPulse, setCurrentPulse] = useState<{
    time: string;
    energy: number;
    mood: string;
    notes: string;
  } | null>(null);
  const [editingPulse, setEditingPulse] = useState<PulseData | null>(null);
  const [pulseHistory, setPulseHistory] = useState<PulseData[]>([]);
  const { toast } = useToast();

  // Add CSS animation for shimmer effect
  useEffect(() => {
    const style = document.createElement("style");
    style.textContent = `
      @keyframes shimmer {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
      }
    `;
    document.head.appendChild(style);
    return () => {
      document.head.removeChild(style);
    };
  }, []);

  // Load pulse history from localStorage on mount
  useEffect(() => {
    const savedHistory = localStorage.getItem("pulseHistory");
    if (savedHistory) {
      try {
        setPulseHistory(JSON.parse(savedHistory));
      } catch (error) {
        console.error("Error loading pulse history:", error);
      }
    }
  }, []);

  const getCurrentTimeOfDay = (): string => {
    const hour = new Date().getHours();
    if (hour < 12) return "AM";
    if (hour < 17) return "PM";
    return "Night";
  };

  const getTimeOfDayLabel = (): string => {
    const timeOfDay = getCurrentTimeOfDay();
    const hour = new Date().getHours();
    const minute = new Date().getMinutes();
    const timeString = `${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")}`;
    return `${timeString} ${timeOfDay}`;
  };

  const handleEnergyChange = (value: number): void => {
    setCurrentPulse((prev) =>
      prev
        ? { ...prev, energy: value }
        : {
            time: getTimeOfDayLabel(),
            energy: value,
            mood: "okay",
            notes: "",
          },
    );
  };

  const handleMoodChange = (newMood: string): void => {
    setCurrentPulse((prev) =>
      prev
        ? { ...prev, mood: newMood }
        : {
            time: getTimeOfDayLabel(),
            energy: 3,
            mood: newMood,
            notes: "",
          },
    );
  };

  const handleNotesChange = (notes: string): void => {
    setCurrentPulse((prev) =>
      prev
        ? { ...prev, notes }
        : {
            time: getTimeOfDayLabel(),
            energy: 3,
            mood: "okay",
            notes,
          },
    );
  };

  const savePulse = (): void => {
    if (!currentPulse) return;

    const newPulse: PulseData = {
      id: Date.now().toString(),
      ...currentPulse,
      timestamp: new Date().toISOString(),
    };

    const updatedHistory = [newPulse, ...pulseHistory.slice(0, 4)]; // Keep last 5 pulses
    setPulseHistory(updatedHistory);
    setCurrentPulse(null);

    // Save to localStorage
    localStorage.setItem("pulseHistory", JSON.stringify(updatedHistory));

    toast({
      title: "Pulse Recorded! 📊",
      description: `Your ${getCurrentTimeOfDay().toLowerCase()} pulse has been saved.`,
    });
  };

  const handleEditPulse = (pulse: PulseData): void => {
    setEditingPulse(pulse);
    setCurrentPulse({
      time: pulse.time, // Keep original time display
      energy: pulse.energy,
      mood: pulse.mood,
      notes: pulse.notes,
    });
  };

  const handleUpdatePulse = (): void => {
    if (!currentPulse || !editingPulse) return;

    const updatedPulse: PulseData = {
      ...editingPulse,
      ...currentPulse,
      timestamp: editingPulse.timestamp, // Preserve original timestamp
    };

    const updatedHistory = pulseHistory.map((pulse) =>
      pulse.id === editingPulse.id ? updatedPulse : pulse,
    );
    setPulseHistory(updatedHistory);
    setCurrentPulse(null);
    setEditingPulse(null);

    // Save to localStorage
    localStorage.setItem("pulseHistory", JSON.stringify(updatedHistory));

    toast({
      title: "Pulse Updated! ✏️",
      description: "Your pulse has been updated successfully.",
    });
  };

  const handleDeletePulse = (pulseId: string): void => {
    const updatedHistory = pulseHistory.filter((pulse) => pulse.id !== pulseId);
    setPulseHistory(updatedHistory);

    // Save to localStorage
    localStorage.setItem("pulseHistory", JSON.stringify(updatedHistory));

    toast({
      title: "Pulse Deleted! 🗑️",
      description: "The pulse has been removed from your history.",
    });
  };

  const handleCancelEdit = (): void => {
    setCurrentPulse(null);
    setEditingPulse(null);
  };

  const formatPulseTime = (timestamp: string): string => {
    const date = new Date(timestamp);
    const hour = date.getHours();
    const minute = date.getMinutes().toString().padStart(2, "0");
    const timeOfDay = hour < 12 ? "AM" : hour < 17 ? "PM" : "Night";
    return `${hour.toString().padStart(2, "0")}:${minute} ${timeOfDay}`;
  };

  return (
    <Card className="bg-gradient-to-r from-blue-50 to-indigo-50 border-blue-200 h-[35rem] flex flex-col">
      <CardHeader className="pb-4 flex-shrink-0">
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center gap-2 text-lg">
            <Zap className="w-5 h-5 text-blue-500" />
            Daily Pulse
          </CardTitle>
          <Button
            size="sm"
            variant="ghost"
            onClick={() =>
              setCurrentPulse({
                time: getTimeOfDayLabel(),
                energy: 3,
                mood: "okay",
                notes: "",
              })
            }
            className="h-8 w-8 p-0 text-blue-600 hover:text-blue-700 hover:bg-blue-100"
          >
            <Plus className="w-4 h-4" />
          </Button>
        </div>
        <p className="text-sm text-gray-600">
          {getCurrentTimeOfDay()} Pulse • {getTimeOfDayLabel()}
        </p>
      </CardHeader>
      <CardContent className="space-y-6 flex-1 overflow-y-auto [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]">
        {currentPulse ? (
          // Pulse Entry Form
          <div className="space-y-4">
            {/* Energy and Mood Side by Side */}
            <div className="grid grid-cols-3 gap-6">
              {/* Energy Level - Upright Battery Style */}
              <div className="space-y-3">
                <div className="flex items-center justify-center">
                  <Label className="text-sm font-medium flex items-center gap-2">
                    <Battery className="w-4 h-4 text-blue-500" />
                    Energy Level
                  </Label>
                </div>
                <div className="relative">
                  {/* Clickable Upright Battery Container with 5 Levels */}
                  <div className="relative w-20 h-28 bg-gray-200 rounded-lg overflow-hidden border-2 border-gray-300 mx-auto cursor-pointer hover:border-gray-400 transition-colors">
                    {/* Battery Terminal */}
                    <div className="absolute -top-1 left-1/2 transform -translate-x-1/2 w-3 h-1.5 bg-gray-300 rounded-t-sm"></div>

                    {/* 5 Clickable Battery Levels */}
                    <div className="h-full flex flex-col">
                      {[5, 4, 3, 2, 1].map((level) => (
                        <button
                          key={level}
                          onClick={() => handleEnergyChange(level)}
                          className={`flex-1 border-b border-gray-300 last:border-b-0 transition-all duration-300 hover:brightness-110 ${
                            level <= currentPulse.energy
                              ? level <= 1
                                ? "bg-gradient-to-b from-red-500 to-red-400"
                                : level <= 2
                                  ? "bg-gradient-to-b from-orange-500 to-orange-400"
                                  : level <= 3
                                    ? "bg-gradient-to-b from-yellow-500 to-yellow-400"
                                    : level <= 4
                                      ? "bg-gradient-to-b from-green-400 to-green-500"
                                      : "bg-gradient-to-b from-green-500 to-green-600"
                              : "bg-gray-200 hover:bg-gray-300"
                          }`}
                        >
                          {/* Shimmer effect for active levels */}
                          {level <= currentPulse.energy && (
                            <div
                              className="w-full h-full bg-gradient-to-r from-transparent via-white/20 to-transparent"
                              style={{
                                animation: `shimmer 2s ease-in-out infinite`,
                                animationDelay: `${(6 - level) * 0.3}s`,
                              }}
                            ></div>
                          )}
                        </button>
                      ))}
                    </div>

                    {/* Battery Percentage Text */}
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                      <span className="text-sm font-bold text-white drop-shadow-sm">
                        {Math.round((currentPulse.energy / 5) * 100)}%
                      </span>
                    </div>
                  </div>
                </div>
              </div>

              {/* Mood */}
              <div className="space-y-3 col-span-2">
                <Label className="text-sm font-medium">Current Mood</Label>
                <div className="grid grid-cols-3">
                  {MOOD_OPTIONS.map((moodOption) => (
                    <button
                      key={moodOption.value}
                      onClick={() => handleMoodChange(moodOption.value)}
                      className={`px-2 py-2 rounded-lg text-2xl transition-all duration-200 hover:scale-105 ${
                        currentPulse.mood === moodOption.value
                          ? "bg-gray-200 scale-105"
                          : "hover:bg-gray-100"
                      }`}
                      title={moodOption.label}
                    >
                      {moodOption.emoji}
                    </button>
                  ))}
                </div>
              </div>
            </div>

            {/* Notes */}
            <div className="space-y-2">
              <Label className="text-sm font-medium">Notes (Optional)</Label>
              <Textarea
                placeholder="How are you feeling? What's affecting your energy?"
                value={currentPulse.notes}
                onChange={(e) => handleNotesChange(e.target.value)}
                className="min-h-[60px] text-sm"
              />
            </div>

            {/* Save/Update Button */}
            <div className="flex gap-2">
              <Button onClick={editingPulse ? handleUpdatePulse : savePulse} className="flex-1">
                {editingPulse ? "Update Pulse" : `Save ${getCurrentTimeOfDay()} Pulse`}
              </Button>
              {editingPulse && (
                <Button onClick={handleCancelEdit} variant="outline" className="px-4">
                  Cancel
                </Button>
              )}
            </div>
          </div>
        ) : (
          // No Current Pulse - Show History or Start Button
          <div className="space-y-4">
            {pulseHistory.length > 0 ? (
              <div className="space-y-3">
                <h4 className="text-sm font-medium text-gray-700 flex items-center gap-2">
                  <Clock className="w-4 h-4" />
                  Recent Pulses
                </h4>
                {pulseHistory.slice(0, 3).map((pulse) => (
                  <div
                    key={pulse.id}
                    className="p-3 bg-white rounded-lg border hover:shadow-sm transition-shadow cursor-pointer group"
                    onClick={() => handleEditPulse(pulse)}
                  >
                    <div className="flex items-center justify-between mb-2">
                      <span className="text-sm font-medium text-gray-900">
                        {formatPulseTime(pulse.timestamp)}
                      </span>
                      <div className="flex items-center gap-2">
                        {/* Mini Upright Battery */}
                        <div className="relative w-12 h-16 bg-gray-200 rounded-sm overflow-hidden border border-gray-300">
                          <div className="absolute -top-0.5 left-1/2 transform -translate-x-1/2 w-2 h-1 bg-gray-300 rounded-t-sm"></div>
                          <div className="h-full flex flex-col">
                            {[5, 4, 3, 2, 1].map((level) => (
                              <div
                                key={level}
                                className={`flex-1 border-b border-gray-300 last:border-b-0 ${
                                  level <= pulse.energy
                                    ? level <= 1
                                      ? "bg-gradient-to-b from-red-500 to-red-400"
                                      : level <= 2
                                        ? "bg-gradient-to-b from-orange-500 to-orange-400"
                                        : level <= 3
                                          ? "bg-gradient-to-b from-yellow-500 to-yellow-400"
                                          : level <= 4
                                            ? "bg-gradient-to-b from-green-400 to-green-500"
                                            : "bg-gradient-to-b from-green-500 to-green-600"
                                    : "bg-gray-200"
                                }`}
                              />
                            ))}
                          </div>
                          <div className="absolute inset-0 flex items-center justify-center">
                            <span className="text-sm font-bold text-white drop-shadow-sm">
                              {Math.round((pulse.energy / 5) * 100)}%
                            </span>
                          </div>
                        </div>
                        {/* Delete Button - Always visible */}
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleDeletePulse(pulse.id);
                          }}
                          className="h-6 w-6 p-0 text-red-600 hover:text-red-700 hover:bg-red-100"
                        >
                          <Trash2 className="w-3 h-3" />
                        </Button>
                      </div>
                    </div>
                    <p className="text-xs text-gray-600">
                      {MOOD_OPTIONS.find((mood) => mood.value === pulse.mood)?.emoji || "😐"}{" "}
                      {MOOD_OPTIONS.find((mood) => mood.value === pulse.mood)?.label || "Okay"}
                    </p>
                    {pulse.notes && (
                      <p className="text-xs text-gray-500 mt-1 italic">"{pulse.notes}"</p>
                    )}
                    {/* Edit hint - only show on hover */}
                    <div className="opacity-0 group-hover:opacity-100 transition-opacity mt-2">
                      <p className="text-xs text-blue-600">Click to edit</p>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-8">
                <Zap className="w-12 h-12 text-gray-300 mx-auto mb-4" />
                <p className="text-sm text-gray-500 mb-4">No pulses recorded yet</p>
                <p className="text-xs text-gray-400">Track your energy throughout the day</p>
              </div>
            )}
          </div>
        )}
      </CardContent>
    </Card>
  );
}



===== src/app/(authorisedRoute)/omni-momentum/_components/HabitTrackers.tsx =====
"use client";

import { useState, useEffect } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  Button,
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  Input,
  Label,
} from "@/components/ui";
import { CheckSquare, Plus, ChevronDown, Trash2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";

// Type definition for habit objects
interface Habit {
  id: number;
  name: string;
  completed: boolean;
  streak: number;
}

// Configuration constants
const CONFIG = {
  MAX_HABITS_DISPLAYED: 5,
} as const;

/**
 * Habit Trackers Component
 * Simple habit tracking for wellness practitioners with progressive disclosure
 */
export function HabitTrackers(): JSX.Element {
  const [showCompleted, setShowCompleted] = useState(false);
  const [showAddModal, setShowAddModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [editingHabit, setEditingHabit] = useState<Habit | null>(null);
  const [newHabitName, setNewHabitName] = useState("");
  const [showAllHabits, setShowAllHabits] = useState(false);
  const { toast } = useToast();

  // Initialize habits with daily reset logic
  const initializeHabits = () => {
    const today = new Date().toDateString();
    const lastReset = localStorage.getItem("habitResetDate");

    // If it's a new day, reset all habits and update streaks
    if (lastReset !== today) {
      const savedHabits = JSON.parse(localStorage.getItem("habits") || "[]");
      const resetHabits = savedHabits.map((habit: Habit) => ({
        ...habit,
        completed: false, // Reset all to incomplete
        streak: habit.completed ? habit.streak : 0, // Reset streak to 0 if not completed yesterday
      }));

      localStorage.setItem("habits", JSON.stringify(resetHabits));
      localStorage.setItem("habitResetDate", today);
      return resetHabits;
    }

    // Return saved habits or empty array if no saved data
    const savedHabits = JSON.parse(localStorage.getItem("habits") || "[]");
    return savedHabits;
  };

  const [habits, setHabits] = useState(initializeHabits);
  const [lastResetDate, setLastResetDate] = useState<string>("");

  // Check for daily reset on component mount and when date changes
  useEffect(() => {
    const today = new Date().toDateString();
    const lastReset = localStorage.getItem("habitResetDate");

    if (lastReset !== today) {
      // New day detected - reset habits
      setHabits((prevHabits: Habit[]) => {
        const resetHabits = prevHabits.map((habit: Habit) => ({
          ...habit,
          completed: false, // Reset all to incomplete
          streak: habit.completed ? habit.streak : 0, // Reset streak to 0 if not completed yesterday
        }));

        localStorage.setItem("habits", JSON.stringify(resetHabits));
        localStorage.setItem("habitResetDate", today);
        setLastResetDate(today);

        // Show reset notification
        toast({
          title: "New Day! 🌅",
          description: "Habits reset for today. Complete them to maintain your streaks!",
        });

        return resetHabits;
      });
    } else {
      setLastResetDate(today);
    }
  }, [toast]);

  // Sort habits by streak (highest first) and filter by completion status
  const allIncompleteHabits = habits
    .filter((habit: Habit) => !habit.completed)
    .sort((a: Habit, b: Habit) => b.streak - a.streak);

  const incompleteHabits = showAllHabits
    ? allIncompleteHabits
    : allIncompleteHabits.slice(0, CONFIG.MAX_HABITS_DISPLAYED);

  const completedHabits = habits
    .filter((habit: Habit) => habit.completed)
    .sort((a: Habit, b: Habit) => b.streak - a.streak);

  const toggleHabit = (habitId: number): void => {
    setHabits((prevHabits: Habit[]) => {
      const updatedHabits = prevHabits.map((habit: Habit) => {
        if (habit.id === habitId) {
          const newCompleted = !habit.completed;
          const newStreak = newCompleted ? habit.streak + 1 : Math.max(0, habit.streak - 1);

          // Show toast notification for streak changes
          if (newCompleted) {
            toast({
              title: "Habit Completed! 🎉",
              description: `${habit.name} streak: ${newStreak} days`,
            });
          } else {
            toast({
              title: "Habit Undone",
              description: `${habit.name} streak: ${newStreak} days`,
            });
          }

          return { ...habit, completed: newCompleted, streak: newStreak };
        }
        return habit;
      });

      localStorage.setItem("habits", JSON.stringify(updatedHabits));
      return updatedHabits;
    });
  };

  const addHabit = (): void => {
    if (newHabitName.trim()) {
      const newHabit: Habit = {
        id: Date.now(),
        name: newHabitName.trim(),
        completed: false,
        streak: 0,
      };

      setHabits((prevHabits: Habit[]) => {
        const updatedHabits = [...prevHabits, newHabit];
        localStorage.setItem("habits", JSON.stringify(updatedHabits));
        return updatedHabits;
      });

      setNewHabitName("");
      setShowAddModal(false);

      toast({
        title: "Habit Added! 📝",
        description: `${newHabit.name} has been added to your habits.`,
      });
    }
  };

  const deleteHabit = (habitId: number): void => {
    setHabits((prevHabits: Habit[]) => {
      const updatedHabits = prevHabits.filter((habit: Habit) => habit.id !== habitId);
      localStorage.setItem("habits", JSON.stringify(updatedHabits));
      return updatedHabits;
    });

    toast({
      title: "Habit Deleted",
      description: "The habit has been removed from your list.",
    });
  };

  const editHabit = (habit: Habit): void => {
    setEditingHabit(habit);
    setNewHabitName(habit.name);
    setShowEditModal(true);
  };

  const saveEditHabit = (): void => {
    if (editingHabit && newHabitName.trim()) {
      setHabits((prevHabits: Habit[]) => {
        const updatedHabits = prevHabits.map((habit: Habit) =>
          habit.id === editingHabit.id ? { ...habit, name: newHabitName.trim() } : habit,
        );
        localStorage.setItem("habits", JSON.stringify(updatedHabits));
        return updatedHabits;
      });

      setNewHabitName("");
      setShowEditModal(false);
      setEditingHabit(null);

      toast({
        title: "Habit Updated! ✏️",
        description: "Your habit has been updated successfully.",
      });
    }
  };

  return (
    <Card className="bg-gradient-to-r from-green-50 to-emerald-50 border-green-200 h-[35rem] flex flex-col">
      <CardHeader className="pb-4 flex-shrink-0">
        <div className="flex items-center justify-between">
          <CardTitle className="flex items-center gap-2 text-lg">
            <CheckSquare className="w-5 h-5 text-green-500" />
            Habit Trackers
          </CardTitle>
          <Button
            size="sm"
            variant="ghost"
            onClick={() => setShowAddModal(true)}
            className="h-8 w-8 p-0 text-green-600 hover:text-green-700 hover:bg-green-100"
          >
            <Plus className="w-4 h-4" />
          </Button>
        </div>
        <CardDescription>
          Track your daily wellness habits and build consistent routines
        </CardDescription>
      </CardHeader>

      <CardContent className="space-y-3 flex-1 overflow-y-auto [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]">
        {/* Incomplete Habits */}
        {incompleteHabits.map((habit: Habit) => (
          <div
            key={habit.id}
            className="flex items-center justify-between p-3 bg-white rounded-lg border hover:shadow-sm transition-shadow"
          >
            <div
              className="flex items-center gap-3 flex-1 cursor-pointer"
              onClick={() => editHabit(habit)}
            >
              <div className="w-4 h-4 rounded-full border-2 border-gray-300 flex items-center justify-center">
                {habit.completed && <span className="text-white text-xs">✓</span>}
              </div>
              <div className="flex-1">
                <p className="text-sm font-medium text-gray-900">{habit.name}</p>
                <p className="text-xs text-gray-500">
                  {habit.streak} day{habit.streak !== 1 ? "s" : ""} streak
                </p>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <Button
                size="sm"
                variant="ghost"
                onClick={(e) => {
                  e.stopPropagation();
                  deleteHabit(habit.id);
                }}
                className="h-8 w-8 p-0 text-red-500 hover:text-red-700 hover:bg-red-50"
              >
                <Trash2 className="w-3 h-3" />
              </Button>
              <Button size="sm" variant="outline" onClick={() => toggleHabit(habit.id)}>
                Mark Done
              </Button>
            </div>
          </div>
        ))}

        {/* Show More/Less Toggle for Incomplete Habits */}
        {allIncompleteHabits.length > CONFIG.MAX_HABITS_DISPLAYED && (
          <div className="pt-2 border-t border-gray-200">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => setShowAllHabits(!showAllHabits)}
              className="w-full text-xs text-gray-600 hover:text-gray-800"
            >
              {showAllHabits
                ? "Show Less"
                : `Show ${allIncompleteHabits.length - CONFIG.MAX_HABITS_DISPLAYED} More`}
              <ChevronDown
                className={`w-3 h-3 ml-1 transition-transform ${showAllHabits ? "rotate-180" : ""}`}
              />
            </Button>
          </div>
        )}

        {/* Completed Habits Toggle */}
        {completedHabits.length > 0 && (
          <div className="pt-2 border-t border-gray-200">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => setShowCompleted(!showCompleted)}
              className="w-full text-xs text-gray-600 hover:text-gray-800"
            >
              {showCompleted ? "Hide" : "Show"} {completedHabits.length} completed today
              <ChevronDown
                className={`w-3 h-3 ml-1 transition-transform ${showCompleted ? "rotate-180" : ""}`}
              />
            </Button>

            {/* Completed Habits List */}
            {showCompleted && (
              <div className="space-y-2 mt-3">
                {completedHabits.map((habit: Habit) => (
                  <div
                    key={habit.id}
                    className="flex items-center justify-between p-2 bg-green-50 rounded-lg border border-green-200 hover:shadow-sm transition-shadow"
                  >
                    <div
                      className="flex items-center gap-3 flex-1 cursor-pointer"
                      onClick={() => editHabit(habit)}
                    >
                      <div className="w-4 h-4 rounded-full border-2 bg-green-500 border-green-500 flex items-center justify-center">
                        <span className="text-white text-xs">✓</span>
                      </div>
                      <div>
                        <p className="text-sm font-medium text-green-800">{habit.name}</p>
                        <p className="text-xs text-green-600">
                          {habit.streak} day{habit.streak !== 1 ? "s" : ""} streak
                        </p>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={(e) => {
                          e.stopPropagation();
                          deleteHabit(habit.id);
                        }}
                        className="h-6 w-6 p-0 text-red-500 hover:text-red-700 hover:bg-red-50"
                      >
                        <Trash2 className="w-3 h-3" />
                      </Button>
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => toggleHabit(habit.id)}
                        className="text-green-600 hover:text-green-700 hover:bg-green-100"
                      >
                        Undo
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}
      </CardContent>

      {/* Add Habit Modal */}
      <Dialog open={showAddModal} onOpenChange={setShowAddModal}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Add New Habit</DialogTitle>
            <DialogDescription>
              Create a new habit to track your daily wellness practices.
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="habit-name">Habit Name</Label>
              <Input
                id="habit-name"
                placeholder="e.g., Morning Meditation"
                value={newHabitName}
                onChange={(e) => setNewHabitName(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === "Enter") {
                    addHabit();
                  }
                }}
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowAddModal(false)}>
              Cancel
            </Button>
            <Button onClick={addHabit}>Add Habit</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Edit Habit Modal */}
      <Dialog open={showEditModal} onOpenChange={setShowEditModal}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Edit Habit</DialogTitle>
            <DialogDescription>Update the name of your habit.</DialogDescription>
          </DialogHeader>
          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="edit-habit-name">Habit Name</Label>
              <Input
                id="edit-habit-name"
                placeholder="e.g., Morning Meditation"
                value={newHabitName}
                onChange={(e) => setNewHabitName(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === "Enter") {
                    saveEditHabit();
                  }
                }}
              />
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowEditModal(false)}>
              Cancel
            </Button>
            <Button onClick={saveEditHabit}>Save Changes</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </Card>
  );
}



===== src/app/(authorisedRoute)/omni-momentum/_components/IntelligentInboxWidget.tsx =====
/**
 * Intelligent Inbox Widget for OmniMomentum
 *
 * This component provides a quick capture interface with intelligent processing
 * and approval workflow integration.
 */

"use client";

import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2, Brain, CheckCircle, AlertTriangle, Zap } from "lucide-react";
import { useIntelligentInbox } from "@/hooks/use-intelligent-inbox";
import { IntelligentProcessingApproval } from "@/app/(authorisedRoute)/omni-momentum/_components/IntelligentProcessingApproval";

export function IntelligentInboxWidget(): JSX.Element {
  const [rawText, setRawText] = useState("");
  const [enableIntelligentProcessing, setEnableIntelligentProcessing] = useState(true);
  const [showApproval, setShowApproval] = useState(false);

  const {
    stats,
    pendingItems,
    isLoading,
    isAvailable,
    processIntelligentCapture,
    loadPendingItems,
  } = useIntelligentInbox();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!rawText.trim()) {
      return;
    }

    try {
      const result = await processIntelligentCapture(rawText, enableIntelligentProcessing);

      if (result.requiresApproval) {
        setShowApproval(true);
      }

      setRawText("");
    } catch (error) {
      console.error("Failed to process:", error);
    }
  };

  const handleApprovalComplete = () => {
    setShowApproval(false);
    loadPendingItems();
  };

  if (showApproval) {
    return (
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <h2 className="text-2xl font-bold">Review AI Suggestions</h2>
          <Button variant="outline" onClick={() => setShowApproval(false)}>
            Back to Capture
          </Button>
        </div>
        <IntelligentProcessingApproval
          items={pendingItems}
          onApprovalComplete={handleApprovalComplete}
        />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Stats Overview */}
      {stats && (
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-2">
                <AlertTriangle className="h-4 w-4 text-orange-500" />
                <div>
                  <div className="text-2xl font-bold">{stats.pendingApprovals}</div>
                  <div className="text-xs text-muted-foreground">Pending Approval</div>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-2">
                <CheckCircle className="h-4 w-4 text-green-500" />
                <div>
                  <div className="text-2xl font-bold">{stats.totalProcessed}</div>
                  <div className="text-xs text-muted-foreground">Total Processed</div>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-2">
                <Brain className="h-4 w-4 text-blue-500" />
                <div>
                  <div className="text-2xl font-bold">
                    {Math.round(stats.averageConfidence * 100)}%
                  </div>
                  <div className="text-xs text-muted-foreground">Avg Confidence</div>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-2">
                {isAvailable ? (
                  <Zap className="h-4 w-4 text-green-500" />
                ) : (
                  <AlertTriangle className="h-4 w-4 text-red-500" />
                )}
                <div>
                  <div className="text-2xl font-bold">{isAvailable ? "ON" : "OFF"}</div>
                  <div className="text-xs text-muted-foreground">AI Status</div>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Quick Capture Form */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Brain className="h-5 w-5" />
            Intelligent Quick Capture
          </CardTitle>
          <CardDescription>
            Dump everything here and let AI intelligently break it down into tasks, projects, and
            categories.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Textarea
                value={rawText}
                onChange={(e) => setRawText(e.target.value)}
                placeholder="Dump everything here... e.g., 'Need to call John about the project proposal, finish the quarterly report by Friday, book dentist appointment, and organize the team meeting for next week'"
                className="min-h-[120px] resize-none"
                disabled={isLoading}
              />
              <div className="text-xs text-muted-foreground">{rawText.length} characters</div>
            </div>

            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                <Switch
                  id="intelligent-processing"
                  checked={enableIntelligentProcessing}
                  onCheckedChange={setEnableIntelligentProcessing}
                  disabled={!isAvailable || isLoading}
                />
                <label htmlFor="intelligent-processing" className="text-sm font-medium">
                  Enable AI Processing
                </label>
                {!isAvailable && (
                  <Badge variant="destructive" className="text-xs">
                    AI Unavailable
                  </Badge>
                )}
              </div>

              <Button
                type="submit"
                disabled={
                  !rawText.trim() || isLoading || (!isAvailable && enableIntelligentProcessing)
                }
                className="min-w-[120px]"
              >
                {isLoading ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    Processing...
                  </>
                ) : (
                  <>
                    <Brain className="h-4 w-4 mr-2" />
                    Process
                  </>
                )}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>

      {/* Pending Approvals Alert */}
      {pendingItems.length > 0 && (
        <Alert>
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>
            You have {pendingItems.length} item{pendingItems.length !== 1 ? "s" : ""} pending
            approval.
            <Button
              variant="link"
              className="p-0 h-auto ml-2"
              onClick={() => setShowApproval(true)}
            >
              Review now
            </Button>
          </AlertDescription>
        </Alert>
      )}

      {/* How it works */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">How Intelligent Processing Works</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
            <div>
              <h4 className="font-medium mb-2">🤖 AI Analysis</h4>
              <ul className="space-y-1 text-muted-foreground">
                <li>• Splits bulk input into individual tasks</li>
                <li>• Categorizes by zones (Life, Business, etc.)</li>
                <li>• Suggests project groupings</li>
                <li>• Detects task hierarchies</li>
              </ul>
            </div>
            <div>
              <h4 className="font-medium mb-2">👤 Human Review</h4>
              <ul className="space-y-1 text-muted-foreground">
                <li>• Review and modify AI suggestions</li>
                <li>• Approve or reject individual items</li>
                <li>• Adjust priorities and due dates</li>
                <li>• Final approval before creation</li>
              </ul>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}



===== src/app/(authorisedRoute)/omni-momentum/_components/IntelligentProcessingApproval.tsx =====
/**
 * Intelligent Processing Approval Component
 *
 * This component provides a UI for users to review and approve AI-generated
 * task breakdowns from the intelligent inbox processing.
 */

"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2, CheckCircle, XCircle, AlertTriangle, Clock, Calendar } from "lucide-react";
import { toast } from "sonner";

interface IntelligentTask {
  id: string;
  name: string;
  description: string | null;
  priority: "low" | "medium" | "high" | "urgent";
  estimatedMinutes: number | null;
  dueDate: string | null;
  zoneId: number | null;
  projectId: string | null;
  parentTaskId: string | null;
  confidence: number;
  reasoning: string;
}

interface IntelligentProject {
  id: string;
  name: string;
  description: string | null;
  zoneId: number | null;
  status: "active" | "on_hold" | "completed" | "archived";
  dueDate: string | null;
  confidence: number;
  reasoning: string;
}

interface TaskHierarchy {
  parentTaskId: string;
  subtaskIds: string[];
  relationshipType: "task_subtask" | "project_task";
  confidence: number;
}

interface ProcessingResult {
  extractedTasks: IntelligentTask[];
  suggestedProjects: IntelligentProject[];
  taskHierarchies: TaskHierarchy[];
  overallConfidence: number;
  processingNotes: string;
  requiresApproval: boolean;
}

interface InboxItem {
  id: string;
  rawText: string;
  createdAt: string;
  status: string;
}

interface ApprovalItem {
  inboxItem: InboxItem;
  processingResult: ProcessingResult;
}

interface ApprovedTask {
  taskId: string;
  approved: boolean;
  modifications: Record<string, string | number | null>;
}

interface ApprovedProject {
  projectId: string;
  approved: boolean;
  modifications: Record<string, string | number | null>;
}

interface ApprovedHierarchy extends TaskHierarchy {
  approved: boolean;
}

interface ItemApprovalData {
  approvedTasks: ApprovedTask[];
  approvedProjects: ApprovedProject[];
  approvedHierarchies: ApprovedHierarchy[];
}

interface IntelligentProcessingApprovalProps {
  items: ApprovalItem[];
  onApprovalComplete: () => void;
}

export function IntelligentProcessingApproval({
  items,
  onApprovalComplete,
}: IntelligentProcessingApprovalProps): JSX.Element {
  const [approvalData, setApprovalData] = useState<Record<string, ItemApprovalData>>({});
  const [isProcessing, setIsProcessing] = useState(false);
  const [selectedItem, setSelectedItem] = useState<ApprovalItem | null>(items[0] || null);

  // Initialize approval data
  useEffect(() => {
    const initialData: Record<string, ItemApprovalData> = {};

    items.forEach((item) => {
      initialData[item.inboxItem.id] = {
        approvedTasks: item.processingResult.extractedTasks.map((task) => ({
          taskId: task.id,
          approved: true,
          modifications: {},
        })),
        approvedProjects: item.processingResult.suggestedProjects.map((project) => ({
          projectId: project.id,
          approved: true,
          modifications: {},
        })),
        approvedHierarchies: item.processingResult.taskHierarchies.map((hierarchy) => ({
          ...hierarchy,
          approved: true,
        })),
      };
    });

    setApprovalData(initialData);
  }, [items]);

  const handleTaskApprovalChange = (itemId: string, taskId: string, approved: boolean) => {
    setApprovalData((prev) => {
      const itemData = prev[itemId];
      if (!itemData) return prev;

      return {
        ...prev,
        [itemId]: {
          ...itemData,
          approvedTasks: itemData.approvedTasks.map((task) =>
            task.taskId === taskId ? { ...task, approved } : task,
          ),
        },
      };
    });
  };

  const handleProjectApprovalChange = (itemId: string, projectId: string, approved: boolean) => {
    setApprovalData((prev) => {
      const itemData = prev[itemId];
      if (!itemData) return prev;

      return {
        ...prev,
        [itemId]: {
          ...itemData,
          approvedProjects: itemData.approvedProjects.map((project) =>
            project.projectId === projectId ? { ...project, approved } : project,
          ),
        },
      };
    });
  };

  const handleTaskModification = (
    itemId: string,
    taskId: string,
    field: string,
    value: string | number | null,
  ) => {
    setApprovalData((prev) => {
      const itemData = prev[itemId];
      if (!itemData) return prev;

      return {
        ...prev,
        [itemId]: {
          ...itemData,
          approvedTasks: itemData.approvedTasks.map((task) =>
            task.taskId === taskId
              ? {
                  ...task,
                  modifications: {
                    ...task.modifications,
                    [field]: value,
                  },
                }
              : task,
          ),
        },
      };
    });
  };

  const handleProjectModification = (
    itemId: string,
    projectId: string,
    field: string,
    value: string | number | null,
  ) => {
    setApprovalData((prev) => {
      const itemData = prev[itemId];
      if (!itemData) return prev;

      return {
        ...prev,
        [itemId]: {
          ...itemData,
          approvedProjects: itemData.approvedProjects.map((project) =>
            project.projectId === projectId
              ? {
                  ...project,
                  modifications: {
                    ...project.modifications,
                    [field]: value,
                  },
                }
              : project,
          ),
        },
      };
    });
  };

  const handleApproval = async (itemId: string) => {
    setIsProcessing(true);

    try {
      const response = await fetch("/api/omni-momentum/inbox/approval", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          inboxItemId: itemId,
          ...approvalData[itemId],
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to process approval");
      }

      const result = await response.json();
      toast.success(result.processingSummary);
      onApprovalComplete();
    } catch (error) {
      toast.error("Failed to process approval");
      console.error("Approval error:", error);
    } finally {
      setIsProcessing(false);
    }
  };

  const handleReject = async (itemId: string) => {
    setIsProcessing(true);

    try {
      const response = await fetch("/api/omni-momentum/inbox/approval", {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ inboxItemId: itemId }),
      });

      if (!response.ok) {
        throw new Error("Failed to reject processing");
      }

      toast.success("Intelligent processing rejected, reverted to manual processing");
      onApprovalComplete();
    } catch (error) {
      toast.error("Failed to reject processing");
      console.error("Reject error:", error);
    } finally {
      setIsProcessing(false);
    }
  };

  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 0.8) return "text-green-600";
    if (confidence >= 0.6) return "text-yellow-600";
    return "text-red-600";
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case "urgent":
        return "bg-red-100 text-red-800";
      case "high":
        return "bg-orange-100 text-orange-800";
      case "medium":
        return "bg-blue-100 text-blue-800";
      case "low":
        return "bg-gray-100 text-gray-800";
      default:
        return "bg-gray-100 text-gray-800";
    }
  };

  if (items.length === 0) {
    return (
      <Alert>
        <CheckCircle className="h-4 w-4" />
        <AlertDescription>
          No items pending approval. All intelligently processed items have been reviewed.
        </AlertDescription>
      </Alert>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h2 className="text-2xl font-bold">Intelligent Processing Approval</h2>
        <Badge variant="outline" className="text-sm">
          {items.length} item{items.length !== 1 ? "s" : ""} pending
        </Badge>
      </div>

      <Tabs
        value={selectedItem?.inboxItem.id || ""}
        onValueChange={(value) => {
          const item = items.find((i) => i.inboxItem.id === value);
          setSelectedItem(item || null);
        }}
      >
        <TabsList className="grid w-full grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
          {items.map((item) => (
            <TabsTrigger key={item.inboxItem.id} value={item.inboxItem.id}>
              <div className="text-left">
                <div className="font-medium truncate">
                  {item.inboxItem.rawText.substring(0, 30)}...
                </div>
                <div className="text-xs text-muted-foreground">
                  {item.processingResult.extractedTasks.length} tasks,{" "}
                  {item.processingResult.suggestedProjects.length} projects
                </div>
              </div>
            </TabsTrigger>
          ))}
        </TabsList>

        {items.map((item) => (
          <TabsContent key={item.inboxItem.id} value={item.inboxItem.id} className="space-y-4">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <AlertTriangle className="h-5 w-5" />
                  Original Input
                </CardTitle>
                <CardDescription>
                  Confidence:{" "}
                  <span className={getConfidenceColor(item.processingResult.overallConfidence)}>
                    {Math.round(item.processingResult.overallConfidence * 100)}%
                  </span>
                </CardDescription>
              </CardHeader>
              <CardContent>
                <p className="text-sm text-muted-foreground whitespace-pre-wrap">
                  {item.inboxItem.rawText}
                </p>
                <div className="mt-2 text-xs text-muted-foreground">
                  {item.processingResult.processingNotes}
                </div>
              </CardContent>
            </Card>

            <div className="grid gap-4 md:grid-cols-2">
              {/* Tasks */}
              <Card>
                <CardHeader>
                  <CardTitle className="text-lg">
                    Tasks ({item.processingResult.extractedTasks.length})
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-3">
                  {item.processingResult.extractedTasks.map((task) => (
                    <div key={task.id} className="border rounded-lg p-3 space-y-2">
                      <div className="flex items-start gap-2">
                        <Checkbox
                          checked={
                            approvalData[item.inboxItem.id]?.approvedTasks?.find(
                              (t) => t.taskId === task.id,
                            )?.approved || false
                          }
                          onCheckedChange={(checked) =>
                            handleTaskApprovalChange(item.inboxItem.id, task.id, checked as boolean)
                          }
                        />
                        <div className="flex-1 space-y-2">
                          <div className="flex items-center gap-2">
                            <Input
                              value={
                                (approvalData[item.inboxItem.id]?.approvedTasks?.find(
                                  (t) => t.taskId === task.id,
                                )?.modifications?.name as string | undefined) || task.name
                              }
                              onChange={(e) =>
                                handleTaskModification(
                                  item.inboxItem.id,
                                  task.id,
                                  "name",
                                  e.target.value,
                                )
                              }
                              className="font-medium"
                            />
                            <Badge className={getPriorityColor(task.priority)}>
                              {task.priority}
                            </Badge>
                          </div>
                          <Textarea
                            value={
                              (approvalData[item.inboxItem.id]?.approvedTasks?.find(
                                (t) => t.taskId === task.id,
                              )?.modifications?.description as string | undefined) ||
                              task.description ||
                              ""
                            }
                            onChange={(e) =>
                              handleTaskModification(
                                item.inboxItem.id,
                                task.id,
                                "description",
                                e.target.value,
                              )
                            }
                            placeholder="Task description..."
                            className="text-sm"
                            rows={2}
                          />
                          <div className="flex items-center gap-4 text-xs text-muted-foreground">
                            {task.estimatedMinutes && (
                              <div className="flex items-center gap-1">
                                <Clock className="h-3 w-3" />
                                {task.estimatedMinutes}m
                              </div>
                            )}
                            {task.dueDate && (
                              <div className="flex items-center gap-1">
                                <Calendar className="h-3 w-3" />
                                {new Date(task.dueDate).toLocaleDateString()}
                              </div>
                            )}
                          </div>
                          <div className="text-xs text-muted-foreground">
                            AI Reasoning: {task.reasoning}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </CardContent>
              </Card>

              {/* Projects */}
              <Card>
                <CardHeader>
                  <CardTitle className="text-lg">
                    Projects ({item.processingResult.suggestedProjects.length})
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-3">
                  {item.processingResult.suggestedProjects.map((project) => (
                    <div key={project.id} className="border rounded-lg p-3 space-y-2">
                      <div className="flex items-start gap-2">
                        <Checkbox
                          checked={
                            approvalData[item.inboxItem.id]?.approvedProjects?.find(
                              (p) => p.projectId === project.id,
                            )?.approved || false
                          }
                          onCheckedChange={(checked) =>
                            handleProjectApprovalChange(
                              item.inboxItem.id,
                              project.id,
                              checked as boolean,
                            )
                          }
                        />
                        <div className="flex-1 space-y-2">
                          <Input
                            value={
                              (approvalData[item.inboxItem.id]?.approvedProjects?.find(
                                (p) => p.projectId === project.id,
                              )?.modifications?.name as string | undefined) || project.name
                            }
                            onChange={(e) =>
                              handleProjectModification(
                                item.inboxItem.id,
                                project.id,
                                "name",
                                e.target.value,
                              )
                            }
                            className="font-medium"
                          />
                          <Textarea
                            value={
                              (approvalData[item.inboxItem.id]?.approvedProjects?.find(
                                (p) => p.projectId === project.id,
                              )?.modifications?.description as string | undefined) ||
                              project.description ||
                              ""
                            }
                            onChange={(e) =>
                              handleProjectModification(
                                item.inboxItem.id,
                                project.id,
                                "description",
                                e.target.value,
                              )
                            }
                            placeholder="Project description..."
                            className="text-sm"
                            rows={2}
                          />
                          <div className="text-xs text-muted-foreground">
                            AI Reasoning: {project.reasoning}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </CardContent>
              </Card>
            </div>

            {/* Action Buttons */}
            <div className="flex gap-2 justify-end">
              <Button
                variant="outline"
                onClick={() => handleReject(item.inboxItem.id)}
                disabled={isProcessing}
              >
                <XCircle className="h-4 w-4 mr-2" />
                Reject & Use Manual
              </Button>
              <Button onClick={() => handleApproval(item.inboxItem.id)} disabled={isProcessing}>
                {isProcessing ? (
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                ) : (
                  <CheckCircle className="h-4 w-4 mr-2" />
                )}
                Approve & Create
              </Button>
            </div>
          </TabsContent>
        ))}
      </Tabs>
    </div>
  );
}



===== src/app/(authorisedRoute)/omni-momentum/_components/MomentumPageLayout.tsx =====
"use client";

import { Suspense } from "react";
import { Card, CardContent } from "@/components/ui";
import { OmniMomentumPage } from "./OmniMomentumPage";
import { useUserProfile } from "@/hooks/use-user-profile";

/**
 * Motivational Header
 * Wellness-appropriate greeting with today's date and user's name
 */
function WellnessHeader(): JSX.Element {
  const { profile, isLoading } = useUserProfile();
  const today = new Date();
  const formattedDate = today.toLocaleDateString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  const hour = today.getHours();
  let greeting = "Good morning";
  if (hour >= 12 && hour < 17) {
    greeting = "Good afternoon";
  } else if (hour >= 17) {
    greeting = "Good evening";
  }

  // Get user's first name or fallback to "there"
  const userName = profile?.displayName?.split(" ")[0] || "there";

  return (
    <div className="mb-8">
      <div className="flex items-center justify-between mb-4">
        <div>
          <h1 className="text-3xl font-bold text-gray-900">
            {greeting} {isLoading ? "..." : userName} ✨
          </h1>
          <p className="text-gray-600 mt-1">{formattedDate} • Your wellness practice awaits</p>
        </div>
      </div>
    </div>
  );
}

/**
 * Main layout component for OmniMomentum
 * Provides static structure and loads client components
 */
export function MomentumPageLayout(): JSX.Element {
  return (
    <div className="container mx-auto p-6 max-w-7xl">
      {/* Wellness Header */}
      <WellnessHeader />

      {/* Main Interactive Content - Client Component */}
      <Suspense
        fallback={
          <Card>
            <CardContent className="p-8 text-center">
              <div className="animate-pulse">
                <div className="h-6 bg-gray-200 rounded w-1/3 mx-auto mb-4"></div>
                <div className="h-4 bg-gray-200 rounded w-1/2 mx-auto"></div>
              </div>
            </CardContent>
          </Card>
        }
      >
        <OmniMomentumPage />
      </Suspense>
    </div>
  );
}



===== src/app/(authorisedRoute)/omni-momentum/_components/MomentumSidebar.tsx =====
"use client";

import {
  Inbox,
  Brain,
  Zap,
  Target,
  BarChart3,
  Plus,
  CheckSquare,
  FolderKanban,
  Calendar
} from "lucide-react";
import Link from "next/link";
import { useRouter, usePathname } from "next/navigation";
import {
  Badge,
  SidebarContent,
  SidebarGroup,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui";
import { useInboxStats } from "@/hooks/use-inbox";

export function MomentumSidebar(): JSX.Element {
  const pathname = usePathname();
  const router = useRouter();
  const { data: inboxStats } = useInboxStats();

  // Handler for selecting "Inbox"
  const handleInboxSelect = (): void => {
    router.push("/omni-momentum");
  };

  return (
    <SidebarContent>
      {/* Quick Capture & Inbox */}
      <SidebarGroup>
        <SidebarGroupLabel>Quick Capture</SidebarGroupLabel>
        <SidebarMenu>
          {/* AI Inbox */}
          <SidebarMenuItem>
            <SidebarMenuButton
              onClick={handleInboxSelect}
              isActive={pathname === "/omni-momentum" || pathname === "/omni-momentum/inbox"}
              tooltip="AI-Powered Inbox"
              className="justify-between w-full"
            >
              <div className="flex items-center gap-3">
                <Inbox className="w-4 h-4" />
                <span>AI Inbox</span>
              </div>
              {inboxStats?.unprocessed && inboxStats.unprocessed > 0 && (
                <Badge
                  variant="outline"
                  className="ml-auto bg-amber-50 border-amber-200 text-amber-700 text-xs"
                >
                  {inboxStats?.unprocessed}
                </Badge>
              )}
            </SidebarMenuButton>
          </SidebarMenuItem>

          {/* Quick Add */}
          <SidebarMenuItem>
            <SidebarMenuButton asChild>
              <Link href="/omni-momentum/quick-add" className="flex items-center w-full">
                <Plus className="w-4 h-4 mr-2" />
                <span className="font-medium">Quick Add</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>
        </SidebarMenu>
      </SidebarGroup>

      {/* Wellness Zones */}
      <SidebarGroup>
        <SidebarGroupLabel>Life-Business Zones</SidebarGroupLabel>
        <SidebarMenu>
          {/* Personal Wellness */}
          <SidebarMenuItem>
            <SidebarMenuButton asChild>
              <Link href="/omni-momentum/zones/personal-wellness" className="flex items-center w-full">
                <Target className="w-4 h-4 mr-2" />
                <span className="font-medium">Personal Wellness</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>

          {/* Self Care */}
          <SidebarMenuItem>
            <SidebarMenuButton asChild>
              <Link href="/omni-momentum/zones/self-care" className="flex items-center w-full">
                <Zap className="w-4 h-4 mr-2" />
                <span className="font-medium">Self Care</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>

          {/* Client Care */}
          <SidebarMenuItem>
            <SidebarMenuButton asChild>
              <Link href="/omni-momentum/zones/client-care" className="flex items-center w-full">
                <CheckSquare className="w-4 h-4 mr-2" />
                <span className="font-medium">Client Care</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>

          {/* Business Development */}
          <SidebarMenuItem>
            <SidebarMenuButton asChild>
              <Link href="/omni-momentum/zones/business-development" className="flex items-center w-full">
                <FolderKanban className="w-4 h-4 mr-2" />
                <span className="font-medium">Business Development</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>

          {/* Social Media & Marketing */}
          <SidebarMenuItem>
            <SidebarMenuButton asChild>
              <Link href="/omni-momentum/zones/social-media-marketing" className="flex items-center w-full">
                <BarChart3 className="w-4 h-4 mr-2" />
                <span className="font-medium">Marketing</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>

          {/* Admin & Finances */}
          <SidebarMenuItem>
            <SidebarMenuButton asChild>
              <Link href="/omni-momentum/zones/admin-finances" className="flex items-center w-full">
                <Calendar className="w-4 h-4 mr-2" />
                <span className="font-medium">Admin & Finances</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>
        </SidebarMenu>
      </SidebarGroup>

      {/* Planning & Analytics */}
      <SidebarGroup>
        <SidebarGroupLabel>Wellness Intelligence</SidebarGroupLabel>
        <SidebarMenu>
          {/* AI Insights */}
          <SidebarMenuItem>
            <SidebarMenuButton asChild>
              <Link href="/omni-momentum/insights" className="flex items-center w-full">
                <Brain className="w-4 h-4 mr-2" />
                <span className="font-medium">AI Insights</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>

          {/* Daily Pulse */}
          <SidebarMenuItem>
            <SidebarMenuButton asChild>
              <Link href="/omni-momentum/pulse" className="flex items-center w-full">
                <BarChart3 className="w-4 h-4 mr-2" />
                <span className="font-medium">Daily Pulse</span>
              </Link>
            </SidebarMenuButton>
          </SidebarMenuItem>
        </SidebarMenu>
      </SidebarGroup>
    </SidebarContent>
  );
}


===== src/app/(authorisedRoute)/omni-momentum/_components/OmniMomentumPage.tsx =====
"use client";

import { useState } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  Button,
  Textarea,
} from "@/components/ui";
import { Zap, Mic, Send, Sparkles, TrendingUp } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
// ✅ Following DTO/Repository architecture - hooks use repository pattern internally
import { useZones } from "@/hooks/use-zones";
import { TodaysFocusSection } from "./TodaysFocusSection";
import { DailyPulseWidget } from "./DailyPulseWidget";
import { HabitTrackers } from "./HabitTrackers";
import { SimpleInboxCapture } from "./SimpleInboxCapture";

// Configuration constants
const CONFIG = {
  MAX_ZONES_DISPLAYED: 6,
  CARD_HEIGHT: "35rem",
} as const;

/**
 * QuickCaptureInput - The "Dump Everything" Interface
 *
 * Research findings:
 * - Wellness practitioners need to quickly capture thoughts between sessions
 * - Voice input preferred for hands-free capture during treatments
 * - Simple text input as fallback
 * - Immediate feedback on capture success
 * - Integration with AI processing for intelligent categorization
 */
function QuickCaptureInput(): JSX.Element {
  const [inputText, setInputText] = useState("");
  const [isRecording, setIsRecording] = useState(false);
  const { toast } = useToast();

  const handleSubmit = async (): Promise<void> => {
    if (!inputText.trim()) return;

    try {
      // TODO: Implement actual API call to capture inbox item
      // For now, just show success feedback
      toast({
        title: "Captured! 📝",
        description: "Your thought has been queued for intelligent processing.",
      });

      setInputText("");
    } catch (error) {
      toast({
        title: "Capture Failed",
        description: "Please try again or use the full inbox interface.",
        variant: "destructive",
      });
    }
  };

  const handleVoiceCapture = (): void => {
    // TODO: Implement voice capture functionality
    setIsRecording(true);
    toast({
      title: "Voice Capture",
      description: "Voice input coming soon! Use text input for now.",
    });
    setTimeout(() => setIsRecording(false), 2000);
  };

  return (
    <Card className="bg-gradient-to-r from-purple-50 to-pink-50 border-purple-200 h-[35rem] flex flex-col">
      <CardHeader className="pb-4 flex-shrink-0">
        <CardTitle className="flex items-center gap-2 text-lg">
          <Zap className="w-5 h-5 text-purple-500" />
          Quick Capture
        </CardTitle>
        <CardDescription>Dump your thoughts and ideas for intelligent processing</CardDescription>
      </CardHeader>

      <CardContent className="space-y-4 flex-1 flex flex-col">
        {/* Voice Capture Button */}
        <Button
          onClick={handleVoiceCapture}
          disabled={isRecording}
          className="w-full h-12 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white"
        >
          {isRecording ? (
            <>
              <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin mr-2" />
              Recording...
            </>
          ) : (
            <>
              <Mic className="w-4 h-4 mr-2" />
              Voice Capture
            </>
          )}
        </Button>

        {/* Text Input */}
        <div className="flex-1 flex flex-col">
          <Textarea
            placeholder="Type your thoughts, ideas, or tasks here... The AI will intelligently categorize and process them."
            value={inputText}
            onChange={(e) => setInputText(e.target.value)}
            className="flex-1 min-h-[200px] resize-none"
            onKeyDown={(e) => {
              if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
                handleSubmit();
              }
            }}
          />
        </div>

        {/* Submit Button */}
        <Button
          onClick={handleSubmit}
          disabled={!inputText.trim()}
          className="w-full bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white"
        >
          <Send className="w-4 h-4 mr-2" />
          Capture & Process
        </Button>

        {/* Quick Tips */}
        <div className="text-xs text-gray-500 space-y-1">
          <p>💡 Tip: Use Cmd/Ctrl + Enter to quickly submit</p>
          <p>🤖 AI will automatically categorize your input</p>
        </div>
      </CardContent>
    </Card>
  );
}

/**
 * Wellness Zone Status Widget
 * Shows current status of different life-business zones
 */
function WellnessZoneStatus(): JSX.Element {
  const { zones } = useZones();

  const getZoneStatus = (zoneName: string): string => {
    // Mock status - in real implementation, this would come from actual data
    const statuses = ["active", "pending", "completed", "overdue"];
    return statuses[Math.floor(Math.random() * statuses.length)] || "pending";
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case "active":
        return "bg-green-100 text-green-800 border-green-200";
      case "pending":
        return "bg-yellow-100 text-yellow-800 border-yellow-200";
      case "completed":
        return "bg-blue-100 text-blue-800 border-blue-200";
      case "overdue":
        return "bg-red-100 text-red-800 border-red-200";
      default:
        return "bg-gray-100 text-gray-800 border-gray-200";
    }
  };

  return (
    <Card className="bg-gradient-to-r from-amber-50 to-orange-50 border-amber-200 h-[35rem] flex flex-col">
      <CardHeader className="pb-4 flex-shrink-0">
        <CardTitle className="flex items-center gap-2 text-lg">
          <TrendingUp className="w-5 h-5 text-amber-500" />
          Zone Status
        </CardTitle>
        <CardDescription>Current status of your wellness zones</CardDescription>
      </CardHeader>

      <CardContent className="space-y-3 flex-1 overflow-y-auto [&::-webkit-scrollbar]:hidden [-ms-overflow-style:none] [scrollbar-width:none]">
        {zones.slice(0, CONFIG.MAX_ZONES_DISPLAYED).map((zone) => {
          const status = getZoneStatus(zone.name);
          return (
            <div
              key={zone.id}
              className="p-3 bg-white rounded-lg border hover:shadow-sm transition-shadow"
            >
              <div className="flex items-center justify-between mb-2">
                <h4 className="text-sm font-medium text-gray-900">{zone.name}</h4>
                <span
                  className={`px-2 py-1 rounded-full text-xs font-medium border ${getStatusColor(
                    status,
                  )}`}
                >
                  {status}
                </span>
              </div>
              <p className="text-xs text-gray-500">No description available</p>
            </div>
          );
        })}

        {zones.length === 0 && (
          <div className="text-center py-8">
            <Sparkles className="w-12 h-12 text-gray-300 mx-auto mb-4" />
            <p className="text-sm text-gray-500 mb-2">No zones configured yet</p>
            <p className="text-xs text-gray-400">
              Set up your wellness zones to track your progress
            </p>
          </div>
        )}
      </CardContent>
    </Card>
  );
}

/**
 * Main OmniMomentum Page Component
 *
 * Optimized layout:
 * - Top row: Daily Pulse (1/3) + Habit Trackers (1/3) + Quick Capture (1/3)
 * - Second row: Today's Focus (2/3) + Wellness Zone Status (1/3)
 * - Bottom: Consolidated Wellness Zones (no duplication)
 */
export function OmniMomentumPage(): JSX.Element {
  return (
    <div className="space-y-6">
      {/* Top Row: Daily Pulse + Habit Trackers + Quick Capture */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 items-stretch">
        {/* Daily Pulse - 1/3 */}
        <div className="lg:col-span-1">
          <DailyPulseWidget />
        </div>

        {/* Habit Trackers - 1/3 */}
        <div className="lg:col-span-1">
          <HabitTrackers />
        </div>

        {/* Quick Capture - 1/3 */}
        <div className="lg:col-span-1">
          <QuickCaptureInput />
        </div>
      </div>

      {/* Second Row: Today's Focus + Wellness Zone Status */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Today's Focus - 2/3 */}
        <div className="lg:col-span-2">
          <TodaysFocusSection />
        </div>

        {/* Wellness Zone Status - 1/3 */}
        <div className="lg:col-span-1">
          <WellnessZoneStatus />
        </div>
      </div>

      {/* Bottom Row: Simple Inbox Capture (Full Width) */}
      <div className="w-full">
        <SimpleInboxCapture />
      </div>
    </div>
  );
}



===== src/app/(authorisedRoute)/omni-momentum/_components/SimpleInboxCapture.tsx =====
/**
 * Simple Inbox Capture Component
 *
 * This component provides a simple interface for users to dump their thoughts
 * and queue them for background intelligent processing.
 */

"use client";

import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Loader2, Brain, CheckCircle, AlertTriangle, Clock, Zap } from "lucide-react";
import { toast } from "sonner";

interface QueueStats {
  totalQueued: number;
  highPriority: number;
  mediumPriority: number;
  lowPriority: number;
  isAvailable: boolean;
}

export function SimpleInboxCapture(): JSX.Element {
  const [rawText, setRawText] = useState("");
  const [enableIntelligentProcessing, setEnableIntelligentProcessing] = useState(true);
  const [isLoading, setIsLoading] = useState(false);
  const [queueStats, setQueueStats] = useState<QueueStats | null>(null);
  const [isAvailable, setIsAvailable] = useState(false);

  // Load queue stats and availability
  const loadStats = async () => {
    try {
      const response = await fetch("/api/omni-momentum/inbox/queue");
      if (response.ok) {
        const data = await response.json();
        setQueueStats(data);
        setIsAvailable(data.isAvailable);
      }
    } catch (error) {
      console.error("Failed to load queue stats:", error);
    }
  };

  // Load availability status
  const loadAvailability = async () => {
    try {
      const response = await fetch("/api/omni-momentum/inbox/queue?action=status");
      if (response.ok) {
        const data = await response.json();
        setIsAvailable(data.isAvailable);
      }
    } catch (error) {
      console.error("Failed to load availability:", error);
    }
  };

  useEffect(() => {
    loadStats();
    loadAvailability();
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!rawText.trim()) {
      return;
    }

    setIsLoading(true);

    try {
      const response = await fetch("/api/omni-momentum/inbox/intelligent", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          rawText,
          enableIntelligentProcessing,
          priority: "medium",
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to queue item for processing");
      }

      const result = await response.json();

      if (result.queued) {
        toast.success(result.message);
        setRawText("");
        // Reload stats to show updated queue
        await loadStats();
      } else {
        toast.success(result.message);
        setRawText("");
      }
    } catch (error) {
      console.error("Failed to queue item:", error);
      toast.error("Failed to queue item for processing");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="space-y-6">
      {/* Queue Stats Overview */}
      {queueStats && (
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-2">
                <Clock className="h-4 w-4 text-blue-500" />
                <div>
                  <div className="text-2xl font-bold">{queueStats.totalQueued}</div>
                  <div className="text-xs text-muted-foreground">Items Queued</div>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-2">
                <AlertTriangle className="h-4 w-4 text-orange-500" />
                <div>
                  <div className="text-2xl font-bold">{queueStats.highPriority}</div>
                  <div className="text-xs text-muted-foreground">High Priority</div>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-2">
                <CheckCircle className="h-4 w-4 text-green-500" />
                <div>
                  <div className="text-2xl font-bold">{queueStats.mediumPriority}</div>
                  <div className="text-xs text-muted-foreground">Medium Priority</div>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-2">
                {isAvailable ? (
                  <Zap className="h-4 w-4 text-green-500" />
                ) : (
                  <AlertTriangle className="h-4 w-4 text-red-500" />
                )}
                <div>
                  <div className="text-2xl font-bold">{isAvailable ? "ON" : "OFF"}</div>
                  <div className="text-xs text-muted-foreground">AI Status</div>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Quick Capture Form */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Brain className="h-5 w-5" />
            Dump Everything Here
          </CardTitle>
          <CardDescription>
            Just dump your thoughts and let AI intelligently organize them into tasks and projects.
            Processing happens in the background - you'll see your organized tasks tomorrow!
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div className="space-y-2">
              <Textarea
                value={rawText}
                onChange={(e) => setRawText(e.target.value)}
                placeholder="Dump everything here... e.g., 'Call John about project proposal, finish quarterly report by Friday, book dentist appointment, organize team meeting for next week, need to buy groceries, schedule car maintenance'"
                className="min-h-[120px] resize-none"
                disabled={isLoading}
              />
              <div className="text-xs text-muted-foreground">{rawText.length} characters</div>
            </div>

            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                <Switch
                  id="intelligent-processing"
                  checked={enableIntelligentProcessing}
                  onCheckedChange={setEnableIntelligentProcessing}
                  disabled={!isAvailable || isLoading}
                />
                <label htmlFor="intelligent-processing" className="text-sm font-medium">
                  Enable AI Processing
                </label>
                {!isAvailable && (
                  <Badge variant="destructive" className="text-xs">
                    AI Unavailable
                  </Badge>
                )}
              </div>

              <Button
                type="submit"
                disabled={
                  !rawText.trim() || isLoading || (!isAvailable && enableIntelligentProcessing)
                }
                className="min-w-[120px]"
              >
                {isLoading ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    Queuing...
                  </>
                ) : (
                  <>
                    <Brain className="h-4 w-4 mr-2" />
                    Dump & Queue
                  </>
                )}
              </Button>
            </div>
          </form>
        </CardContent>
      </Card>

      {/* Processing Info */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">How It Works</CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
            <div>
              <h4 className="font-medium mb-2">🤖 Background Processing</h4>
              <ul className="space-y-1 text-muted-foreground">
                <li>• Items are queued for AI processing</li>
                <li>• Processing happens twice daily</li>
                <li>• Tasks appear in your dashboard tomorrow</li>
                <li>• No need to wait or approve</li>
              </ul>
            </div>
            <div>
              <h4 className="font-medium mb-2">📋 What AI Does</h4>
              <ul className="space-y-1 text-muted-foreground">
                <li>• Splits bulk input into individual tasks</li>
                <li>• Categorizes by zones (Life, Business, etc.)</li>
                <li>• Groups related tasks into projects</li>
                <li>• Sets priorities and due dates</li>
              </ul>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Queue Status Alert */}
      {queueStats && queueStats.totalQueued > 0 && (
        <Alert>
          <Clock className="h-4 w-4" />
          <AlertDescription>
            You have {queueStats.totalQueued} item{queueStats.totalQueued !== 1 ? "s" : ""} queued
            for processing. They will be processed in the next batch run.
          </AlertDescription>
        </Alert>
      )}
    </div>
  );
}



===== src/app/(authorisedRoute)/omni-momentum/_components/TodaysFocusSection.tsx =====
"use client";

import { useMemo, useState } from "react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  Button,
  Badge,
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui";
import { format } from "date-fns";
import { Brain, Clock, Target, Inbox, Sparkles } from "lucide-react";
import { useInbox } from "@/hooks/use-inbox";
import type { InboxItem } from "@/server/db/business-schemas/productivity";

export function TodaysFocusSection(): JSX.Element {
  const { items, isLoading } = useInbox({
    filters: { status: ["unprocessed", "processed"] },
  });
  const [selectedItem, setSelectedItem] = useState<InboxItem | null>(null);

  const { focusItems, remainingItems } = useMemo(() => {
    const unprocessed = items.filter((item: InboxItem) => item.status === "unprocessed");
    return {
      focusItems: unprocessed.slice(0, 3),
      remainingItems: unprocessed.slice(3),
    };
  }, [items]);

  const handleProcessItem = (item: InboxItem): void => {
    setSelectedItem(item);
  };

  const handleDialogChange = (open: boolean): void => {
    if (!open) {
      setSelectedItem(null);
    }
  };

  const computeWordCount = (item: InboxItem): number => {
    const candidate = (item as { wordCount?: unknown }).wordCount;
    if (typeof candidate === "number" && Number.isFinite(candidate)) {
      return Math.max(candidate, 1);
    }
    const tokens = item.rawText.trim().split(/\s+/).filter(Boolean);
    return tokens.length > 0 ? tokens.length : 1;
  };

  const formatCreatedAt = (value: InboxItem["createdAt"]): string | null => {
    if (!value) return null;
    const date = new Date(value as unknown as Date | string | number);
    if (Number.isNaN(date.getTime())) return null;
    return format(date, "MMM d, h:mm a");
  };

  if (isLoading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Target className="w-5 h-5 text-blue-500" />
            Today&apos;s Focus
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-3">
            {[1, 2, 3].map((i) => (
              <div key={i} className="animate-pulse">
                <div className="h-16 bg-gray-100 rounded-lg" />
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <>
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Target className="w-5 h-5 text-blue-500" />
            Today&apos;s Focus
          </CardTitle>
          <CardDescription>Your top 3 priorities. Keep it simple, stay focused.</CardDescription>
        </CardHeader>
        <CardContent>
          {focusItems.length === 0 ? (
            <div className="text-center py-8">
              <Target className="w-12 h-12 mx-auto text-gray-300 mb-4" />
              <h3 className="font-medium text-gray-900 mb-2">Ready to focus?</h3>
              <p className="text-gray-500 text-sm">
                Use Quick Capture above to add your thoughts and priorities.
              </p>
            </div>
          ) : (
            <div className="space-y-4">
              {focusItems.map((item: InboxItem, index: number) => (
                <div
                  key={item.id}
                  className="flex items-start gap-4 p-4 bg-white rounded-lg border-2 border-blue-100 hover:border-blue-200 transition-colors"
                >
                  <div className="flex items-center justify-center w-8 h-8 bg-blue-500 text-white rounded-full text-lg font-bold flex-shrink-0">
                    {index + 1}
                  </div>
                  <div className="flex-1 min-w-0">
                    <p className="text-base text-gray-900 mb-2 line-clamp-3">{item.rawText}</p>
                    <div className="flex flex-wrap items-center gap-2 text-xs text-gray-500">
                      <span className="inline-flex items-center gap-1">
                        <Clock className="w-3 h-3" />
                        {formatCreatedAt(item.createdAt) ?? "Just now"}
                      </span>
                      <Badge variant="outline" className="ml-2">
                        {computeWordCount(item)} words
                      </Badge>
                    </div>
                  </div>
                  <Button
                    size="sm"
                    variant="default"
                    className="flex-shrink-0 bg-blue-600 hover:bg-blue-700"
                    onClick={() => handleProcessItem(item)}
                  >
                    <Brain className="w-4 h-4 mr-1.5" />
                    Process
                  </Button>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {remainingItems.length > 0 && (
        <Card className="mt-6">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Inbox className="w-5 h-5 text-gray-600" />
            </CardTitle>
            <CardDescription>
              These will move to your top priorities as you process the items above.
            </CardDescription>
          </CardHeader>
            <CardContent>
            <div className="space-y-2">
              {remainingItems.map((item: InboxItem) => (
                <div
                  key={item.id}
                  className="flex items-center gap-3 p-3 bg-gray-50 rounded-lg border hover:bg-gray-100 transition-colors"
                >
                  <div className="flex-1 min-w-0">
                    <p className="text-sm text-gray-900 line-clamp-1">{item.rawText}</p>
                    <div className="flex items-center gap-2 text-xs text-gray-500 mt-1">
                      <Clock className="w-3 h-3" />
                      {formatCreatedAt(item.createdAt) ?? "Just now"}
                    </div>
                  </div>
                  <Button
                    size="sm"
                    variant="outline"
                    className="flex-shrink-0"
                    onClick={() => handleProcessItem(item)}
                  >
                    <Brain className="w-4 h-4 mr-1" />
                    Process
                  </Button>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      <Dialog open={selectedItem !== null} onOpenChange={handleDialogChange}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <Brain className="w-5 h-5 text-blue-600" />
              AI Processing
            </DialogTitle>
            <DialogDescription>
              AI-powered categorization will be available in Phase 2.
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            <div className="p-4 bg-blue-50 rounded-lg border border-blue-200">
              <p className="text-sm text-gray-700 font-medium mb-2">Item to process:</p>
              <p className="text-sm text-gray-900">{selectedItem?.rawText}</p>
            </div>
            <div className="p-4 bg-gray-50 rounded-lg border">
              <p className="text-sm text-gray-600">
                <span className="font-semibold">Coming soon:</span> AI will analyze this item and
                suggest the best category (Task, Project, Zone, or Note) with intelligent
                recommendations.
              </p>
            </div>
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => handleDialogChange(false)}>
                Close
              </Button>
              <Button
                variant="default"
                className="bg-blue-600 hover:bg-blue-700"
                onClick={() => handleDialogChange(false)}
              >
                <Sparkles className="w-4 h-4 mr-1" />
                OK, Got It
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
}



===== src/app/(authorisedRoute)/omni-momentum/page.tsx =====
import type { Metadata } from "next";
import { redirect } from "next/navigation";
import { getServerUserId } from "@/server/auth/user";
import { MomentumPageLayout } from "./_components/MomentumPageLayout";

export const metadata: Metadata = {
  title: "OmniMomentum · OmniCRM",
  description:
    "AI-powered productivity suite for wellness practitioners. Dump everything, let AI organize into life-business zones with intelligent task prioritization.",
};

/**
 * Server Component for OmniMomentum Productivity Suite
 *
 * Handles server-side authentication and provides the foundation for
 * the wellness practitioner's AI-powered task management system.
 *
 * Research-driven design:
 * - Progressive disclosure interface to prevent overwhelm
 * - Wellness-appropriate terminology (Pathways, Pulse, Journey)
 * - Mobile-first for between-session task capture
 * - Invisible AI integration for seamless categorization
 */
export default async function Page(): Promise<React.ReactNode> {
  // Server-side authentication check
  try {
    await getServerUserId();
  } catch {
    redirect("/login?next=/omni-momentum");
  }

  // Server component renders the layout with static elements
  // All interactive functionality handled by client components within
  return <MomentumPageLayout />;
}


===== src/app/(authorisedRoute)/omni-momentum/README.md =====
# OmniMomentum - AI-Powered Productivity Suite

**Status**: ✅ FULLY IMPLEMENTED - Backend + Frontend Complete
**Architecture**: DTO/Repository/Service Pattern with React Query Frontend
**Compliance**: Technical Debt Elimination Standards (Zero-Tolerance Achieved)

---

## Overview

OmniMomentum is the AI-powered productivity suite designed specifically for wellness practitioners. It provides an intelligent "dump everything" inbox where users can capture thoughts, tasks, and ideas, which are then automatically categorized into 6 life-business zones using AI.

### Key Features

- **AI-Powered Inbox**: "Dump everything" interface with intelligent categorization
- **Today's Focus**: Research-driven approach showing max 3 priorities to avoid overwhelm
- **Daily Pulse**: Wellness check-in with energy ratings, sleep tracking, and mood assessment
- **Wellness Zones**: 6 core life-business areas for holistic practice management
- **Progressive Disclosure**: Only shows what matters now, preventing cognitive overload

---

## Full-Stack Architecture

### Complete Infrastructure Stack

OmniMomentum implements a complete full-stack architecture following enterprise patterns:

```bash
Full-Stack Architecture:
├── Frontend (Client Components)
│   ├── React Query + TanStack Table
│   ├── shadcn/ui Components
│   └── Optimistic Updates
├── API Layer
│   ├── Next.js App Router API Routes
│   ├── Standardized Handlers (handleAuth, handleGetWithQueryAuth)
│   └── CSRF Protection
├── Service Layer
│   ├── MomentumService (Business Logic)
│   ├── Filtering & Validation
│   └── Data Transformation
├── Repository Layer
│   ├── MomentumRepository (Data Access)
│   ├── Drizzle ORM with Type Guards
│   └── Async getDb() Pattern
└── Database Schema
    ├── Supabase PostgreSQL
    ├── Row Level Security
    └── Comprehensive OmniMomentum Tables
```

### Backend Infrastructure (FULLY COMPLETED)

**Service layer is split into focused modules**

```typescript
// src/server/services/projects.service.ts
export async function createProjectService(userId: string, data: {...}): Promise<Project>
export async function getProjectService(userId: string, projectId: string): Promise<Project | null>
export async function listProjectsService(userId: string, filters?: {...}): Promise<Project[]>
export async function updateProjectService(projectId: string, userId: string, data: {...}): Promise<Project | null>
export async function deleteProjectService(userId: string, projectId: string): Promise<void>

// src/server/services/tasks.service.ts
export async function createTaskService(userId: string, data: {...}): Promise<TaskListItem>
export async function getTaskService(userId: string, taskId: string): Promise<TaskListItem | null>
export async function listTasksService(userId: string, filters?: {...}): Promise<TaskListItem[]>
export async function updateTaskService(taskId: string, userId: string, data: {...}): Promise<TaskListItem | null>
export async function deleteTaskService(userId: string, taskId: string): Promise<void>
export async function getProjectTasksService(userId: string, projectId: string, filters?: {...}): Promise<TaskListItem[]>
export async function getSubtasksService(userId: string, parentTaskId: string, filters?: {...}): Promise<TaskListItem[]>
export async function getPendingApprovalTasksService(userId: string): Promise<TaskListItem[]>
export async function approveTaskService(userId: string, taskId: string): Promise<TaskListItem>
export async function rejectTaskService(userId: string, taskId: string, reason?: string): Promise<TaskListItem>

// src/server/services/zones.service.ts
export async function listZonesService(): Promise<Zone[]>
export async function getZonesWithStatsService(userId: string): Promise<ZoneWithStats[]>

// src/server/services/inbox.service.ts
export async function quickCaptureService(userId: string, data: {...}): Promise<InboxItem>
export async function voiceCaptureService(userId: string, data: {...}): Promise<InboxItem>
export async function listInboxItemsService(userId: string, filters?: {...}): Promise<InboxItem[]>
export async function getInboxStatsService(userId: string): Promise<{...}>
export async function processInboxItemService(userId: string, data: {...}): Promise<InboxProcessingResultDTO>
export async function bulkProcessInboxService(userId: string, data: {...}): Promise<{...}>

// src/server/services/productivity.service.ts
// Re-exports all project, task, and zone services + UI enrichment mappers
```

#### API Routes (Complete Set)

```bash
# All API endpoints use standardized handlers from @/lib/api

# Projects
src/app/api/omni-momentum/projects/route.ts
  GET  - List projects (handleGetWithQueryAuth)
  POST - Create project (handleAuth)

src/app/api/omni-momentum/projects/[projectId]/route.ts
  GET    - Get project by ID (handleAuth)
  PUT    - Update project (handleAuth)
  DELETE - Delete project (handleAuth)

src/app/api/omni-momentum/projects/[projectId]/tasks/route.ts
  GET - Get tasks within project (handleGetWithQueryAuth)

# Tasks
src/app/api/omni-momentum/tasks/route.ts
  GET  - List tasks (handleGetWithQueryAuth)
  POST - Create task (handleAuth)

src/app/api/omni-momentum/tasks/[taskId]/route.ts
  GET    - Get task by ID (handleAuth)
  PUT    - Update task (handleAuth)
  DELETE - Delete task (handleAuth)

src/app/api/omni-momentum/tasks/[taskId]/subtasks/route.ts
  GET  - Get subtasks (handleGetWithQueryAuth)
  POST - Create subtask (handleAuth)

src/app/api/omni-momentum/tasks/[taskId]/approve/route.ts
  POST - Approve task (handleAuth)

src/app/api/omni-momentum/tasks/[taskId]/reject/route.ts
  POST - Reject task (handleAuth)

src/app/api/omni-momentum/tasks/pending-approval/route.ts
  GET - Get pending approval tasks (handleGetWithQueryAuth)

# Inbox
src/app/api/omni-momentum/inbox/route.ts
  GET  - List inbox items or get stats (handleGetWithQueryAuth)
  POST - Quick/voice capture or bulk process (handleAuth)

src/app/api/omni-momentum/inbox/[itemId]/route.ts
  GET    - Get inbox item (handleAuth)
  PATCH  - Update inbox item (handleAuth)
  DELETE - Delete inbox item (handleAuth)

src/app/api/omni-momentum/inbox/process/route.ts
  POST - AI process single inbox item (handleAuth)

# Zones
src/app/api/omni-momentum/zones/route.ts
  GET - List zones or zones with stats (handleGetWithQueryAuth)
```

### Frontend Architecture

**✅ React Query Hooks** (`src/hooks/use-momentum.ts`)

```typescript
// Note: This hook may need to be split into focused hooks per domain
export function useMomentum() {
  // Projects
  const { data: projects } = useQuery({ queryKey: ['/api/omni-momentum/projects'], ... })
  const createProject = useMutation({ mutationFn: (data) => fetchPost('/api/omni-momentum/projects', data), ... })
  
  // Tasks
  const { data: tasks } = useQuery({ queryKey: ['/api/omni-momentum/tasks'], ... })
  const createTask = useMutation({ mutationFn: (data) => fetchPost('/api/omni-momentum/tasks', data), ... })
  
  // Inbox
  const { data: inboxItems } = useQuery({ queryKey: ['/api/omni-momentum/inbox'], ... })
  const quickCapture = useMutation({ mutationFn: (data) => fetchPost('/api/omni-momentum/inbox', { type: 'quick_capture', data }), ... })
  
  // Zones
  const { data: zones } = useQuery({ queryKey: ['/api/omni-momentum/zones'], ... })
}
```

**✅ UI Components** (`src/app/(authorisedRoute)/omni-momentum/_components/`)

```bash
_components/
  MomentumPageLayout.tsx    # Main layout wrapper
  MomentumSidebar.tsx       # Navigation sidebar
  OmniMomentumPage.tsx      # Main page component
  # Additional components as needed
  // ✅ Real-time query invalidation

  return {
    // Query data
    projects: ProjectDTO[],
    tasks: TaskDTO[],
    stats: MomentumStats,

    // Actions with proper typing
    createProject: (data: CreateProjectDTO) => void,
    updateTask: (taskId: string, data: UpdateTaskDTO) => void,
    bulkUpdateTasks: (data: BulkTaskUpdateDTO) => void,
    // ... All operations implemented
  };
}
```

#### ✅ Component Architecture

```bash
omni-momentum/
├── page.tsx                    # Server component - auth & metadata
├── _components/
│   ├── MomentumPageLayout.tsx  # Static layout shell (server-rendered)
│   ├── DailyPulseWidget.tsx    # Wellness check-in (client)
│   ├── OmniMomentumPage.tsx    # Main dashboard (client)
│   ├── TodaysFocusSection.tsx  # Focus management (client)
│   └── MomentumSidebar.tsx     # Navigation (client)
```

### Technical Compliance (Zero-Tolerance Achieved)

#### ✅ TypeScript Strict Mode Compliance

- **Zero `any` types** - All functions properly typed
- **No type assertions** - Type guards used throughout
- **Explicit return types** - Required on all functions
- **Runtime validation** - Zod schemas in DTOs provide safety

#### ✅ Database Connection Pattern

```typescript
// ✅ CORRECT Pattern (used throughout)
import { getDb } from "@/server/db/client";
const db = await getDb();

// ❌ BROKEN Pattern (eliminated)
import { db } from "@/server/db"; // Causes runtime errors
```

#### ✅ Array Filtering with Type Guards

```typescript
// ✅ Proper implementation in momentum.repo.ts
if (filters.status && filters.status.length > 0) {
  const validStatuses = filters.status.filter((status): status is TaskStatus =>
    ["todo", "in_progress", "done", "canceled"].includes(status)
  );
  if (validStatuses.length > 0) {
    whereConditions.push(inArray(tasks.status, validStatuses));
  }
}
```

#### ✅ Standardized Handler Pattern

```typescript
// ❌ DEPRECATED: Manual NextRequest/NextResponse
// All API routes now use standardized handlers from @/lib/api

import { handleGetWithQueryAuth } from "@/lib/api";
import { ProjectFiltersSchema, ProjectListResponseSchema } from "@/server/db/business-schemas";

export const GET = handleGetWithQueryAuth(
  ProjectFiltersSchema,
  ProjectListResponseSchema,
  async (filters, userId) => {
    return await listProjectsService(userId, filters);
  }
);
```

**See `docs/REFACTORING_PATTERNS_OCT_2025.md` for current patterns.**

---

## Research-Driven Design

### Wellness Practitioner Research Findings

Based on `docs/roadmap/implementation/RhythmModuleResearch.md`:

#### 1. **78% Prefer Simple Lists**

```typescript
// ✅ Implementation: Today's Focus limits to 3 items max
const focusItems = items
  .filter(item => item.status === "unprocessed")
  .slice(0, 3); // Hard limit per research findings
```

#### 2. **"Dump Everything" AI Inbox**

- **Top requested feature** among wellness practitioners
- Invisible AI processing (no overwhelming tech terminology)
- Quick capture between client sessions

#### 3. **Wellness Terminology**

- **"Focus"** instead of "Tasks"
- **"Pathways"** instead of "Projects"
- **"Journey"** instead of "Goals"
- **"Pulse"** instead of "Analytics"

#### 4. **Mobile-First Design**

- Large touch targets (44x44 pixels minimum)
- Quick capture accessible with minimal taps
- Fast loading of priority information

---

## Component Architecture

### Core Components

#### 1. **QuickCaptureInput**

```typescript
// AI-powered "dump everything" interface
function QuickCaptureInput(): JSX.Element {
  // ✅ Proper DTO validation
  const data: CreateInboxItemDTO = {
    rawText: rawText.trim(),
  };

  // ✅ No floating promises
  void quickCapture(data);
}
```

**Features:**

- Prominent placement for rapid thought capture
- ⌘+Enter keyboard shortcut for speed
- Voice integration placeholder (future enhancement)
- Wellness-appropriate messaging and feedback

#### 2. **TodaysFocusSection**

```typescript
// Research-driven: Max 3 priorities to avoid overwhelm
export function TodaysFocusSection(): JSX.Element {
  const focusItems = items
    .filter(item => item.status === "unprocessed")
    .slice(0, 3); // Hard research-based limit
}
```

**Features:**

- Maximum 3 priorities shown at once
- Simple list view (not Kanban boards)
- Progressive disclosure interface
- Process button for AI categorization

#### 3. **DailyPulseWidget**

```typescript
// Wellness check-in based on practitioner patterns
interface DailyPulseData {
  energyLevel: number; // 1-5 stars
  sleepHours: number;  // 3-7+ hours
  napMinutes: number;  // 0-60 minutes
  mood: string;        // Emoji-based selection
}
```

**Features:**

- 1-5 star energy rating (intuitive for practitioners)
- 3-7+ hour sleep slider (real practitioner patterns)
- Mood emoji selection with wellness language
- Quick morning input designed for friction-free use

#### 4. **MomentumSidebar**

```typescript
// Wellness-focused navigation with live stats
export function MomentumSidebar(): JSX.Element {
  const { data: stats } = useInboxStats();

  // Shows unprocessed count badge for motivation
  return (
    <SidebarContent>
      {/* Wellness terminology throughout */}
    </SidebarContent>
  );
}
```

**Navigation Structure:**

- **Your Momentum**: Focus Dashboard, Today's Focus, Quick Capture
- **Life + Business Zones**: Pathways, Journey, Tasks & Actions
- **Wellness Intelligence**: Daily Pulse, Flow Analytics, Rhythm Sync

---

## Integration Points

### 1. **Sidebar Navigation Integration**

```typescript
// AppSidebarController.tsx routing
if (pathname.startsWith("/omni-momentum")) {
  return <MomentumSidebar />;
}
```

### 2. **Backend API Integration (FULLY IMPLEMENTED)**

**Complete Architecture Flow:**

```typescript
// 1. Frontend Hook (src/hooks/use-momentum.ts)
const { projects, createProject } = useMomentum();

// 2. API Route (src/app/api/omni-momentum/projects/route.ts)
export const POST = handleAuth(
  CreateProjectSchema,
  ProjectSchema,
  async (data, userId) => {
    return await createProjectService(userId, data);
  }
);

// 3. Service Layer (src/server/services/projects.service.ts)
export async function createProjectService(userId: string, data: {...}): Promise<Project> {
  const db = await getDb();
  const repo = createProductivityRepository(db);
  try {
    return await repo.createProject(userId, data);
  } catch (error) {
    throw new AppError(...);
  }
}

// 4. Repository Layer (packages/repo/src/productivity.repo.ts)
export class ProductivityRepository {
  constructor(private readonly db: DbClient) {}

  // Projects
  async createProject(userId: string, data: Omit<CreateProject, 'userId'>): Promise<ProjectListItem>
  async getProjects(userId: string, filters?: {...}): Promise<ProjectListItem[]>
  async getProject(projectId: string, userId: string): Promise<ProjectListItem | null>
  async updateProject(projectId: string, userId: string, data: Partial<{...}>): Promise<void>
  async deleteProject(projectId: string, userId: string): Promise<void>

  // Tasks
  async createTask(userId: string, data: Omit<CreateTask, 'userId'>): Promise<TaskListItem>
  async getTasks(userId: string, filters?: {...}): Promise<TaskListItem[]>
  async getTask(taskId: string, userId: string): Promise<TaskListItem | null>
  async updateTask(taskId: string, userId: string, data: Partial<{...}>): Promise<void>
  async deleteTask(taskId: string, userId: string): Promise<void>
  async getProjectTasks(userId: string, projectId: string, filters?: {...}): Promise<TaskListItem[]>
  async getSubtasks(userId: string, parentTaskId: string, filters?: {...}): Promise<TaskListItem[]>
  async getPendingApprovalTasks(userId: string): Promise<TaskListItem[]>
}

export function createProductivityRepository(db: DbClient): ProductivityRepository

// packages/repo/src/zones.repo.ts
export class ZonesRepository {
  constructor(private readonly db: DbClient) {}
  async listZones(): Promise<Zone[]>
  async getZoneWithStats(userId: string, zoneId: number): Promise<ZoneWithStats | null>
  async listZonesWithStats(userId: string): Promise<ZoneWithStats[]>
}

export function createZonesRepository(db: DbClient): ZonesRepository

// packages/repo/src/inbox.repo.ts
export class InboxRepository {
  constructor(private readonly db: DbClient) {}
  async createInboxItem(data: {...}): Promise<InboxItem>
  async listInboxItems(userId: string, filters?: InboxFilters): Promise<InboxItem[]>
  async getInboxItemById(userId: string, itemId: string): Promise<InboxItem | null>
  async updateInboxItem(userId: string, itemId: string, data: Partial<{...}>): Promise<InboxItem | null>
  async deleteInboxItem(userId: string, itemId: string): Promise<boolean>
  async getInboxStats(userId: string): Promise<{...}>
  async markAsProcessed(userId: string, itemId: string, createdTaskId?: string): Promise<InboxItem | null>
  async bulkUpdateStatus(userId: string, itemIds: string[], status: string): Promise<InboxItem[]>
  async bulkDeleteInboxItems(userId: string, itemIds: string[]): Promise<void>
}

export function createInboxRepository(db: DbClient): InboxRepository
```

**✅ Pattern Compliance:**
- All API routes use standardized handlers from `@/lib/api`
- Business schemas in `src/server/db/business-schemas/productivity.ts`
- Services throw `AppError` with status codes
- Repositories use constructor injection with `DbClient`
- Type-safe throughout with Drizzle ORM

### 3. **Database Schema (Complete OmniMomentum Tables)**

```sql
-- ✅ All OmniMomentum tables implemented in Supabase
CREATE TABLE zones (id, name, color, icon_name);
CREATE TABLE projects (id, user_id, zone_id, name, status, due_date, details);
CREATE TABLE tasks (id, user_id, project_id, parent_task_id, name, status, priority);
CREATE TABLE goals (id, user_id, contact_id, goal_type, name, status, target_date);
CREATE TABLE daily_pulse_logs (id, user_id, log_date, details);
CREATE TABLE inbox_items (id, user_id, raw_text, status, created_task_id);
CREATE TABLE task_contact_tags (task_id, contact_id); -- Many-to-many join table

-- ✅ Row Level Security (RLS) enabled on all tables
-- ✅ Proper foreign key constraints and indexes
-- ✅ Enum types for status fields with validation
```

### 4. **State Management & Error Handling**

```typescript
// ✅ Complete React Query integration with error boundaries
const createTaskMutation = useMutation({
  mutationFn: async (data: CreateTaskDTO): Promise<TaskDTO> => {
    return await apiClient.post<TaskDTO>("/api/omni-momentum/tasks", data);
  },
  onSuccess: (newTask) => {
    queryClient.setQueryData(["momentum-tasks"], (old) => [newTask, ...old]);
    toast.success("Task created successfully");
  },
  onError: (error) => {
    toast.error("Failed to create task");
    console.error("Task creation error:", error);
  }
});

// ✅ Factory patterns for test data
import { TaskFactory, ProjectFactory } from "@omnicrm/testing";
const mockTask = TaskFactory.build({ status: "todo", priority: "high" });
```

---

## Wellness Zones (6 Core Areas)

Based on wellness practitioner business patterns:

1. **Personal Wellness** - Self-care, personal health goals
2. **Self Care** - Mindfulness, energy management, boundaries
3. **Admin & Finances** - Business operations, invoicing, taxes
4. **Business Development** - Growth, partnerships, strategy
5. **Social Media & Marketing** - Content creation, campaigns, engagement
6. **Client Care** - Client sessions, follow-ups, program delivery

### AI Categorization (Backend Ready)

```typescript
// ✅ Backend infrastructure ready for AI implementation
const { createInboxItem, processInboxItem } = useMomentum();

// Capture phase - fully implemented
await createInboxItem({ rawText: "Schedule yoga class for Saturday" });

// Process phase - backend ready, AI integration next phase
const aiSuggestion = await processInboxItem({
  id: itemId,
  userContext: {
    currentEnergy: dailyPulse.energyLevel,
    availableTime: schedule.freeMinutes,
  }
});

// ✅ Repository methods implemented for AI workflow:
// - createInboxItem() ✅
// - processInboxItem() ✅
// - getInboxItems() ✅
// - updateInboxItem() ✅
```

---

## Development Guidelines

### Adding New Components

1. **Follow Server/Client Separation**

```typescript
// Server components: page.tsx, static layouts
export default async function Page() {
  await getServerUserId(); // Auth check
  return <MomentumPageLayout />;
}

// Client components: interactive elements
"use client";
export function InteractiveComponent(): JSX.Element {
  // React hooks and state management
}
```

1. **Use DTO Contracts**

```typescript
// ✅ Always import from @omnicrm/contracts
import type { CreateInboxItemDTO } from "@omnicrm/contracts";

// ✅ Runtime validation happens automatically
const validatedData = CreateInboxItemDTO.parse(formData);
```

1. **Follow ESLint Rules**

```typescript
// ✅ Explicit return types required
function handleAction(): Promise<void> {
  // ✅ No floating promises
  void asyncOperation();
}

// ✅ No any types allowed
function processData(data: unknown): ProcessedData {
  // Use type guards instead of assertions
  if (isValidData(data)) {
    return data.processed;
  }
  throw new Error("Invalid data");
}
```

### Testing Patterns (Enterprise Grade)

```typescript
// ✅ Repository Layer Testing
import { MomentumRepository } from "@repo";
import { TaskFactory, ProjectFactory } from "@omnicrm/testing";

describe("MomentumRepository", () => {
  it("filters tasks with proper type guards", async () => {
    const repo = new MomentumRepository();
    const filters: TaskFilters = {
      status: ["todo", "in_progress"],
      priority: ["high", "urgent"]
    };

    const tasks = await repo.getTasks(userId, filters);
    expect(tasks).toHaveLength(expectedCount);
  });
});

// ✅ Service Layer Testing
import { MomentumService } from "@/server/services/momentum.service";

const mockRepo = mockDeep<MomentumRepository>();
const service = new MomentumService();
// Mock the private repository instance
(service as any).momentumRepository = mockRepo;

// ✅ API Route Testing
import { GET, POST } from "@/app/api/omni-momentum/tasks/route";

const request = new NextRequest("http://localhost/api/omni-momentum/tasks");
const response = await GET(request);
expect(response.status).toBe(200);

// ✅ Hook Testing with React Query
import { renderHook, waitFor } from "@testing-library/react";
import { useMomentum } from "@/hooks/use-momentum";

const { result } = renderHook(() => useMomentum(), {
  wrapper: QueryClientProvider
});

await waitFor(() => {
  expect(result.current.projects).toHaveLength(expectedCount);
});
```

---

## Implementation Status & Next Phase

### ✅ COMPLETED - Backend Infrastructure (Phase 1)

- **Repository Layer**: Complete CRUD operations with type guards
- **Service Layer**: Business logic with comprehensive filtering
- **API Routes**: Universal NextResponse pattern implementation
- **Database Schema**: All OmniMomentum tables with RLS
- **React Hooks**: Full React Query integration with optimistic updates
- **TypeScript Compliance**: Zero-tolerance achieved (no `any`, no type assertions)
- **Testing Infrastructure**: Enterprise-grade testing patterns

### 🎯 READY FOR - AI Integration (Phase 2)

**Backend Foundation Complete** - AI features can now be implemented:

- **AI Zone Routing**: Backend ready for automatic categorization

  ```typescript
  // Infrastructure exists - just needs AI model integration
  await processInboxItem(itemId); // ✅ Implemented
  await createTask(aiGeneratedTask); // ✅ Implemented
  ```

- **Intelligent Prioritization**: All building blocks available

  ```typescript
  // Data sources ready for AI analysis
  const dailyPulse = await getDailyPulseLog(userId, today); // ✅
  const userStats = await getStats(userId); // ✅
  const contextualTasks = await getTasks(userId, filters); // ✅
  ```

### 🔮 FUTURE - Advanced Features (Phase 3)

- **Voice Integration**: Voice-to-text capture for mobile use
- **Calendar Integration**: Sync with omni-rhythm for time-aware suggestions
- **Wellness Analytics**: Flow state tracking and insights
- **Client Integration**: Connect tasks to specific client needs
- **Template Pathways**: Pre-built workflows for common wellness business tasks
- **Team Collaboration**: Multi-practitioner wellness business support

### Development Readiness Assessment

| Component | Status | Ready for AI? |
|-----------|--------|---------------|
| Inbox System | ✅ Complete | ✅ Yes |
| Task Management | ✅ Complete | ✅ Yes |
| Project Management | ✅ Complete | ✅ Yes |
| Goals Tracking | ✅ Complete | ✅ Yes |
| Daily Pulse | ✅ Complete | ✅ Yes |
| Contact Integration | ✅ Complete | ✅ Yes |
| Stats & Analytics | ✅ Complete | ✅ Yes |

---

## Troubleshooting

### Common Issues

#### 1. **TypeScript Compilation Issues**

```bash
# ✅ Check repository pattern compliance
grep -r "from.*@/server/db\"" src/ --exclude="*.test.*"
# Should return empty - all database access via getDb()

# ✅ Verify all momentum infrastructure
pnpm typecheck
# Should pass with zero errors

# ✅ Check explicit return types
grep -r "function.*(" src/server/services/momentum.service.ts
# All functions should have explicit Promise<ReturnType>
```

#### 2. **ESLint Zero-Tolerance Validation**

```bash
# ✅ Verify no technical debt violations
pnpm lint
# Should pass with zero warnings

# ✅ Check momentum-specific compliance
pnpm lint src/server/services/momentum.service.ts --max-warnings=0
pnpm lint packages/repo/src/momentum.repo.ts --max-warnings=0
pnpm lint src/hooks/use-momentum.ts --max-warnings=0

# ✅ Validate no `any` types in codebase
grep -r ": any" src/server/services/momentum.service.ts
# Should return empty - zero tolerance policy
```

#### 3. **Repository/Service Integration Issues**

```bash
# ✅ Verify proper import patterns
grep -r "MomentumRepository" src/server/services/
# Should show class instantiation, not direct imports

# ✅ Test database connection pattern
grep -r "getDb()" packages/repo/src/momentum.repo.ts
# Should show async getDb() pattern throughout

# ✅ Validate DTO contract usage
grep -r "CreateTaskDTO\|UpdateTaskDTO" src/
# Should show proper DTO imports from @omnicrm/contracts
```

#### 4. **React Query Integration Problems**

```bash
# ✅ Check hook implementation
grep -r "useMutation\|useQuery" src/hooks/use-momentum.ts
# Should show proper TanStack React Query patterns

# ✅ Verify optimistic updates
grep -r "queryClient.setQueryData" src/hooks/use-momentum.ts
# Should show optimistic update patterns with rollback

# ✅ Test API client usage
grep -r "apiClient\." src/hooks/use-momentum.ts
# Should show apiClient pattern, not fetchPost/fetchGet
```

### Performance Monitoring & Validation

```bash
# ✅ Full compilation validation (should pass)
pnpm typecheck
# All momentum infrastructure compiles without errors

# ✅ Zero-tolerance linting (should pass)
pnpm lint --max-warnings=0
# All momentum code follows strict standards

# ✅ Momentum-specific test suite
pnpm test src/hooks/use-momentum.test.ts
pnpm test packages/repo/src/momentum.repo.test.ts
pnpm test src/server/services/momentum.service.test.ts

# ✅ API endpoint validation
curl -X GET http://localhost:3000/api/omni-momentum/projects
curl -X GET http://localhost:3000/api/omni-momentum/tasks
curl -X GET http://localhost:3000/api/omni-momentum/stats

# ✅ Database integration test
pnpm dev
# Navigate to /omni-momentum and verify all features work

# ✅ Bundle impact analysis
pnpm build && npx @next/bundle-analyzer
# Verify momentum infrastructure doesn't add excessive bundle size
```

### Validation Checklist

**Before deploying momentum features:**

- [ ] `pnpm typecheck` passes with zero errors
- [ ] `pnpm lint` passes with zero warnings
- [ ] All momentum API routes return valid responses
- [ ] React hooks provide proper TypeScript intellisense
- [ ] Database queries use proper type guards
- [ ] No `any` types exist in momentum codebase
- [ ] Repository pattern used consistently
- [ ] Service layer separates business logic
- [ ] Frontend components use proper DTO contracts

---

## Documentation References

- **Product Requirements**: `docs/roadmap/Product Requirements Document_ Wellness Task Management App.md`
- **Research Findings**: `docs/roadmap/implementation/RhythmModuleResearch.md`
- **Technical Standards**: `docs/TECHNICAL_DEBT_ELIMINATION.md`
- **Implementation Guide**: `docs/omni-momentum-implementation-guide.md`
- **Architecture Patterns**: `eslint.config.mjs` (enforcement rules)

---

**Last Updated**: September 20, 2025
**Maintainer**: OmniCRM Development Team
**Backend Status**: ✅ FULLY IMPLEMENTED - Zero Technical Debt
**Frontend Status**: ✅ React Query Integration Complete
**Ready For**: AI Integration (Phase 2) - All infrastructure in place




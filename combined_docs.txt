===== packages/repo/src/auth-user.repo.ts =====
// src/server/repositories/auth-user.repo.ts
import { getDb } from "@/server/db/client";
import { sql } from "drizzle-orm";
import { ok, DbResult, dbError } from "@/lib/utils/result";

export interface UserContext {
  email: string;
  avatarUrl?: string | undefined;
}

export interface UserProfile {
  id: string;
  email: string;
  avatarUrl?: string | undefined;
  displayName?: string | undefined;
  createdAt: string;
}

/**
 * Repository for querying the auth.users table (Supabase auth schema)
 * Provides controlled access to user authentication data
 */
export class AuthUserRepository {
  /**
   * Get user context (email and avatar) by user ID from auth.users table
   * Replaces raw SQL from contact-intelligence.service.ts
   */
  static async getUserContext(userId: string): Promise<DbResult<UserContext>> {
    try {
      const db = await getDb();

      // Use Drizzle's sql template for cross-schema query
      const result = await db.execute(sql`
        SELECT email, raw_user_meta_data
        FROM auth.users
        WHERE id = ${userId}
        LIMIT 1
      `);

      // Type-safe access to database result
      const resultsWithRows = result as unknown as {
        rows?: Array<{
          email: string;
          raw_user_meta_data: Record<string, unknown> | null;
        }>;
      };

      if (resultsWithRows.rows?.length && resultsWithRows.rows[0]) {
        const userData = resultsWithRows.rows[0];
        const avatarUrl = userData.raw_user_meta_data?.["avatar_url"] as string | undefined;

        return ok({
          email: userData.email,
          avatarUrl: avatarUrl ?? undefined,
        });
      }

      return dbError("USER_NOT_FOUND", "User not found", { userId });
    } catch (getUserContextError) {
      console.error("Failed to fetch user context:", getUserContextError);
      return dbError("DATABASE_ERROR", "Failed to fetch user context", getUserContextError);
    }
  }

  /**
   * Check if user exists by ID
   */
  static async userExists(userId: string): Promise<DbResult<boolean>> {
    try {
      const db = await getDb();

      const result = await db.execute(sql`
        SELECT 1
        FROM auth.users
        WHERE id = ${userId}
        LIMIT 1
      `);

      const resultsWithRows = result as unknown as {
        rows?: Array<{ [key: string]: unknown }>;
      };

      return ok(Boolean(resultsWithRows.rows?.length));
    } catch (checkUserError) {
      console.warn("Failed to check user existence:", checkUserError);
      return dbError("DATABASE_ERROR", "Failed to check user existence", checkUserError);
    }
  }

  /**
   * Get basic user info by ID
   * Useful for user validation and basic profile data
   */
  static async getUserInfo(userId: string): Promise<
    DbResult<{
      id: string;
      email: string;
      created_at: string;
    } | null>
  > {
    try {
      const db = await getDb();

      const result = await db.execute(sql`
        SELECT id, email, created_at
        FROM auth.users
        WHERE id = ${userId}
        LIMIT 1
      `);

      const resultsWithRows = result as unknown as {
        rows?: Array<{
          id: string;
          email: string;
          created_at: string;
        }>;
      };

      if (resultsWithRows.rows?.length && resultsWithRows.rows[0]) {
        return ok(resultsWithRows.rows[0]);
      }

      return ok(null);
    } catch (getUserError) {
      console.warn("Failed to get user info:", getUserError);
      return dbError("DATABASE_ERROR", "Failed to get user info", getUserError);
    }
  }

  /**
   * Get full user profile including avatar for intake forms
   * This method provides comprehensive user data for display purposes
   */
  static async getUserProfile(userId: string): Promise<DbResult<UserProfile | null>> {
    try {
      const db = await getDb();

      const result = await db.execute(sql`
        SELECT id, email, created_at, raw_user_meta_data
        FROM auth.users
        WHERE id = ${userId}
        LIMIT 1
      `);

      const resultsWithRows = result as unknown as {
        rows?: Array<{
          id: string;
          email: string;
          created_at: string;
          raw_user_meta_data: Record<string, unknown> | null;
        }>;
      };

      if (resultsWithRows.rows?.length && resultsWithRows.rows[0]) {
        const userData = resultsWithRows.rows[0];
        const avatarUrl = userData.raw_user_meta_data?.["avatar_url"] as string | undefined;
        const displayName = userData.raw_user_meta_data?.["full_name"] as string | undefined;

        return ok({
          id: userData.id,
          email: userData.email,
          avatarUrl: avatarUrl ?? undefined,
          displayName: displayName ?? undefined,
          createdAt: userData.created_at,
        });
      }

      return ok(null);
    } catch (getUserProfileError) {
      console.error("Failed to get user profile:", getUserProfileError);
      return dbError("DATABASE_ERROR", "Failed to get user profile", getUserProfileError);
    }
  }
}

// Named exports for easier importing
export const getUserContext = AuthUserRepository.getUserContext;
export const userExists = AuthUserRepository.userExists;
export const getUserInfo = AuthUserRepository.getUserInfo;
export const getUserProfile = AuthUserRepository.getUserProfile;



===== packages/repo/src/calendar-events.repo.ts =====
import { eq, and, desc, gte, lte } from "drizzle-orm";
import { calendarEvents, CalendarEvent, CreateCalendarEvent } from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import { ok, err, DbResult } from "@/lib/utils/result";

// Local type aliases for repository layer
type CalendarEventDTO = CalendarEvent;
type CreateCalendarEventDTO = CreateCalendarEvent;
type UpdateCalendarEventDTO = Partial<CreateCalendarEvent>;

interface CalendarEventFilters {
  fromDate?: Date;
  toDate?: Date;
  eventType?: string;
  businessCategory?: string;
  status?: string;
}

export class CalendarEventsRepository {
  /**
   * List calendar events for a user with optional filtering
   */
  static async listCalendarEvents(
    userId: string,
    filters?: CalendarEventFilters,
  ): Promise<DbResult<CalendarEventDTO[]>> {
    try {
      const db = await getDb();

      // Build conditions array
      const conditions = [eq(calendarEvents.userId, userId)];

      if (filters?.fromDate) {
        conditions.push(gte(calendarEvents.startTime, filters.fromDate));
      }

      if (filters?.toDate) {
        conditions.push(lte(calendarEvents.startTime, filters.toDate));
      }

      if (filters?.eventType) {
        conditions.push(eq(calendarEvents.eventType, filters.eventType));
      }

      if (filters?.businessCategory) {
        conditions.push(eq(calendarEvents.businessCategory, filters.businessCategory));
      }

      if (filters?.status) {
        conditions.push(eq(calendarEvents.status, filters.status));
      }

      const query = db
        .select({
          id: calendarEvents.id,
          userId: calendarEvents.userId,
          googleEventId: calendarEvents.googleEventId,
          title: calendarEvents.title,
          description: calendarEvents.description,
          startTime: calendarEvents.startTime,
          endTime: calendarEvents.endTime,
          attendees: calendarEvents.attendees,
          location: calendarEvents.location,
          status: calendarEvents.status,
          timeZone: calendarEvents.timeZone,
          isAllDay: calendarEvents.isAllDay,
          visibility: calendarEvents.visibility,
          eventType: calendarEvents.eventType,
          businessCategory: calendarEvents.businessCategory,
          keywords: calendarEvents.keywords,
          googleUpdated: calendarEvents.googleUpdated,
          lastSynced: calendarEvents.lastSynced,
          createdAt: calendarEvents.createdAt,
          updatedAt: calendarEvents.updatedAt,
        })
        .from(calendarEvents)
        .where(and(...conditions))
        .orderBy(desc(calendarEvents.startTime));

      const rows = await query;

      return ok(rows.map((row) => row));
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to list calendar events",
        details: error,
      });
    }
  }

  /**
   * Get a single calendar event by ID
   */
  static async getCalendarEventById(
    userId: string,
    eventId: string,
  ): Promise<CalendarEventDTO | null> {
    const db = await getDb();

    const rows = await db
      .select({
        id: calendarEvents.id,
        userId: calendarEvents.userId,
        googleEventId: calendarEvents.googleEventId,
        title: calendarEvents.title,
        description: calendarEvents.description,
        startTime: calendarEvents.startTime,
        endTime: calendarEvents.endTime,
        attendees: calendarEvents.attendees,
        location: calendarEvents.location,
        status: calendarEvents.status,
        timeZone: calendarEvents.timeZone,
        isAllDay: calendarEvents.isAllDay,
        visibility: calendarEvents.visibility,
        eventType: calendarEvents.eventType,
        businessCategory: calendarEvents.businessCategory,
        keywords: calendarEvents.keywords,
        googleUpdated: calendarEvents.googleUpdated,
        lastSynced: calendarEvents.lastSynced,
        createdAt: calendarEvents.createdAt,
        updatedAt: calendarEvents.updatedAt,
      })
      .from(calendarEvents)
      .where(and(eq(calendarEvents.userId, userId), eq(calendarEvents.id, eventId)))
      .limit(1);

    if (rows.length === 0) {
      return null;
    }

    return rows[0] ?? null;
  }

  /**
   * Get calendar event by Google Event ID
   */
  static async getCalendarEventByGoogleId(
    userId: string,
    googleEventId: string,
  ): Promise<CalendarEventDTO | null> {
    const db = await getDb();

    const rows = await db
      .select({
        id: calendarEvents.id,
        userId: calendarEvents.userId,
        googleEventId: calendarEvents.googleEventId,
        title: calendarEvents.title,
        description: calendarEvents.description,
        startTime: calendarEvents.startTime,
        endTime: calendarEvents.endTime,
        attendees: calendarEvents.attendees,
        location: calendarEvents.location,
        status: calendarEvents.status,
        timeZone: calendarEvents.timeZone,
        isAllDay: calendarEvents.isAllDay,
        visibility: calendarEvents.visibility,
        eventType: calendarEvents.eventType,
        businessCategory: calendarEvents.businessCategory,
        keywords: calendarEvents.keywords,
        googleUpdated: calendarEvents.googleUpdated,
        lastSynced: calendarEvents.lastSynced,
        createdAt: calendarEvents.createdAt,
        updatedAt: calendarEvents.updatedAt,
      })
      .from(calendarEvents)
      .where(
        and(eq(calendarEvents.userId, userId), eq(calendarEvents.googleEventId, googleEventId)),
      )
      .limit(1);

    if (rows.length === 0) {
      return null;
    }

    return rows[0] ?? null;
  }

  /**
   * Create a new calendar event
   */
  static async createCalendarEvent(
    userId: string,
    data: CreateCalendarEventDTO,
  ): Promise<DbResult<CalendarEventDTO>> {
    try {
      const db = await getDb();

      const [newEvent] = await db
        .insert(calendarEvents)
        .values({
          userId: userId,
          title: data.title,
          description: data.description ?? null,
          startTime: data.startTime,
          endTime: data.endTime,
          isAllDay: data.isAllDay ?? null,
          timeZone: data.timeZone ?? null,
          location: data.location ?? null,
          status: data.status ?? null,
          visibility: data.visibility ?? null,
          eventType: data.eventType ?? null,
          businessCategory: data.businessCategory ?? null,
          googleEventId: data.googleEventId,
          googleUpdated: data.googleUpdated ?? null,
          lastSynced: data.lastSynced ?? null,
          attendees: data.attendees ?? null,
          keywords: data.keywords ?? null,
        })
        .returning();

      if (!newEvent) {
        return err({
          code: "DB_INSERT_FAILED",
          message: "Failed to create calendar event - no data returned",
        });
      }

      return ok(newEvent);
    } catch (error) {
      return err({
        code: "DB_INSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to create calendar event",
        details: error,
      });
    }
  }

  /**
   * Update an existing calendar event
   */
  static async updateCalendarEvent(
    userId: string,
    eventId: string,
    data: UpdateCalendarEventDTO,
  ): Promise<DbResult<CalendarEventDTO | null>> {
    try {
      const db = await getDb();

      // Convert undefined to null for database nullable fields with exactOptionalPropertyTypes
      const updateValues = {
        updatedAt: new Date(),
        ...(data.title !== undefined && { title: data.title }),
        ...(data.description !== undefined && { description: data.description ?? null }),
        ...(data.startTime !== undefined && { startTime: data.startTime }),
        ...(data.endTime !== undefined && { endTime: data.endTime }),
        ...(data.attendees !== undefined && { attendees: data.attendees ?? null }),
        ...(data.location !== undefined && { location: data.location ?? null }),
        ...(data.status !== undefined && { status: data.status ?? null }),
        ...(data.timeZone !== undefined && { timeZone: data.timeZone ?? null }),
        ...(data.isAllDay !== undefined && { isAllDay: data.isAllDay ?? null }),
        ...(data.visibility !== undefined && { visibility: data.visibility ?? null }),
        ...(data.eventType !== undefined && { eventType: data.eventType ?? null }),
        ...(data.businessCategory !== undefined && {
          businessCategory: data.businessCategory ?? null,
        }),
        ...(data.keywords !== undefined && { keywords: data.keywords ?? null }),
        ...(data.googleUpdated !== undefined && { googleUpdated: data.googleUpdated ?? null }),
        ...(data.lastSynced !== undefined && { lastSynced: data.lastSynced ?? null }),
      };

      const [updatedEvent] = await db
        .update(calendarEvents)
        .set(updateValues)
        .where(and(eq(calendarEvents.userId, userId), eq(calendarEvents.id, eventId)))
        .returning();

      return ok(updatedEvent || null);
    } catch (error) {
      return err({
        code: "DB_UPDATE_FAILED",
        message: error instanceof Error ? error.message : "Failed to update calendar event",
        details: error,
      });
    }
  }

  /**
   * Delete a calendar event
   */
  static async deleteCalendarEvent(userId: string, eventId: string): Promise<boolean> {
    const db = await getDb();

    const result = await db
      .delete(calendarEvents)
      .where(and(eq(calendarEvents.userId, userId), eq(calendarEvents.id, eventId)));

    return result.length > 0;
  }

  /**
   * Bulk upsert calendar events (for sync operations)
   */
  static async upsertCalendarEvents(
    userId: string,
    data: CreateCalendarEventDTO[],
  ): Promise<DbResult<CalendarEventDTO[]>> {
    try {
      const results: CalendarEventDTO[] = [];

      for (const eventData of data) {
        // Check if event exists by googleEventId
        const existing = await this.getCalendarEventByGoogleId(userId, eventData.googleEventId);

        if (existing) {
          // Update existing event
          const updateResult = await this.updateCalendarEvent(userId, existing.id, eventData);
          if (updateResult.success && updateResult.data) {
            results.push(updateResult.data);
          }
        } else {
          // Create new event
          const createResult = await this.createCalendarEvent(userId, eventData);
          if (createResult.success) {
            results.push(createResult.data);
          }
        }
      }

      return ok(results);
    } catch (error) {
      return err({
        code: "DB_UPSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to upsert calendar events",
        details: error,
      });
    }
  }

  /**
   * Get events within a date range (useful for calendar views)
   */
  static async getEventsInDateRange(
    userId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<CalendarEventDTO[]> {
    const db = await getDb();

    const rows = await db
      .select({
        id: calendarEvents.id,
        userId: calendarEvents.userId,
        googleEventId: calendarEvents.googleEventId,
        title: calendarEvents.title,
        description: calendarEvents.description,
        startTime: calendarEvents.startTime,
        endTime: calendarEvents.endTime,
        attendees: calendarEvents.attendees,
        location: calendarEvents.location,
        status: calendarEvents.status,
        timeZone: calendarEvents.timeZone,
        isAllDay: calendarEvents.isAllDay,
        visibility: calendarEvents.visibility,
        eventType: calendarEvents.eventType,
        businessCategory: calendarEvents.businessCategory,
        keywords: calendarEvents.keywords,
        googleUpdated: calendarEvents.googleUpdated,
        lastSynced: calendarEvents.lastSynced,
        createdAt: calendarEvents.createdAt,
        updatedAt: calendarEvents.updatedAt,
      })
      .from(calendarEvents)
      .where(
        and(
          eq(calendarEvents.userId, userId),
          gte(calendarEvents.startTime, startDate),
          lte(calendarEvents.startTime, endDate),
        ),
      )
      .orderBy(calendarEvents.startTime);

    return rows.map((row) => row);
  }
}



===== packages/repo/src/contacts.repo.ts =====
import { eq, and, ilike, desc, asc, inArray, count } from "drizzle-orm";
import { contacts, notes, type Contact, type Note } from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import { ok, err, DbResult, dbError } from "@/lib/utils/result";
import { CreateContactSchema, UpdateContactBodySchema } from "@/server/db/business-schemas";
import { safeParse } from "@/lib/utils/zod-helpers";

// Only export types that actually transform/extend base types
export type ContactWithNotes = Contact & { notes: Note[] };

export class ContactsRepository {
  /**
   * List contacts for a user with pagination, search, and sorting
   */
  static async listContacts(
    userId: string,
    params: {
      search?: string;
      sort?: "displayName" | "createdAt" | "updatedAt";
      order?: "asc" | "desc";
      page?: number;
      pageSize?: number;
    } = {},
  ): Promise<DbResult<{ items: Contact[]; total: number }>> {
    try {
      const db = await getDb();
      const page = params.page ?? 1;
      const pageSize = params.pageSize ?? 50;
      const offset = (page - 1) * pageSize;
      const sortKey = params.sort ?? "updatedAt";
      const sortDir = params.order === "desc" ? desc : asc;

      // Build conditions array
      const conditions = [eq(contacts.userId, userId)];

      if (params.search) {
        conditions.push(ilike(contacts.displayName, `%${params.search}%`));
      }

      // Count total using Drizzle's typed count helper
      const countResult = await db
        .select({ count: count() })
        .from(contacts)
        .where(and(...conditions));

      const total = countResult[0]?.count ?? 0;

      // Main query with dynamic sort and limit/offset
      const sortColumnMap = {
        displayName: contacts.displayName,
        createdAt: contacts.createdAt,
        updatedAt: contacts.updatedAt,
      } as const;

      const orderByClause = sortDir(sortColumnMap[sortKey] ?? contacts.updatedAt);

      const query = db
        .select()
        .from(contacts)
        .where(and(...conditions))
        .orderBy(orderByClause)
        .limit(pageSize)
        .offset(offset);

      const rows = await query;

      // Transform DB rows to DTOs
      const items = rows;

      return ok({ items, total });
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to list contacts",
        details: error,
      });
    }
  }

  /**
   * Get a single contact by ID
   */
  static async getContactById(
    userId: string,
    contactId: string,
  ): Promise<DbResult<Contact | null>> {
    try {
      const db = await getDb();

      const rows = await db
        .select()
        .from(contacts)
        .where(and(eq(contacts.userId, userId), eq(contacts.id, contactId)))
        .limit(1);

      if (rows.length === 0) {
        return ok(null);
      }

      return ok(rows[0] ?? null);
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to get contact",
        details: error,
      });
    }
  }

  /**
   * Get contact with associated notes
   */
  static async getContactWithNotes(
    userId: string,
    contactId: string,
  ): Promise<DbResult<ContactWithNotes | null>> {
    try {
      const db = await getDb();

      // Get contact
      const contactRows = await db
        .select()
        .from(contacts)
        .where(and(eq(contacts.userId, userId), eq(contacts.id, contactId)))
        .limit(1);

      if (contactRows.length === 0) {
        return ok(null);
      }

      // Get associated notes
      const noteRows = await db
        .select()
        .from(notes)
        .where(and(eq(notes.userId, userId), eq(notes.contactId, contactId)))
        .orderBy(desc(notes.createdAt));

      const contactWithNotes = {
        ...contactRows[0],
        notes: noteRows,
      } as ContactWithNotes;

      return ok(contactWithNotes);
    } catch (error) {
      return dbError(
        "DB_QUERY_FAILED",
        error instanceof Error ? error.message : "Failed to get contact with notes",
        error,
      );
    }
  }

  /**
   * Create a new contact
   */
  static async createContact(input: unknown): Promise<DbResult<Contact>> {
    try {
      const db = await getDb();

      // Validate and narrow the input type using Zod
      // CreateContactSchema already includes userId, so just use it directly
      const dataValidation = safeParse(CreateContactSchema, input);

      if (!dataValidation.success) {
        return err({
          code: "VALIDATION_ERROR",
          message: `Invalid contact data: ${dataValidation.error.issues.map((i: { message: string }) => i.message).join(", ")}`,
        });
      }

      const data = dataValidation.data as {
        userId: string;
        displayName: string;
        primaryEmail?: string | null;
        primaryPhone?: string | null;
        photoUrl?: string | null;
        source?: string | null;
        lifecycleStage?: string | null;
        tags?: string[] | null;
        confidenceScore?: string | null;
      };

      // Convert undefined to null for database nullable fields with exactOptionalPropertyTypes
      const insertValues = {
        userId: data.userId,
        displayName: data.displayName,
        primaryEmail: data.primaryEmail ?? null,
        primaryPhone: data.primaryPhone ?? null,
        photoUrl: data.photoUrl ?? null,
        source: data.source ?? null,
        lifecycleStage: data.lifecycleStage ?? null,
        tags: data.tags ?? null,
        confidenceScore: data.confidenceScore ?? null,
      };

      const [newContact] = await db.insert(contacts).values(insertValues).returning();

      if (!newContact) {
        return err({
          code: "DB_INSERT_FAILED",
          message: "Failed to create contact - no data returned",
        });
      }

      return ok(newContact);
    } catch (error) {
      return err({
        code: "DB_INSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to create contact",
        details: error,
      });
    }
  }

  /**
   * Update an existing contact
   */
  static async updateContact(
    userId: string,
    contactId: string,
    input: unknown,
  ): Promise<DbResult<Contact | null>> {
    try {
      const db = await getDb();

      // Validate and narrow the input type using Zod
      // Use UpdateContactBodySchema which excludes userId (comes from auth) and id (comes from URL)
      const dataValidation = safeParse(UpdateContactBodySchema, input);

      if (!dataValidation.success) {
        return err({
          code: "VALIDATION_ERROR",
          message: `Invalid update data: ${dataValidation.error.issues.map((i: { message: string }) => i.message).join(", ")}`,
        });
      }

      const data = dataValidation.data;

      // Convert undefined to null for database nullable fields with exactOptionalPropertyTypes
      const updateValues = {
        updatedAt: new Date(),
        ...(data.displayName !== undefined && { displayName: data.displayName }),
        ...(data.primaryEmail !== undefined && { primaryEmail: data.primaryEmail ?? null }),
        ...(data.primaryPhone !== undefined && { primaryPhone: data.primaryPhone ?? null }),
        ...(data.photoUrl !== undefined && { photoUrl: data.photoUrl ?? null }),
        ...(data.source !== undefined && { source: data.source ?? null }),
        ...(data.lifecycleStage !== undefined && { lifecycleStage: data.lifecycleStage ?? null }),
        ...(data.tags !== undefined && { tags: data.tags ?? null }),
        ...(data.confidenceScore !== undefined && {
          confidenceScore: data.confidenceScore ?? null,
        }),
      };

      const [updatedContact] = await db
        .update(contacts)
        .set(updateValues)
        .where(and(eq(contacts.userId, userId), eq(contacts.id, contactId)))
        .returning();

      return ok(updatedContact || null);
    } catch (error) {
      return err({
        code: "DB_UPDATE_FAILED",
        message: error instanceof Error ? error.message : "Failed to update contact",
        details: error,
      });
    }
  }

  /**
   * Delete a contact
   */
  static async deleteContact(userId: string, contactId: string): Promise<DbResult<boolean>> {
    try {
      const db = await getDb();

      const result = await db
        .delete(contacts)
        .where(and(eq(contacts.userId, userId), eq(contacts.id, contactId)))
        .returning({ id: contacts.id });

      return ok(result.length > 0);
    } catch (error) {
      return dbError(
        "DB_DELETE_FAILED",
        error instanceof Error ? error.message : "Failed to delete contact",
        error,
      );
    }
  }

  /**
   * Check if contact exists by email
   */
  static async findContactByEmail(
    userId: string,
    email: string,
  ): Promise<DbResult<Contact | null>> {
    try {
      const db = await getDb();

      const rows = await db
        .select()
        .from(contacts)
        .where(and(eq(contacts.userId, userId), eq(contacts.primaryEmail, email)))
        .limit(1);

      return ok(rows.length === 0 ? null : (rows[0] ?? null));
    } catch (error) {
      return dbError(
        "DB_QUERY_FAILED",
        error instanceof Error ? error.message : "Failed to find contact by email",
        error,
      );
    }
  }

  /**
   * Get multiple contacts by IDs
   */
  static async getContactsByIds(
    userId: string,
    contactIds: string[],
  ): Promise<DbResult<Contact[]>> {
    try {
      if (contactIds.length === 0) {
        return ok([]);
      }

      const db = await getDb();

      const rows = await db
        .select()
        .from(contacts)
        .where(and(eq(contacts.userId, userId), inArray(contacts.id, contactIds)));

      return ok(rows);
    } catch (error) {
      return dbError(
        "DB_QUERY_FAILED",
        error instanceof Error ? error.message : "Failed to get contacts by IDs",
        error,
      );
    }
  }

  /**
   * Bulk delete contacts by IDs
   */
  static async deleteContactsByIds(
    userId: string,
    contactIds: string[],
  ): Promise<DbResult<number>> {
    try {
      if (contactIds.length === 0) {
        return ok(0);
      }

      const db = await getDb();

      // Count contacts to delete first
      const countRows = await db
        .select({ n: count() })
        .from(contacts)
        .where(and(eq(contacts.userId, userId), inArray(contacts.id, contactIds)))
        .limit(1);
      const n = countRows[0]?.n ?? 0;

      if (n === 0) {
        return ok(0);
      }

      // Delete the contacts
      const result = await db
        .delete(contacts)
        .where(and(eq(contacts.userId, userId), inArray(contacts.id, contactIds)));

      return ok(result.count || n);
    } catch (error) {
      return dbError(
        "DB_DELETE_FAILED",
        error instanceof Error ? error.message : "Failed to bulk delete contacts",
        error,
      );
    }
  }

  /**
   * Count contacts for a user with optional search filter
   */
  static async countContacts(userId: string, search?: string): Promise<DbResult<number>> {
    try {
      const db = await getDb();

      const conditions = [eq(contacts.userId, userId)];
      if (search) {
        conditions.push(ilike(contacts.displayName, `%${search}%`));
      }

      const result = await db
        .select({ count: count() })
        .from(contacts)
        .where(and(...conditions))
        .limit(1);

      return ok(result[0]?.count ?? 0);
    } catch (error) {
      return dbError(
        "DB_QUERY_FAILED",
        error instanceof Error ? error.message : "Failed to count contacts",
        error,
      );
    }
  }
}



===== packages/repo/src/identities.repo.ts =====
import { getDb } from "@/server/db/client";
import { sql } from "drizzle-orm";
import { ok, err, DbResult } from "@/lib/utils/result";

// Database row types for query results
interface ContactIdentityRow {
  id: string;
  user_id: string;
  contact_id: string;
  kind: string;
  value: string;
  provider: string | null;
  created_at: string;
}

interface ContactIdRow {
  contact_id: string;
}

interface DuplicateIdentityRow {
  kind: string;
  value: string;
  provider: string | null;
  contact_ids: string[];
}

interface IdentityStatsRow {
  kind: string;
  count: string;
}

export interface ContactIdentity {
  id: string;
  userId: string;
  contactId: string;
  kind: "email" | "phone" | "handle" | "provider_id";
  value: string;
  provider?: string | null;
  createdAt: string;
}

export interface IdentityQuery {
  email?: string;
  phone?: string;
  handle?: string;
  provider?: string;
  providerId?: string;
}

export class IdentitiesRepository {
  /**
   * Add email identity for contact
   */
  async addEmail(userId: string, contactId: string, email: string): Promise<DbResult<void>> {
    return this.addIdentity(userId, contactId, "email", email.toLowerCase());
  }

  /**
   * Add phone identity for contact
   */
  async addPhone(userId: string, contactId: string, phone: string): Promise<void> {
    const normalizedPhone = this.normalizePhone(phone);
    await this.addIdentity(userId, contactId, "phone", normalizedPhone);
  }

  /**
   * Add handle identity for contact (e.g., social media handle)
   */
  async addHandle(
    userId: string,
    contactId: string,
    provider: string,
    handle: string,
  ): Promise<void> {
    await this.addIdentity(userId, contactId, "handle", handle.toLowerCase(), provider);
  }

  /**
   * Add provider-specific ID for contact
   */
  async addProviderId(
    userId: string,
    contactId: string,
    provider: string,
    providerId: string,
  ): Promise<void> {
    await this.addIdentity(userId, contactId, "provider_id", providerId, provider);
  }

  /**
   * Resolve contact ID from identity query
   */
  async resolve(userId: string, query: IdentityQuery): Promise<DbResult<string | null>> {
    try {
      if (query.email) {
        const contactId = await this.findByEmail(userId, query.email);
        if (contactId) return ok(contactId);
      }

      if (query.phone) {
        const contactId = await this.findByPhone(userId, query.phone);
        if (contactId) return ok(contactId);
      }

      if (query.handle && query.provider) {
        const contactId = await this.findByHandle(userId, query.provider, query.handle);
        if (contactId) return ok(contactId);
      }

      if (query.providerId && query.provider) {
        const contactId = await this.findByProviderId(userId, query.provider, query.providerId);
        if (contactId) return ok(contactId);
      }

      return ok(null);
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to resolve identity",
        details: error,
      });
    }
  }

  /**
   * Get all identities for a contact
   */
  async getContactIdentities(
    userId: string,
    contactId: string,
  ): Promise<DbResult<ContactIdentity[]>> {
    try {
      const db = await getDb();

      const result = await db.execute(sql`
        SELECT id, user_id, contact_id, kind, value, provider, created_at
        FROM contact_identities
        WHERE user_id = ${userId} AND contact_id = ${contactId}
        ORDER BY created_at ASC
      `);

      return ok((result as unknown as ContactIdentityRow[]).map(this.mapToContactIdentity));
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to get contact identities",
        details: error,
      });
    }
  }

  /**
   * Get all contacts for an identity value
   */
  async findContactsByIdentity(
    userId: string,
    kind: ContactIdentity["kind"],
    value: string,
    provider?: string,
  ): Promise<string[]> {
    const db = await getDb();

    const normalizedValue =
      kind === "email" || kind === "handle"
        ? value.toLowerCase()
        : kind === "phone"
          ? this.normalizePhone(value)
          : value;

    const result = await db.execute(sql`
      SELECT DISTINCT contact_id
      FROM contact_identities
      WHERE user_id = ${userId}
        AND kind = ${kind}
        AND value = ${normalizedValue}
        ${provider ? sql`AND provider = ${provider}` : sql`AND provider IS NULL`}
    `);

    return (result as unknown as ContactIdRow[]).map((row) => row.contact_id);
  }

  /**
   * Remove identity
   */
  async removeIdentity(userId: string, identityId: string): Promise<void> {
    const db = await getDb();

    await db.execute(sql`
      DELETE FROM contact_identities
      WHERE id = ${identityId} AND user_id = ${userId}
    `);
  }

  /**
   * Remove all identities for a contact
   */
  async removeContactIdentities(userId: string, contactId: string): Promise<void> {
    const db = await getDb();

    await db.execute(sql`
      DELETE FROM contact_identities
      WHERE user_id = ${userId} AND contact_id = ${contactId}
    `);
  }

  /**
   * Find duplicate identities (same value, different contacts)
   */
  async findDuplicateIdentities(userId: string): Promise<
    Array<{
      kind: string;
      value: string;
      provider?: string;
      contactIds: string[];
    }>
  > {
    const db = await getDb();

    const result = await db.execute(sql`
      SELECT kind, value, provider, array_agg(contact_id) as contact_ids
      FROM contact_identities
      WHERE user_id = ${userId}
      GROUP BY kind, value, provider
      HAVING count(DISTINCT contact_id) > 1
    `);

    return (result as unknown as DuplicateIdentityRow[]).map((row) => {
      const mapped: {
        kind: string;
        value: string;
        provider?: string;
        contactIds: string[];
      } = {
        kind: row.kind,
        value: row.value,
        contactIds: row.contact_ids,
      };

      if (row.provider) {
        mapped.provider = row.provider;
      }

      return mapped;
    });
  }

  /**
   * Merge identities from one contact to another
   */
  async mergeIdentities(userId: string, fromContactId: string, toContactId: string): Promise<void> {
    const db = await getDb();

    // Update identities to new contact (ignoring conflicts)
    await db.execute(sql`
      UPDATE contact_identities
      SET contact_id = ${toContactId}
      WHERE user_id = ${userId} AND contact_id = ${fromContactId}
      ON CONFLICT (user_id, kind, value, coalesce(provider, ''))
      DO NOTHING
    `);

    // Remove any remaining duplicates
    await db.execute(sql`
      DELETE FROM contact_identities
      WHERE user_id = ${userId} AND contact_id = ${fromContactId}
    `);
  }

  /**
   * Get identity statistics for user
   */
  async getIdentityStats(userId: string): Promise<Record<string, number>> {
    const db = await getDb();

    const result = await db.execute(sql`
      SELECT kind, count(*) as count
      FROM contact_identities
      WHERE user_id = ${userId}
      GROUP BY kind
    `);

    const stats: Record<string, number> = {};
    for (const row of result as unknown as IdentityStatsRow[]) {
      stats[row.kind] = parseInt(row.count, 10);
    }

    return stats;
  }

  private async addIdentity(
    userId: string,
    contactId: string,
    kind: ContactIdentity["kind"],
    value: string,
    provider?: string,
  ): Promise<DbResult<void>> {
    try {
      const db = await getDb();

      await db.execute(sql`
        INSERT INTO contact_identities (user_id, contact_id, kind, value, provider, created_at)
        VALUES (${userId}, ${contactId}, ${kind}, ${value}, ${provider ?? null}, ${new Date()})
        ON CONFLICT (user_id, kind, value, coalesce(provider, ''))
        DO UPDATE SET contact_id = EXCLUDED.contact_id
      `);

      return ok(undefined);
    } catch (error) {
      return err({
        code: "DB_INSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to add identity",
        details: error,
      });
    }
  }

  private async findByEmail(userId: string, email: string): Promise<string | null> {
    const db = await getDb();

    const result = await db.execute(sql`
      SELECT contact_id
      FROM contact_identities
      WHERE user_id = ${userId}
        AND kind = 'email'
        AND value = ${email.toLowerCase()}
      LIMIT 1
    `);

    return result.length > 0 ? (result[0] as unknown as ContactIdRow).contact_id : null;
  }

  private async findByPhone(userId: string, phone: string): Promise<string | null> {
    const db = await getDb();
    const normalizedPhone = this.normalizePhone(phone);

    const result = await db.execute(sql`
      SELECT contact_id
      FROM contact_identities
      WHERE user_id = ${userId}
        AND kind = 'phone'
        AND value = ${normalizedPhone}
      LIMIT 1
    `);

    return result.length > 0 ? (result[0] as unknown as ContactIdRow).contact_id : null;
  }

  private async findByHandle(
    userId: string,
    provider: string,
    handle: string,
  ): Promise<string | null> {
    const db = await getDb();

    const result = await db.execute(sql`
      SELECT contact_id
      FROM contact_identities
      WHERE user_id = ${userId}
        AND kind = 'handle'
        AND value = ${handle.toLowerCase()}
        AND provider = ${provider}
      LIMIT 1
    `);

    return result.length > 0 ? (result[0] as unknown as ContactIdRow).contact_id : null;
  }

  private async findByProviderId(
    userId: string,
    provider: string,
    providerId: string,
  ): Promise<string | null> {
    const db = await getDb();

    const result = await db.execute(sql`
      SELECT contact_id
      FROM contact_identities
      WHERE user_id = ${userId}
        AND kind = 'provider_id'
        AND value = ${providerId}
        AND provider = ${provider}
      LIMIT 1
    `);

    return result.length > 0 ? (result[0] as unknown as ContactIdRow).contact_id : null;
  }

  private normalizePhone(phone: string): string {
    // Basic phone normalization - remove non-digits
    // TODO: Implement proper E.164 formatting
    return phone.replace(/\D/g, "");
  }

  private mapToContactIdentity(row: ContactIdentityRow): ContactIdentity {
    return {
      id: row.id,
      userId: row.user_id,
      contactId: row.contact_id,
      kind: row.kind as ContactIdentity["kind"],
      value: row.value,
      provider: row.provider,
      createdAt: row.created_at,
    };
  }
}



===== packages/repo/src/inbox.repo.ts =====
import { eq, and, desc, ilike, inArray, sql } from "drizzle-orm";
import { inboxItems } from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import type { InboxItem, CreateInboxItem } from "@/server/db/schema";
import { ok, err, DbResult } from "@/lib/utils/result";

// Local type aliases for repository layer
type InboxItemDTO = InboxItem;
type CreateInboxItemDTO = CreateInboxItem;
type UpdateInboxItemDTO = Partial<CreateInboxItem>;
type InboxItemStatus = "unprocessed" | "processed" | "archived";

interface InboxFilters {
  status?: InboxItemStatus[];
  search?: string;
  createdAfter?: Date;
  createdBefore?: Date;
}

export class InboxRepository {
  /**
   * List inbox items for a user with optional filtering
   */
  static async listInboxItems(
    userId: string,
    filters?: InboxFilters,
  ): Promise<DbResult<InboxItemDTO[]>> {
    try {
      const db = await getDb();

      // Build conditions array
      const conditions = [eq(inboxItems.userId, userId)];

      if (filters?.status && filters.status.length > 0) {
        conditions.push(inArray(inboxItems.status, filters.status));
      }

      if (filters?.search) {
        conditions.push(ilike(inboxItems.rawText, `%${filters.search}%`));
      }

      if (filters?.createdAfter) {
        conditions.push(sql`${inboxItems.createdAt} >= ${filters.createdAfter}`);
      }

      if (filters?.createdBefore) {
        conditions.push(sql`${inboxItems.createdAt} <= ${filters.createdBefore}`);
      }

      const query = db
        .select({
          id: inboxItems.id,
          userId: inboxItems.userId,
          rawText: inboxItems.rawText,
          status: inboxItems.status,
          createdTaskId: inboxItems.createdTaskId,
          processedAt: inboxItems.processedAt,
          createdAt: inboxItems.createdAt,
          updatedAt: inboxItems.updatedAt,
        })
        .from(inboxItems)
        .where(and(...conditions))
        .orderBy(desc(inboxItems.createdAt));

      const rows = await query;
      return ok(rows.map((row) => row));
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to list inbox items",
        details: error,
      });
    }
  }

  /**
   * Get a single inbox item by ID
   */
  static async getInboxItemById(userId: string, itemId: string): Promise<InboxItemDTO | null> {
    const db = await getDb();

    const rows = await db
      .select({
        id: inboxItems.id,
        userId: inboxItems.userId,
        rawText: inboxItems.rawText,
        status: inboxItems.status,
        createdTaskId: inboxItems.createdTaskId,
        processedAt: inboxItems.processedAt,
        createdAt: inboxItems.createdAt,
        updatedAt: inboxItems.updatedAt,
      })
      .from(inboxItems)
      .where(and(eq(inboxItems.userId, userId), eq(inboxItems.id, itemId)))
      .limit(1);

    if (rows.length === 0) {
      return null;
    }

    return rows[0] ?? null;
  }

  /**
   * Create a new inbox item
   */
  static async createInboxItem(
    data: CreateInboxItemDTO & { userId: string },
  ): Promise<InboxItemDTO> {
    const db = await getDb();

    const insertValues = {
      userId: data.userId,
      rawText: data.rawText,
      status: "unprocessed" as const,
      createdTaskId: null,
      processedAt: null,
    };

    const [newItem] = await db.insert(inboxItems).values(insertValues).returning({
      id: inboxItems.id,
      userId: inboxItems.userId,
      rawText: inboxItems.rawText,
      status: inboxItems.status,
      createdTaskId: inboxItems.createdTaskId,
      processedAt: inboxItems.processedAt,
      createdAt: inboxItems.createdAt,
      updatedAt: inboxItems.updatedAt,
    });

    if (!newItem) {
      throw new Error("Failed to create inbox item - no data returned");
    }

    return newItem;
  }

  /**
   * Update an existing inbox item
   */
  static async updateInboxItem(
    userId: string,
    itemId: string,
    data: UpdateInboxItemDTO,
  ): Promise<InboxItemDTO | null> {
    const db = await getDb();

    const updateValues = {
      updatedAt: new Date(),
      ...(data.status !== undefined && { status: data.status }),
      ...(data.createdTaskId !== undefined && { createdTaskId: data.createdTaskId ?? null }),
      ...(data.status === "processed" && { processedAt: new Date() }),
    };

    const [updatedItem] = await db
      .update(inboxItems)
      .set(updateValues)
      .where(and(eq(inboxItems.userId, userId), eq(inboxItems.id, itemId)))
      .returning({
        id: inboxItems.id,
        userId: inboxItems.userId,
        rawText: inboxItems.rawText,
        status: inboxItems.status,
        createdTaskId: inboxItems.createdTaskId,
        processedAt: inboxItems.processedAt,
        createdAt: inboxItems.createdAt,
        updatedAt: inboxItems.updatedAt,
      });

    if (!updatedItem) {
      return null;
    }

    return updatedItem;
  }

  /**
   * Delete an inbox item
   */
  static async deleteInboxItem(userId: string, itemId: string): Promise<boolean> {
    const db = await getDb();

    const result = await db
      .delete(inboxItems)
      .where(and(eq(inboxItems.userId, userId), eq(inboxItems.id, itemId)));

    return result.length > 0;
  }

  /**
   * Mark multiple inbox items with a status
   */
  static async bulkUpdateStatus(
    userId: string,
    itemIds: string[],
    status: InboxItemStatus,
  ): Promise<InboxItemDTO[]> {
    if (itemIds.length === 0) {
      return [];
    }

    const db = await getDb();

    const updateValues = {
      status,
      updatedAt: new Date(),
      ...(status === "processed" && { processedAt: new Date() }),
    };

    const updatedItems = await db
      .update(inboxItems)
      .set(updateValues)
      .where(and(eq(inboxItems.userId, userId), inArray(inboxItems.id, itemIds)))
      .returning({
        id: inboxItems.id,
        userId: inboxItems.userId,
        rawText: inboxItems.rawText,
        status: inboxItems.status,
        createdTaskId: inboxItems.createdTaskId,
        processedAt: inboxItems.processedAt,
        createdAt: inboxItems.createdAt,
        updatedAt: inboxItems.updatedAt,
      });

    return updatedItems.map((item) => item);
  }

  /**
   * Delete multiple inbox items by IDs
   */
  static async bulkDeleteInboxItems(userId: string, itemIds: string[]): Promise<number> {
    if (itemIds.length === 0) {
      return 0;
    }

    const db = await getDb();

    // Count items to delete first
    const countRows = await db
      .select({ n: sql<number>`count(*)` })
      .from(inboxItems)
      .where(and(eq(inboxItems.userId, userId), inArray(inboxItems.id, itemIds)))
      .limit(1);
    const n = countRows[0]?.n ?? 0;

    if (n === 0) {
      return 0;
    }

    // Delete the items
    await db
      .delete(inboxItems)
      .where(and(eq(inboxItems.userId, userId), inArray(inboxItems.id, itemIds)));

    return n;
  }

  /**
   * Count inbox items by status for a user
   */
  static async getInboxStats(userId: string): Promise<{
    unprocessed: number;
    processed: number;
    archived: number;
    total: number;
  }> {
    const db = await getDb();

    const result = await db
      .select({
        status: inboxItems.status,
        count: sql<number>`count(*)`,
      })
      .from(inboxItems)
      .where(eq(inboxItems.userId, userId))
      .groupBy(inboxItems.status);

    const stats = {
      unprocessed: 0,
      processed: 0,
      archived: 0,
      total: 0,
    };

    for (const row of result) {
      const status = row.status as InboxItemStatus;
      const count = row.count;
      stats[status] = count;
      stats.total += count;
    }

    return stats;
  }

  /**
   * Get unprocessed inbox items for AI processing
   */
  static async getUnprocessedItems(userId: string, limit = 10): Promise<InboxItemDTO[]> {
    const db = await getDb();

    const rows = await db
      .select({
        id: inboxItems.id,
        userId: inboxItems.userId,
        rawText: inboxItems.rawText,
        status: inboxItems.status,
        createdTaskId: inboxItems.createdTaskId,
        processedAt: inboxItems.processedAt,
        createdAt: inboxItems.createdAt,
        updatedAt: inboxItems.updatedAt,
      })
      .from(inboxItems)
      .where(and(eq(inboxItems.userId, userId), eq(inboxItems.status, "unprocessed")))
      .orderBy(desc(inboxItems.createdAt))
      .limit(limit);

    return rows.map((row) => row);
  }

  /**
   * Mark an inbox item as processed with created task reference
   */
  static async markAsProcessed(
    userId: string,
    itemId: string,
    createdTaskId?: string,
  ): Promise<InboxItemDTO | null> {
    const db = await getDb();

    const updateValues = {
      status: "processed" as const,
      processedAt: new Date(),
      updatedAt: new Date(),
      ...(createdTaskId && { createdTaskId }),
    };

    const [updatedItem] = await db
      .update(inboxItems)
      .set(updateValues)
      .where(and(eq(inboxItems.userId, userId), eq(inboxItems.id, itemId)))
      .returning({
        id: inboxItems.id,
        userId: inboxItems.userId,
        rawText: inboxItems.rawText,
        status: inboxItems.status,
        createdTaskId: inboxItems.createdTaskId,
        processedAt: inboxItems.processedAt,
        createdAt: inboxItems.createdAt,
        updatedAt: inboxItems.updatedAt,
      });

    if (!updatedItem) {
      return null;
    }

    return updatedItem;
  }
}



===== packages/repo/src/index.ts =====
// Database client and utilities
export { getDb, db, getSql, closeDb } from "@/server/db/client";
export type { PostgresJsDatabase } from "drizzle-orm/postgres-js";

// Repository classes
export { AuthUserRepository } from "./auth-user.repo";
export { ContactsRepository } from "./contacts.repo";
export { InteractionsRepository } from "./interactions.repo";
export { NotesRepository } from "./notes.repo";
export { CalendarEventsRepository } from "./calendar-events.repo";
export { IdentitiesRepository } from "./identities.repo";
export { SearchRepository } from "./search.repo";
export { MomentumRepository, momentumRepository } from "./momentum.repo";
export { UserIntegrationsRepository } from "./user-integrations.repo";
export { SyncSessionsRepository } from "./sync-sessions.repo";
export { RawEventsRepository } from "./raw-events.repo";
export type { RawEventListParams, RawEventListItem } from "./raw-events.repo";
export { JobsRepository } from "./jobs.repo";
export { OnboardingRepository } from "./onboarding.repo";
export type {
  OnboardingToken,
  CreateOnboardingToken,
  ClientData,
  ConsentData,
  TokenValidationResult,
} from "./onboarding.repo";

// Auth User types
export type { UserContext, UserProfile } from "./auth-user.repo";

// Search types
export type { SearchResultDTO, TraditionalSearchParams, SemanticSearchParams } from "./search.repo";

// OmniMomentum Repository classes
export { InboxRepository } from "./inbox.repo";
export { ZonesRepository } from "./zones.repo";

// Re-export database schema types for convenience
export * from "@/server/db/schema";



===== packages/repo/src/interactions.repo.ts =====
import { eq, and, desc, gte, lte, inArray, count, sql } from "drizzle-orm";
import { interactions } from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import type { Interaction, CreateInteraction } from "@/server/db/schema";
import { ok, err, DbResult } from "@/lib/utils/result";

interface InteractionFilters {
  contactId?: string;
  type?: string[];
  source?: string[];
  occurredAfter?: Date;
  occurredBefore?: Date;
}

// Additional types for server compatibility
interface IdRow {
  id: string;
}

interface EmbeddingRow {
  id: string;
  bodyText: string | null;
}

interface TypeStatsRow {
  type: string;
  count: string;
}

interface LinkStatsRow {
  linked: string;
  unlinked: string;
}

interface SourceStatsRow {
  source: string;
  count: string;
}

export class InteractionsRepository {
  /**
   * List interactions for a user with optional filtering
   */
  static async listInteractions(
    userId: string,
    filters?: InteractionFilters,
  ): Promise<DbResult<Interaction[]>> {
    try {
      const db = await getDb();

      // Build conditions array
      const conditions = [eq(interactions.userId, userId)];

      if (filters?.contactId) {
        conditions.push(eq(interactions.contactId, filters.contactId));
      }

      if (filters?.type && filters.type.length > 0) {
        conditions.push(inArray(interactions.type, filters.type));
      }

      if (filters?.source && filters.source.length > 0) {
        conditions.push(inArray(interactions.source, filters.source));
      }

      if (filters?.occurredAfter) {
        conditions.push(gte(interactions.occurredAt, filters.occurredAfter));
      }

      if (filters?.occurredBefore) {
        conditions.push(lte(interactions.occurredAt, filters.occurredBefore));
      }

      const query = db
        .select({
          id: interactions.id,
          userId: interactions.userId,
          contactId: interactions.contactId,
          type: interactions.type,
          subject: interactions.subject,
          bodyText: interactions.bodyText,
          bodyRaw: interactions.bodyRaw,
          occurredAt: interactions.occurredAt,
          source: interactions.source,
          sourceId: interactions.sourceId,
          sourceMeta: interactions.sourceMeta,
          batchId: interactions.batchId,
          createdAt: interactions.createdAt,
        })
        .from(interactions)
        .where(and(...conditions))
        .orderBy(desc(interactions.occurredAt));

      const rows = await query;

      return ok(rows.map((row) => row));
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to list interactions",
        details: error,
      });
    }
  }

  /**
   * Get a single interaction by ID
   */
  static async getInteractionById(
    userId: string,
    interactionId: string,
  ): Promise<DbResult<Interaction | null>> {
    try {
      const db = await getDb();

      const rows = await db
        .select({
          id: interactions.id,
          userId: interactions.userId,
          contactId: interactions.contactId,
          type: interactions.type,
          subject: interactions.subject,
          bodyText: interactions.bodyText,
          bodyRaw: interactions.bodyRaw,
          occurredAt: interactions.occurredAt,
          source: interactions.source,
          sourceId: interactions.sourceId,
          sourceMeta: interactions.sourceMeta,
          batchId: interactions.batchId,
          createdAt: interactions.createdAt,
        })
        .from(interactions)
        .where(and(eq(interactions.userId, userId), eq(interactions.id, interactionId)))
        .limit(1);

      if (rows.length === 0) {
        return ok(null);
      }

      return ok(rows[0]!);
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to get interaction",
        details: error,
      });
    }
  }

  /**
   * Get interactions for a specific contact
   */
  static async getInteractionsByContactId(
    userId: string,
    contactId: string,
  ): Promise<Interaction[]> {
    const db = await getDb();

    const rows = await db
      .select({
        id: interactions.id,
        userId: interactions.userId,
        contactId: interactions.contactId,
        type: interactions.type,
        subject: interactions.subject,
        bodyText: interactions.bodyText,
        bodyRaw: interactions.bodyRaw,
        occurredAt: interactions.occurredAt,
        source: interactions.source,
        sourceId: interactions.sourceId,
        sourceMeta: interactions.sourceMeta,
        batchId: interactions.batchId,
        createdAt: interactions.createdAt,
      })
      .from(interactions)
      .where(and(eq(interactions.userId, userId), eq(interactions.contactId, contactId)))
      .orderBy(desc(interactions.occurredAt));

    return rows.map((row) => row);
  }

  /**
   * Create a new interaction
   */
  static async createInteraction(
    userId: string,
    data: CreateInteraction,
  ): Promise<DbResult<Interaction>> {
    try {
      const db = await getDb();

      // Convert undefined to null for database nullable fields with exactOptionalPropertyTypes
      const insertValues = {
        userId: userId,
        contactId: data.contactId ?? null,
        type: data.type,
        subject: data.subject ?? null,
        bodyText: data.bodyText ?? null,
        bodyRaw: data.bodyRaw ?? null,
        occurredAt: data.occurredAt,
        source: data.source ?? null,
        sourceId: data.sourceId ?? null,
        sourceMeta: data.sourceMeta ?? null,
        batchId: data.batchId ?? null,
      };

      const [newInteraction] = await db.insert(interactions).values(insertValues).returning({
        id: interactions.id,
        userId: interactions.userId,
        contactId: interactions.contactId,
        type: interactions.type,
        subject: interactions.subject,
        bodyText: interactions.bodyText,
        bodyRaw: interactions.bodyRaw,
        occurredAt: interactions.occurredAt,
        source: interactions.source,
        sourceId: interactions.sourceId,
        sourceMeta: interactions.sourceMeta,
        batchId: interactions.batchId,
        createdAt: interactions.createdAt,
      });

      if (!newInteraction) {
        return err({
          code: "DB_INSERT_FAILED",
          message: "Failed to create interaction - no data returned",
        });
      }

      return ok(newInteraction);
    } catch (error) {
      return err({
        code: "DB_INSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to create interaction",
        details: error,
      });
    }
  }

  /**
   * Update an existing interaction
   */
  static async updateInteraction(
    userId: string,
    interactionId: string,
    data: Partial<CreateInteraction>,
  ): Promise<Interaction | null> {
    const db = await getDb();

    // Convert undefined to null for database nullable fields with exactOptionalPropertyTypes
    const updateValues = {
      ...(data.contactId !== undefined && { contactId: data.contactId ?? null }),
      ...(data.type !== undefined && { type: data.type }),
      ...(data.subject !== undefined && { subject: data.subject ?? null }),
      ...(data.bodyText !== undefined && { bodyText: data.bodyText ?? null }),
      ...(data.bodyRaw !== undefined && { bodyRaw: data.bodyRaw ?? null }),
      ...(data.occurredAt !== undefined && { occurredAt: data.occurredAt }),
      ...(data.source !== undefined && { source: data.source ?? null }),
      ...(data.sourceId !== undefined && { sourceId: data.sourceId ?? null }),
      ...(data.sourceMeta !== undefined && { sourceMeta: data.sourceMeta ?? null }),
      ...(data.batchId !== undefined && { batchId: data.batchId ?? null }),
    };

    const [updatedInteraction] = await db
      .update(interactions)
      .set(updateValues)
      .where(and(eq(interactions.userId, userId), eq(interactions.id, interactionId)))
      .returning({
        id: interactions.id,
        userId: interactions.userId,
        contactId: interactions.contactId,
        type: interactions.type,
        subject: interactions.subject,
        bodyText: interactions.bodyText,
        bodyRaw: interactions.bodyRaw,
        occurredAt: interactions.occurredAt,
        source: interactions.source,
        sourceId: interactions.sourceId,
        sourceMeta: interactions.sourceMeta,
        batchId: interactions.batchId,
        createdAt: interactions.createdAt,
      });

    if (!updatedInteraction) {
      return null;
    }

    return updatedInteraction;
  }

  /**
   * Delete an interaction
   */
  static async deleteInteraction(userId: string, interactionId: string): Promise<boolean> {
    const db = await getDb();

    const result = await db
      .delete(interactions)
      .where(and(eq(interactions.userId, userId), eq(interactions.id, interactionId)));

    return result.length > 0;
  }

  /**
   * Bulk create interactions (useful for sync operations)
   */
  static async bulkCreateInteractions(
    userId: string,
    data: CreateInteraction[],
  ): Promise<Interaction[]> {
    const db = await getDb();

    const newInteractions = await db
      .insert(interactions)
      .values(
        data.map((item) => ({
          userId: userId,
          contactId: item.contactId ?? null,
          type: item.type,
          subject: item.subject ?? null,
          bodyText: item.bodyText ?? null,
          bodyRaw: item.bodyRaw ?? null,
          occurredAt: item.occurredAt,
          source: item.source ?? null,
          sourceId: item.sourceId ?? null,
          sourceMeta: item.sourceMeta ?? null,
          batchId: item.batchId ?? null,
        })),
      )
      .returning({
        id: interactions.id,
        userId: interactions.userId,
        contactId: interactions.contactId,
        type: interactions.type,
        subject: interactions.subject,
        bodyText: interactions.bodyText,
        bodyRaw: interactions.bodyRaw,
        occurredAt: interactions.occurredAt,
        source: interactions.source,
        sourceId: interactions.sourceId,
        sourceMeta: interactions.sourceMeta,
        batchId: interactions.batchId,
        createdAt: interactions.createdAt,
      });

    return newInteractions.map((row) => row);
  }

  /**
   * Count interactions for a user
   */
  static async countInteractions(userId: string, filters?: InteractionFilters): Promise<number> {
    const db = await getDb();

    // Build conditions array
    const conditions = [eq(interactions.userId, userId)];

    if (filters?.contactId) {
      conditions.push(eq(interactions.contactId, filters.contactId));
    }

    if (filters?.type && filters.type.length > 0) {
      conditions.push(inArray(interactions.type, filters.type));
    }

    if (filters?.source && filters.source.length > 0) {
      conditions.push(inArray(interactions.source, filters.source));
    }

    if (filters?.occurredAfter) {
      conditions.push(gte(interactions.occurredAt, filters.occurredAfter));
    }

    if (filters?.occurredBefore) {
      conditions.push(lte(interactions.occurredAt, filters.occurredBefore));
    }

    const result = await db
      .select({ count: count() })
      .from(interactions)
      .where(and(...conditions));

    return result[0]?.count ?? 0;
  }

  /**
   * Upsert interaction with idempotency on (user_id, source, source_id)
   */
  static async upsert(
    interaction: CreateInteraction & { userId: string },
  ): Promise<string | null> {
    const db = await getDb();

    const result = await db.execute(sql`
      INSERT INTO interactions (
        user_id, contact_id, type, subject, body_text, body_raw,
        occurred_at, source, source_id, source_meta, batch_id, created_at
      ) VALUES (
        ${interaction.userId}, ${interaction.contactId}, ${interaction.type},
        ${interaction.subject}, ${interaction.bodyText}, ${JSON.stringify(interaction.bodyRaw)},
        ${interaction.occurredAt}, ${interaction.source}, ${interaction.sourceId},
        ${JSON.stringify(interaction.sourceMeta)}, ${interaction.batchId},
        ${new Date()}
      )
      ON CONFLICT (user_id, source, source_id) 
      DO UPDATE SET
        contact_id = EXCLUDED.contact_id,
        type = EXCLUDED.type,
        subject = EXCLUDED.subject,
        body_text = EXCLUDED.body_text,
        body_raw = EXCLUDED.body_raw,
        occurred_at = EXCLUDED.occurred_at,
        source_meta = EXCLUDED.source_meta,
        batch_id = EXCLUDED.batch_id
      RETURNING id
    `);

    return result.length > 0 ? (result[0] as unknown as IdRow).id : null;
  }

  /**
   * Bulk upsert interactions
   */
  static async bulkUpsert(
    interactions: Array<CreateInteraction & { userId: string }>,
  ): Promise<string[]> {
    const insertedIds: string[] = [];

    for (const interaction of interactions) {
      const id = await this.upsert(interaction);
      if (id) insertedIds.push(id);
    }

    return insertedIds;
  }

  /**
   * Get unlinked interactions (no contact_id)
   */
  static async getUnlinked(
    userId: string,
    options: {
      limit?: number;
      sources?: string[];
      daysSince?: number;
    } = {},
  ): Promise<Interaction[]> {
    const db = await getDb();

    const daysSince = options.daysSince ?? 7;

    const result = await db.execute(sql`
      SELECT 
        id,
        user_id AS "userId",
        contact_id AS "contactId",
        type,
        subject,
        body_text AS "bodyText",
        body_raw AS "bodyRaw",
        occurred_at AS "occurredAt",
        source,
        source_id AS "sourceId",
        source_meta AS "sourceMeta",
        batch_id AS "batchId",
        created_at AS "createdAt"
      FROM interactions
      WHERE user_id = ${userId}
        AND contact_id IS NULL
        AND created_at > now() - (${daysSince} * interval '1 day')
        ${options.sources?.length ? sql`AND source = ANY(${options.sources})` : sql``}
      ORDER BY created_at DESC
      LIMIT ${options.limit ?? 100}
    `);

    return result as unknown as Interaction[];
  }

  /**
   * Link interaction to contact
   */
  static async linkToContact(interactionId: string, contactId: string): Promise<void> {
    const db = await getDb();

    await db.execute(sql`
      UPDATE interactions
      SET contact_id = ${contactId}
      WHERE id = ${interactionId}
    `);
  }

  /**
   * Get recent interactions for timeline
   */
  static async getRecentForTimeline(
    userId: string,
    options: {
      limit?: number;
      hoursBack?: number;
      hasContact?: boolean;
    } = {},
  ): Promise<Interaction[]> {
    const db = await getDb();

    const hoursBack = options.hoursBack ?? 24;

    const result = await db.execute(sql`
      SELECT 
        id,
        user_id AS "userId",
        contact_id AS "contactId",
        type,
        subject,
        body_text AS "bodyText",
        body_raw AS "bodyRaw",
        occurred_at AS "occurredAt",
        source,
        source_id AS "sourceId",
        source_meta AS "sourceMeta",
        batch_id AS "batchId",
        created_at AS "createdAt"
      FROM interactions
      WHERE user_id = ${userId}
        AND created_at > now() - (INTERVAL '1 hour' * ${hoursBack})
        ${
          options.hasContact !== undefined
            ? options.hasContact
              ? sql`AND contact_id IS NOT NULL`
              : sql`AND contact_id IS NULL`
            : sql``
        }
      ORDER BY occurred_at DESC
      LIMIT ${options.limit ?? 100}
    `);

    return result as unknown as Interaction[];
  }

  /**
   * Get interactions without embeddings
   */
  static async getWithoutEmbeddings(
    userId: string,
    limit = 50,
  ): Promise<Array<{ id: string; bodyText: string | null }>> {
    const db = await getDb();

    const result = await db.execute(sql`
      SELECT i.id, i.body_text AS "bodyText"
      FROM interactions i
      LEFT JOIN embeddings e ON e.owner_type = 'interaction' AND e.owner_id = i.id
      WHERE i.user_id = ${userId}
        AND i.body_text IS NOT NULL
        AND i.body_text != ''
        AND e.id IS NULL
      ORDER BY i.created_at DESC
      LIMIT ${limit}
    `);

    return (result as unknown as EmbeddingRow[]).map((row) => ({
      id: row.id,
      bodyText: row.bodyText,
    }));
  }

  /**
   * Get interaction statistics
   */
  static async getStats(userId: string): Promise<{
    byType: Record<string, number>;
    linking: { linked: number; unlinked: number };
    bySource: Record<string, number>;
  }> {
    const db = await getDb();

    // Get counts by type
    const typeStats = await db.execute(sql`
      SELECT type, count(*) as count
      FROM interactions
      WHERE user_id = ${userId}
        AND created_at > now() - interval '30 days'
      GROUP BY type
      ORDER BY count DESC
    `);

    // Get linked vs unlinked counts
    const linkStats = await db.execute(sql`
      SELECT 
        count(*) FILTER (WHERE contact_id IS NOT NULL) as linked,
        count(*) FILTER (WHERE contact_id IS NULL) as unlinked
      FROM interactions
      WHERE user_id = ${userId}
        AND created_at > now() - interval '30 days'
    `);

    // Get source distribution
    const sourceStats = await db.execute(sql`
      SELECT source, count(*) as count
      FROM interactions
      WHERE user_id = ${userId}
        AND created_at > now() - interval '30 days'
      GROUP BY source
      ORDER BY count DESC
    `);

    return {
      byType: (typeStats as unknown as TypeStatsRow[]).reduce(
        (acc: Record<string, number>, row: TypeStatsRow) => {
          acc[row.type] = parseInt(row.count, 10);
          return acc;
        },
        {},
      ),
      linking: {
        linked: parseInt((linkStats[0] as unknown as LinkStatsRow)?.linked ?? "0", 10),
        unlinked: parseInt((linkStats[0] as unknown as LinkStatsRow)?.unlinked ?? "0", 10),
      },
      bySource: (sourceStats as unknown as SourceStatsRow[]).reduce(
        (acc: Record<string, number>, row: SourceStatsRow) => {
          acc[row.source] = parseInt(row.count, 10);
          return acc;
        },
        {},
      ),
    };
  }
}



===== packages/repo/src/jobs.repo.ts =====
import { eq, and, desc, inArray, count, sql } from "drizzle-orm";
import { jobs } from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import type { Job, CreateJob } from "@/server/db/schema";
import { ok, err, DbResult } from "@/lib/utils/result";

// Local type aliases for repository layer
type JobDTO = Job;
type CreateJobDTO = CreateJob;

export class JobsRepository {
  /**
   * Create a new job
   */
  static async createJob(data: CreateJobDTO & { userId: string }): Promise<DbResult<JobDTO>> {
    try {
      const db = await getDb();

      if (!data.userId || !data.kind) {
        return err({
          code: "VALIDATION_ERROR",
          message: "Required fields missing: userId and kind are required",
        });
      }

      const insertValues = {
        userId: data.userId,
        kind: data.kind,
        payload: data.payload,
        batchId: data.batchId ?? null,
        status: "queued" as const,
        attempts: 0,
        lastError: null,
      };

      const [newJob] = await db.insert(jobs).values(insertValues).returning({
        id: jobs.id,
        userId: jobs.userId,
        kind: jobs.kind,
        payload: jobs.payload,
        status: jobs.status,
        attempts: jobs.attempts,
        batchId: jobs.batchId,
        lastError: jobs.lastError,
        createdAt: jobs.createdAt,
        updatedAt: jobs.updatedAt,
      });

      if (!newJob) {
        return err({
          code: "DB_INSERT_FAILED",
          message: "Failed to create job - no data returned",
        });
      }

      return ok(newJob);
    } catch (error) {
      return err({
        code: "DB_INSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to create job",
        details: error,
      });
    }
  }

  /**
   * Get a job by ID
   */
  static async getJobById(userId: string, jobId: string): Promise<DbResult<JobDTO | null>> {
    try {
      const db = await getDb();

      const rows = await db
        .select({
          id: jobs.id,
          userId: jobs.userId,
          kind: jobs.kind,
          payload: jobs.payload,
          status: jobs.status,
          attempts: jobs.attempts,
          batchId: jobs.batchId,
          lastError: jobs.lastError,
          createdAt: jobs.createdAt,
          updatedAt: jobs.updatedAt,
        })
        .from(jobs)
        .where(and(eq(jobs.userId, userId), eq(jobs.id, jobId)))
        .limit(1);

      return ok(rows.length === 0 ? null : (rows[0] ?? null));
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to get job",
        details: error,
      });
    }
  }

  /**
   * List jobs for a user with optional filtering
   */
  static async listJobs(
    userId: string,
    options: {
      status?: string[];
      kind?: string[];
      batchId?: string;
      limit?: number;
      offset?: number;
    } = {},
  ): Promise<JobDTO[]> {
    const db = await getDb();
    const { status, kind, batchId, limit = 50, offset = 0 } = options;

    const conditions = [eq(jobs.userId, userId)];

    if (status && status.length > 0) {
      conditions.push(inArray(jobs.status, status));
    }

    if (kind && kind.length > 0) {
      conditions.push(inArray(jobs.kind, kind));
    }

    if (batchId) {
      conditions.push(eq(jobs.batchId, batchId));
    }

    const rows = await db
      .select({
        id: jobs.id,
        userId: jobs.userId,
        kind: jobs.kind,
        payload: jobs.payload,
        status: jobs.status,
        attempts: jobs.attempts,
        batchId: jobs.batchId,
        lastError: jobs.lastError,
        createdAt: jobs.createdAt,
        updatedAt: jobs.updatedAt,
      })
      .from(jobs)
      .where(and(...conditions))
      .orderBy(desc(jobs.updatedAt))
      .limit(limit)
      .offset(offset);

    return rows.map((row) => row);
  }

  /**
   * Get job counts by status and kind
   */
  static async getJobCounts(
    userId: string,
    batchId?: string,
  ): Promise<{
    statusCounts: Record<string, number>;
    kindCounts: Record<string, number>;
  }> {
    const db = await getDb();

    const conditions = [eq(jobs.userId, userId)];
    if (batchId) {
      conditions.push(eq(jobs.batchId, batchId));
    }

    const jobCounts = await db
      .select({
        status: jobs.status,
        kind: jobs.kind,
        count: count(),
      })
      .from(jobs)
      .where(and(...conditions))
      .groupBy(jobs.status, jobs.kind);

    const statusCounts = {
      queued: 0,
      processing: 0,
      completed: 0,
      failed: 0,
      retrying: 0,
    };

    const kindCounts = {
      normalize: 0,
      embed: 0,
      insight: 0,
      sync_gmail: 0,
      sync_calendar: 0,
      google_gmail_sync: 0,
    };

    jobCounts.forEach(({ status, kind, count: jobCount }) => {
      if (status && status in statusCounts) {
        statusCounts[status as keyof typeof statusCounts] += jobCount;
      }
      if (kind in kindCounts) {
        kindCounts[kind as keyof typeof kindCounts] += jobCount;
      }
    });

    return { statusCounts, kindCounts };
  }

  /**
   * Get pending jobs (queued, processing, retrying)
   */
  static async getPendingJobs(
    userId: string,
    batchId?: string,
    limit: number = 50,
  ): Promise<JobDTO[]> {
    const db = await getDb();

    const conditions = [
      eq(jobs.userId, userId),
      inArray(jobs.status, ["queued", "processing", "retrying"]),
    ];

    if (batchId) {
      conditions.push(eq(jobs.batchId, batchId));
    }

    const rows = await db
      .select({
        id: jobs.id,
        userId: jobs.userId,
        kind: jobs.kind,
        payload: jobs.payload,
        status: jobs.status,
        attempts: jobs.attempts,
        batchId: jobs.batchId,
        lastError: jobs.lastError,
        createdAt: jobs.createdAt,
        updatedAt: jobs.updatedAt,
      })
      .from(jobs)
      .where(and(...conditions))
      .orderBy(jobs.createdAt)
      .limit(limit);

    return rows.map((row) => row);
  }

  /**
   * Get recent jobs for history/monitoring
   */
  static async getRecentJobs(
    userId: string,
    batchId?: string,
    limit: number = 20,
  ): Promise<JobDTO[]> {
    const db = await getDb();

    const conditions = [eq(jobs.userId, userId)];
    if (batchId) {
      conditions.push(eq(jobs.batchId, batchId));
    }

    const rows = await db
      .select({
        id: jobs.id,
        userId: jobs.userId,
        kind: jobs.kind,
        payload: jobs.payload,
        status: jobs.status,
        attempts: jobs.attempts,
        batchId: jobs.batchId,
        lastError: jobs.lastError,
        createdAt: jobs.createdAt,
        updatedAt: jobs.updatedAt,
      })
      .from(jobs)
      .where(and(...conditions))
      .orderBy(desc(jobs.updatedAt))
      .limit(limit);

    return rows.map((row) => row);
  }

  /**
   * Update job status and error information
   */
  static async updateJobStatus(
    userId: string,
    jobId: string,
    updates: {
      status?: string;
      attempts?: number;
      lastError?: string | null;
    },
  ): Promise<DbResult<JobDTO | null>> {
    try {
      const db = await getDb();

      const updateValues = {
        updatedAt: new Date(),
        ...(updates.status !== undefined && { status: updates.status }),
        ...(updates.attempts !== undefined && { attempts: updates.attempts }),
        ...(updates.lastError !== undefined && { lastError: updates.lastError }),
      };

      const [updatedJob] = await db
        .update(jobs)
        .set(updateValues)
        .where(and(eq(jobs.userId, userId), eq(jobs.id, jobId)))
        .returning({
          id: jobs.id,
          userId: jobs.userId,
          kind: jobs.kind,
          payload: jobs.payload,
          status: jobs.status,
          attempts: jobs.attempts,
          batchId: jobs.batchId,
          lastError: jobs.lastError,
          createdAt: jobs.createdAt,
          updatedAt: jobs.updatedAt,
        });

      return ok(updatedJob || null);
    } catch (error) {
      return err({
        code: "DB_UPDATE_FAILED",
        message: error instanceof Error ? error.message : "Failed to update job",
        details: error,
      });
    }
  }

  /**
   * Delete jobs by batch ID
   */
  static async deleteJobsByBatch(userId: string, batchId: string): Promise<number> {
    const db = await getDb();

    const result = await db
      .delete(jobs)
      .where(and(eq(jobs.userId, userId), eq(jobs.batchId, batchId)));

    return result.length;
  }

  /**
   * Count total jobs for a user
   */
  static async countJobs(userId: string, batchId?: string): Promise<number> {
    const db = await getDb();

    const conditions = [eq(jobs.userId, userId)];
    if (batchId) {
      conditions.push(eq(jobs.batchId, batchId));
    }

    const result = await db
      .select({ count: count() })
      .from(jobs)
      .where(and(...conditions));

    return result[0]?.count ?? 0;
  }

  /**
   * Get jobs that have been processing for too long (stuck jobs)
   */
  static async getStuckJobs(userId: string, thresholdMinutes: number = 10): Promise<JobDTO[]> {
    const db = await getDb();

    const thresholdTime = new Date(Date.now() - thresholdMinutes * 60 * 1000);

    const rows = await db
      .select({
        id: jobs.id,
        userId: jobs.userId,
        kind: jobs.kind,
        payload: jobs.payload,
        status: jobs.status,
        attempts: jobs.attempts,
        batchId: jobs.batchId,
        lastError: jobs.lastError,
        createdAt: jobs.createdAt,
        updatedAt: jobs.updatedAt,
      })
      .from(jobs)
      .where(
        and(
          eq(jobs.userId, userId),
          eq(jobs.status, "processing"),
          sql`${jobs.updatedAt} < ${thresholdTime}`,
        ),
      );

    return rows.map((row) => row);
  }

  /**
   * Bulk create jobs for batch operations
   */
  static async createBulkJobs(
    jobsData: Array<CreateJobDTO & { userId: string }>,
  ): Promise<JobDTO[]> {
    if (jobsData.length === 0) {
      return [];
    }

    const db = await getDb();

    const insertValues = jobsData.map((job) => ({
      userId: job.userId,
      kind: job.kind,
      payload: job.payload,
      batchId: job.batchId ?? null,
      status: "queued" as const,
      attempts: 0,
      lastError: null,
    }));

    const newJobs = await db.insert(jobs).values(insertValues).returning({
      id: jobs.id,
      userId: jobs.userId,
      kind: jobs.kind,
      payload: jobs.payload,
      status: jobs.status,
      attempts: jobs.attempts,
      batchId: jobs.batchId,
      lastError: jobs.lastError,
      createdAt: jobs.createdAt,
      updatedAt: jobs.updatedAt,
    });

    return newJobs.map((job) => job);
  }
}



===== packages/repo/src/momentum.repo.ts =====
// OmniMomentum repository - Projects, Tasks, Goals, and Daily Pulse
import { getDb } from "@/server/db/client";
import { ok, DbResult, dbError } from "@/lib/utils/result";
import {
  projects,
  tasks,
  goals,
  dailyPulseLogs,
  zones,
  inboxItems,
  taskContactTags,
  contacts,
} from "@/server/db/schema";
import { eq, desc, and, asc, isNull, inArray } from "drizzle-orm";
import type {
  InboxItem,
  Project,
  CreateProject,
  Task,
  CreateTask,
  Goal,
  CreateGoal,
  DailyPulseLog,
  CreateDailyPulseLog,
} from "@/server/db/schema";

// Local type aliases for repository layer
type ProjectDTO = Project;
type CreateProjectDTO = CreateProject;
type UpdateProjectDTO = Partial<CreateProject>;
type TaskDTO = Task;
type CreateTaskDTO = CreateTask;
type UpdateTaskDTO = Partial<CreateTask>;
type GoalDTO = Goal;
type CreateGoalDTO = CreateGoal;
type UpdateGoalDTO = Partial<CreateGoal>;
type DailyPulseLogDTO = DailyPulseLog;
type CreateDailyPulseLogDTO = CreateDailyPulseLog;
type UpdateDailyPulseLogDTO = Partial<CreateDailyPulseLog>;

interface ProjectFilters {
  zoneId?: number;
  status?: string[];
}

interface TaskFilters {
  projectId?: string;
  parentTaskId?: string | null;
  status?: string[];
  priority?: string[];
}

interface GoalFilters {
  contactId?: string;
  goalType?: string[];
  status?: string[];
}

export class MomentumRepository {
  // ============================================================================
  // PROJECTS (Pathways)
  // ============================================================================

  async createProject(userId: string, data: CreateProjectDTO): Promise<DbResult<ProjectDTO>> {
    try {
      const db = await getDb();
      const [project] = await db
        .insert(projects)
        .values({
          ...data,
          userId,
          zoneId: data.zoneId ?? null,
          dueDate: data.dueDate ?? null,
          details: data.details ?? {},
        })
        .returning();
      if (!project) {
        return dbError("DB_INSERT_FAILED", "Failed to create project - no data returned");
      }
      return ok(this.mapProjectToDTO(project));
    } catch (error) {
      return dbError(
        "DB_INSERT_FAILED",
        error instanceof Error ? error.message : "Failed to create project",
        error,
      );
    }
  }

  async getProjects(userId: string, filters: ProjectFilters = {}): Promise<DbResult<ProjectDTO[]>> {
    try {
      const db = await getDb();
      const whereConditions = [eq(projects.userId, userId)];

      if (filters.zoneId !== undefined) {
        whereConditions.push(eq(projects.zoneId, filters.zoneId));
      }

      if (filters.status && filters.status.length > 0) {
        const validStatuses = filters.status.filter(
          (status): status is "active" | "on_hold" | "completed" | "archived" =>
            ["active", "on_hold", "completed", "archived"].includes(status),
        );
        if (validStatuses.length > 0) {
          whereConditions.push(inArray(projects.status, validStatuses));
        }
      }

      const projectsData = await db
        .select()
        .from(projects)
        .where(and(...whereConditions))
        .orderBy(desc(projects.updatedAt));

      return ok(projectsData.map((p) => this.mapProjectToDTO(p)));
    } catch (error) {
      return dbError(
        "DB_QUERY_FAILED",
        error instanceof Error ? error.message : "Failed to get projects",
        error,
      );
    }
  }

  async getProject(projectId: string, userId: string): Promise<DbResult<ProjectDTO | null>> {
    try {
      const db = await getDb();
      const [project] = await db
        .select()
        .from(projects)
        .where(and(eq(projects.id, projectId), eq(projects.userId, userId)));
      return ok(project ? this.mapProjectToDTO(project) : null);
    } catch (error) {
      return dbError(
        "DB_QUERY_FAILED",
        error instanceof Error ? error.message : "Failed to get project",
        error,
      );
    }
  }

  async updateProject(
    projectId: string,
    userId: string,
    data: UpdateProjectDTO,
  ): Promise<DbResult<void>> {
    try {
      const db = await getDb();
      // Filter out undefined values for exact optional property types
      const updateData = Object.fromEntries(
        Object.entries(data).filter(([, value]) => value !== undefined),
      );

      await db
        .update(projects)
        .set({ ...updateData, updatedAt: new Date() })
        .where(and(eq(projects.id, projectId), eq(projects.userId, userId)));

      return ok(undefined);
    } catch (error) {
      return dbError(
        "DB_UPDATE_FAILED",
        error instanceof Error ? error.message : "Failed to update project",
        error,
      );
    }
  }

  async deleteProject(projectId: string, userId: string): Promise<DbResult<void>> {
    try {
      const db = await getDb();
      await db.delete(projects).where(and(eq(projects.id, projectId), eq(projects.userId, userId)));
      return ok(undefined);
    } catch (error) {
      return dbError(
        "DB_DELETE_FAILED",
        error instanceof Error ? error.message : "Failed to delete project",
        error,
      );
    }
  }

  // ============================================================================
  // TASKS (Hierarchical)
  // ============================================================================

  async createTask(userId: string, data: CreateTaskDTO): Promise<DbResult<TaskDTO>> {
    try {
      const db = await getDb();
      const [task] = await db
        .insert(tasks)
        .values({
          ...data,
          userId,
          projectId: data.projectId || null,
          parentTaskId: data.parentTaskId || null,
          dueDate: data.dueDate ? new Date(data.dueDate) : null,
          details: data.details || {},
        })
        .returning();
      if (!task) {
        return dbError("DB_INSERT_FAILED", "Failed to create task - no data returned");
      }
      return ok(this.mapTaskToDTO(task));
    } catch (error) {
      return dbError(
        "DB_INSERT_FAILED",
        error instanceof Error ? error.message : "Failed to create task",
        error,
      );
    }
  }

  async getTasks(userId: string, filters: TaskFilters = {}): Promise<DbResult<TaskDTO[]>> {
    try {
      const db = await getDb();
      const whereConditions = [eq(tasks.userId, userId)];

      if (filters.projectId) {
        whereConditions.push(eq(tasks.projectId, filters.projectId));
      }

      if (filters.parentTaskId !== undefined) {
        if (filters.parentTaskId === null) {
          whereConditions.push(isNull(tasks.parentTaskId));
        } else {
          whereConditions.push(eq(tasks.parentTaskId, filters.parentTaskId));
        }
      }

      if (filters.status && filters.status.length > 0) {
        const validStatuses = filters.status.filter(
          (status): status is "todo" | "in_progress" | "done" | "canceled" =>
            ["todo", "in_progress", "done", "canceled"].includes(status),
        );
        if (validStatuses.length > 0) {
          whereConditions.push(inArray(tasks.status, validStatuses));
        }
      }

      if (filters.priority && filters.priority.length > 0) {
        const validPriorities = filters.priority.filter(
          (priority): priority is "low" | "medium" | "high" | "urgent" =>
            ["low", "medium", "high", "urgent"].includes(priority),
        );
        if (validPriorities.length > 0) {
          whereConditions.push(inArray(tasks.priority, validPriorities));
        }
      }

      const tasksData = await db
        .select()
        .from(tasks)
        .where(and(...whereConditions))
        .orderBy(desc(tasks.updatedAt));

      return ok(tasksData.map((t) => this.mapTaskToDTO(t)));
    } catch (error) {
      return dbError(
        "DB_QUERY_FAILED",
        error instanceof Error ? error.message : "Failed to get tasks",
        error,
      );
    }
  }

  async getTask(taskId: string, userId: string): Promise<TaskDTO | null> {
    const db = await getDb();
    const [task] = await db
      .select()
      .from(tasks)
      .where(and(eq(tasks.id, taskId), eq(tasks.userId, userId)));
    return task ? this.mapTaskToDTO(task) : null;
  }

  async getTasksWithProject(userId: string, projectId: string): Promise<TaskDTO[]> {
    const db = await getDb();
    const tasksData = await db
      .select()
      .from(tasks)
      .where(and(eq(tasks.userId, userId), eq(tasks.projectId, projectId)))
      .orderBy(desc(tasks.updatedAt));

    return tasksData.map((t) => this.mapTaskToDTO(t));
  }

  async getSubtasks(parentTaskId: string, userId: string): Promise<TaskDTO[]> {
    const db = await getDb();
    const tasksData = await db
      .select()
      .from(tasks)
      .where(and(eq(tasks.userId, userId), eq(tasks.parentTaskId, parentTaskId)))
      .orderBy(asc(tasks.createdAt));

    return tasksData.map((t) => this.mapTaskToDTO(t));
  }

  async updateTask(taskId: string, userId: string, data: UpdateTaskDTO): Promise<void> {
    const db = await getDb();
    // Filter out undefined values for exact optional property types
    const updateData = Object.fromEntries(
      Object.entries(data).filter(([, value]) => value !== undefined),
    );

    await db
      .update(tasks)
      .set({ ...updateData, updatedAt: new Date() })
      .where(and(eq(tasks.id, taskId), eq(tasks.userId, userId)));
  }

  async deleteTask(taskId: string, userId: string): Promise<void> {
    const db = await getDb();
    // Delete task and its contact tags
    await db.delete(taskContactTags).where(eq(taskContactTags.taskId, taskId));
    await db.delete(tasks).where(and(eq(tasks.id, taskId), eq(tasks.userId, userId)));
  }

  // ============================================================================
  // TASK CONTACT TAGS (Many-to-Many)
  // ============================================================================

  async addTaskContactTags(taskId: string, contactIds: string[]): Promise<void> {
    if (contactIds.length === 0) return;

    const db = await getDb();
    const tagData = contactIds.map((contactId) => ({
      taskId,
      contactId,
    }));

    await db.insert(taskContactTags).values(tagData).onConflictDoNothing();
  }

  async removeTaskContactTags(taskId: string, contactIds?: string[]): Promise<void> {
    const db = await getDb();

    if (contactIds && contactIds.length > 0) {
      // Remove specific contact tags
      await db
        .delete(taskContactTags)
        .where(
          and(eq(taskContactTags.taskId, taskId), inArray(taskContactTags.contactId, contactIds)),
        );
    } else {
      // Remove all contact tags for this task
      await db.delete(taskContactTags).where(eq(taskContactTags.taskId, taskId));
    }
  }

  async getTaskContactTags(taskId: string): Promise<Array<{ taskId: string; contactId: string }>> {
    const db = await getDb();
    return await db.select().from(taskContactTags).where(eq(taskContactTags.taskId, taskId));
  }

  // ============================================================================
  // GOALS
  // ============================================================================

  async createGoal(userId: string, data: CreateGoalDTO): Promise<GoalDTO> {
    const db = await getDb();
    const [goal] = await db
      .insert(goals)
      .values({
        ...data,
        userId,
        contactId: data.contactId ?? null,
        targetDate: data.targetDate ?? null,
        details: data.details ?? {},
      })
      .returning();
    if (!goal) throw new Error("Failed to create goal");
    return this.mapGoalToDTO(goal);
  }

  async getGoals(userId: string, filters: GoalFilters = {}): Promise<GoalDTO[]> {
    const db = await getDb();
    const whereConditions = [eq(goals.userId, userId)];

    if (filters.contactId) {
      whereConditions.push(eq(goals.contactId, filters.contactId));
    }

    if (filters.goalType && filters.goalType.length > 0) {
      const validGoalTypes = filters.goalType.filter(
        (type): type is "practitioner_business" | "practitioner_personal" | "client_wellness" =>
          ["practitioner_business", "practitioner_personal", "client_wellness"].includes(type),
      );
      if (validGoalTypes.length > 0) {
        whereConditions.push(inArray(goals.goalType, validGoalTypes));
      }
    }

    if (filters.status && filters.status.length > 0) {
      const validStatuses = filters.status.filter(
        (status): status is "on_track" | "at_risk" | "achieved" | "abandoned" =>
          ["on_track", "at_risk", "achieved", "abandoned"].includes(status),
      );
      if (validStatuses.length > 0) {
        whereConditions.push(inArray(goals.status, validStatuses));
      }
    }

    const goalsData = await db
      .select()
      .from(goals)
      .where(and(...whereConditions))
      .orderBy(desc(goals.updatedAt));

    return goalsData.map((g) => this.mapGoalToDTO(g));
  }

  async getGoal(goalId: string, userId: string): Promise<GoalDTO | null> {
    const db = await getDb();
    const [goal] = await db
      .select()
      .from(goals)
      .where(and(eq(goals.id, goalId), eq(goals.userId, userId)));
    return goal ? this.mapGoalToDTO(goal) : null;
  }

  async updateGoal(goalId: string, userId: string, data: UpdateGoalDTO): Promise<void> {
    const db = await getDb();
    // Filter out undefined values for exact optional property types
    const updateData = Object.fromEntries(
      Object.entries(data).filter(([, value]) => value !== undefined),
    );

    await db
      .update(goals)
      .set({ ...updateData, updatedAt: new Date() })
      .where(and(eq(goals.id, goalId), eq(goals.userId, userId)));
  }

  async deleteGoal(goalId: string, userId: string): Promise<void> {
    const db = await getDb();
    await db.delete(goals).where(and(eq(goals.id, goalId), eq(goals.userId, userId)));
  }

  // ============================================================================
  // DAILY PULSE LOGS
  // ============================================================================

  async createDailyPulseLog(
    userId: string,
    data: CreateDailyPulseLogDTO,
  ): Promise<DailyPulseLogDTO> {
    const db = await getDb();
    const logDate = data.logDate || new Date();
    const isoString = typeof logDate === "string" ? logDate : logDate.toISOString();
    const logDateString = isoString.split("T")[0]; // Convert to YYYY-MM-DD format
    if (!logDateString) {
      throw new Error("Failed to format log date");
    }

    const [log] = await db
      .insert(dailyPulseLogs)
      .values({
        userId,
        logDate: logDateString,
        details: data.details ?? {},
      })
      .returning();
    if (!log) throw new Error("Failed to create daily pulse log");
    return this.mapDailyPulseLogToDTO(log);
  }

  async getDailyPulseLogs(userId: string, limit = 30): Promise<DailyPulseLogDTO[]> {
    const db = await getDb();
    const logsData = await db
      .select()
      .from(dailyPulseLogs)
      .where(eq(dailyPulseLogs.userId, userId))
      .orderBy(desc(dailyPulseLogs.logDate))
      .limit(limit);

    return logsData.map((l) => this.mapDailyPulseLogToDTO(l));
  }

  async getDailyPulseLog(userId: string, logDate: Date): Promise<DailyPulseLogDTO | null> {
    const db = await getDb();
    const isoString = logDate.toISOString();
    const dateString = isoString.split("T")[0]; // Convert to YYYY-MM-DD format
    if (!dateString) {
      throw new Error("Failed to format log date");
    }
    const [log] = await db
      .select()
      .from(dailyPulseLogs)
      .where(and(eq(dailyPulseLogs.userId, userId), eq(dailyPulseLogs.logDate, dateString)));
    return log ? this.mapDailyPulseLogToDTO(log) : null;
  }

  async updateDailyPulseLog(
    logId: string,
    userId: string,
    data: UpdateDailyPulseLogDTO,
  ): Promise<void> {
    const db = await getDb();
    // Filter out undefined values for exact optional property types
    const updateData = Object.fromEntries(
      Object.entries(data).filter(([, value]) => value !== undefined),
    );

    await db
      .update(dailyPulseLogs)
      .set(updateData)
      .where(and(eq(dailyPulseLogs.id, logId), eq(dailyPulseLogs.userId, userId)));
  }

  // ============================================================================
  // ZONES (Lookup)
  // ============================================================================

  async getZones(): Promise<
    Array<{ id: number; name: string; color: string | null; iconName: string | null }>
  > {
    const db = await getDb();
    return await db.select().from(zones).orderBy(asc(zones.name));
  }

  // ============================================================================
  // INBOX ITEMS (AI Quick Capture)
  // ============================================================================

  async createInboxItem(
    userId: string,
    data: { rawText: string; status?: "unprocessed" | "processed" | "archived" },
  ): Promise<InboxItem> {
    const db = await getDb();
    const [item] = await db
      .insert(inboxItems)
      .values({
        userId,
        rawText: data.rawText,
        status: data.status || "unprocessed",
      })
      .returning();
    if (!item) throw new Error("Failed to create inbox item");
    return this.mapInboxItemToDTO(item);
  }

  async getInboxItems(userId: string, status?: string): Promise<InboxItem[]> {
    const db = await getDb();
    const whereConditions = [eq(inboxItems.userId, userId)];

    if (status) {
      const validStatus = ["unprocessed", "processed", "archived"].includes(status);
      if (validStatus) {
        whereConditions.push(
          eq(inboxItems.status, status as "unprocessed" | "processed" | "archived"),
        );
      }
    }

    const itemsData = await db
      .select()
      .from(inboxItems)
      .where(and(...whereConditions))
      .orderBy(desc(inboxItems.createdAt));

    return itemsData.map((item) => this.mapInboxItemToDTO(item));
  }

  async updateInboxItem(
    itemId: string,
    userId: string,
    data: {
      rawText?: string;
      status?: "unprocessed" | "processed" | "archived";
      createdTaskId?: string;
      processedAt?: Date;
    },
  ): Promise<void> {
    const db = await getDb();
    // Filter out undefined values for exact optional property types
    const updateData = Object.fromEntries(
      Object.entries(data).filter(([, value]) => value !== undefined),
    );

    await db
      .update(inboxItems)
      .set({ ...updateData, updatedAt: new Date() })
      .where(and(eq(inboxItems.id, itemId), eq(inboxItems.userId, userId)));
  }

  // ============================================================================
  // STATISTICS & ANALYTICS
  // ============================================================================

  async getTaskStats(userId: string): Promise<{
    total: number;
    todo: number;
    inProgress: number;
    completed: number;
    cancelled: number;
  }> {
    const db = await getDb();
    const allTasks = await db
      .select({ status: tasks.status })
      .from(tasks)
      .where(eq(tasks.userId, userId));

    const stats = {
      total: allTasks.length,
      todo: allTasks.filter((t) => t.status === "todo").length,
      inProgress: allTasks.filter((t) => t.status === "in_progress").length,
      completed: allTasks.filter((t) => t.status === "done").length,
      cancelled: allTasks.filter((t) => t.status === "canceled").length,
    };

    return stats;
  }

  async getProjectStats(userId: string): Promise<{
    total: number;
    active: number;
    onHold: number;
    completed: number;
    archived: number;
  }> {
    const db = await getDb();
    const allProjects = await db
      .select({ status: projects.status })
      .from(projects)
      .where(eq(projects.userId, userId));

    const stats = {
      total: allProjects.length,
      active: allProjects.filter((p) => p.status === "active").length,
      onHold: allProjects.filter((p) => p.status === "on_hold").length,
      completed: allProjects.filter((p) => p.status === "completed").length,
      archived: allProjects.filter((p) => p.status === "archived").length,
    };

    return stats;
  }

  // ============================================================================
  // COMPLEX QUERIES WITH RELATIONS
  // ============================================================================

  async getTaskWithRelations(
    taskId: string,
    userId: string,
  ): Promise<{
    task: TaskDTO;
    project: ProjectDTO | null;
    parentTask: TaskDTO | null;
    subtasks: TaskDTO[];
    taggedContacts: Array<{ id: string; displayName: string; primaryEmail?: string }>;
    zone: { id: number; name: string; color: string | null; iconName: string | null } | null;
  } | null> {
    const db = await getDb();

    // Get main task
    const task = await this.getTask(taskId, userId);
    if (!task) return null;

    // Get related data in parallel
    const [project, parentTask, subtasks, taggedContactsData] = await Promise.all([
      task.projectId ? this.getProject(task.projectId, userId) : null,
      task.parentTaskId ? this.getTask(task.parentTaskId, userId) : null,
      this.getSubtasks(taskId, userId),
      // Get tagged contacts
      db
        .select({
          id: contacts.id,
          displayName: contacts.displayName,
          primaryEmail: contacts.primaryEmail,
        })
        .from(taskContactTags)
        .innerJoin(contacts, eq(taskContactTags.contactId, contacts.id))
        .where(eq(taskContactTags.taskId, taskId))
        .then((results) =>
          results.map((result) => {
            const contact: { id: string; displayName: string; primaryEmail?: string } = {
              id: result.id,
              displayName: result.displayName,
            };
            if (result.primaryEmail) {
              contact.primaryEmail = result.primaryEmail;
            }
            return contact;
          }),
        ),
    ]);

    // Get zone if project has one
    let zone: { id: number; name: string; color: string | null; iconName: string | null } | null =
      null;
    if (project && "success" in project && project.success && project.data?.zoneId) {
      const [zoneData] = await db.select().from(zones).where(eq(zones.id, project.data.zoneId));
      zone = zoneData ?? null;
    }

    return {
      task,
      project: project && "success" in project && project.success ? project.data : null,
      parentTask,
      subtasks,
      taggedContacts: taggedContactsData,
      zone,
    };
  }

  // ============================================================================
  // PRIVATE MAPPER METHODS
  // ============================================================================

  private mapProjectToDTO(project: typeof projects.$inferSelect): ProjectDTO {
    return {
      id: project.id,
      userId: project.userId,
      zoneId: project.zoneId,
      name: project.name,
      status: project.status as "active" | "on_hold" | "completed" | "archived",
      dueDate: project.dueDate,
      details: project.details as Record<string, unknown>,
      createdAt: project.createdAt,
      updatedAt: project.updatedAt,
    };
  }

  private mapTaskToDTO(task: typeof tasks.$inferSelect): TaskDTO {
    return {
      id: task.id,
      userId: task.userId,
      projectId: task.projectId,
      parentTaskId: task.parentTaskId,
      name: task.name,
      status: task.status as "todo" | "in_progress" | "done" | "canceled",
      priority: task.priority as "low" | "medium" | "high" | "urgent",
      dueDate: task.dueDate,
      details: task.details as Record<string, unknown>,
      completedAt: task.completedAt,
      createdAt: task.createdAt,
      updatedAt: task.updatedAt,
    };
  }

  private mapGoalToDTO(goal: typeof goals.$inferSelect): GoalDTO {
    return {
      id: goal.id,
      userId: goal.userId,
      contactId: goal.contactId,
      goalType: goal.goalType as
        | "practitioner_business"
        | "practitioner_personal"
        | "client_wellness",
      name: goal.name,
      status: goal.status as "on_track" | "at_risk" | "achieved" | "abandoned",
      targetDate: goal.targetDate,
      details: goal.details as Record<string, unknown>,
      createdAt: goal.createdAt,
      updatedAt: goal.updatedAt,
    };
  }

  private mapDailyPulseLogToDTO(log: typeof dailyPulseLogs.$inferSelect): DailyPulseLogDTO {
    return {
      id: log.id,
      userId: log.userId,
      logDate: log.logDate,
      details: log.details as Record<string, unknown>,
      createdAt: log.createdAt,
    };
  }

  private mapInboxItemToDTO(item: typeof inboxItems.$inferSelect): InboxItem {
    return {
      id: item.id,
      userId: item.userId,
      rawText: item.rawText,
      status: item.status as "unprocessed" | "processed" | "archived",
      createdTaskId: item.createdTaskId,
      processedAt: item.processedAt,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
    };
  }
}

export const momentumRepository = new MomentumRepository();



===== packages/repo/src/notes.repo.ts =====
import { eq, and, desc, ilike } from "drizzle-orm";
import { Note, notes } from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import { ok, err, DbResult } from "@/lib/utils/result";
import { z } from "zod";
import { redactPII } from "@/server/lib/pii-detector";

export class NotesRepository {
  /**
   * List notes for a user with optional contact filtering
   */
  static async listNotes(userId: string, contactId?: string): Promise<DbResult<Note[]>> {
    try {
      const db = await getDb();

      // Build conditions array
      const conditions = [eq(notes.userId, userId)];

      if (contactId) {
        conditions.push(eq(notes.contactId, contactId));
      }

      const rows = await db
        .select()
        .from(notes)
        .where(and(...conditions))
        .orderBy(desc(notes.createdAt));

      return ok(rows);
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to list notes",
        details: error,
      });
    }
  }

  /**
   * Get a single note by ID
   */
  static async getNoteById(userId: string, noteId: string): Promise<DbResult<Note | null>> {
    try {
      const db = await getDb();

      const rows = await db
        .select()
        .from(notes)
        .where(and(eq(notes.userId, userId), eq(notes.id, noteId)))
        .limit(1);

      return ok(rows[0] || null);
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to get note by ID",
        details: error,
      });
    }
  }

  /**
   * Get notes for a specific contact
   */
  static async getNotesByContactId(userId: string, contactId: string): Promise<DbResult<Note[]>> {
    try {
      const db = await getDb();

      const rows = await db
        .select()
        .from(notes)
        .where(and(eq(notes.userId, userId), eq(notes.contactId, contactId)))
        .orderBy(desc(notes.createdAt));

      return ok(rows);
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to get notes by contact ID",
        details: error,
      });
    }
  }

  /**
   * Search notes by content
   */
  static async searchNotes(userId: string, searchTerm: string): Promise<DbResult<Note[]>> {
    try {
      const db = await getDb();

      const rows = await db
        .select()
        .from(notes)
        .where(and(eq(notes.userId, userId), ilike(notes.contentPlain, `%${searchTerm}%`)))
        .orderBy(desc(notes.createdAt));

      return ok(rows);
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to search notes",
        details: error,
      });
    }
  }

  /**
   * Create a new note
   */
  static async createNote(userId: string, input: unknown): Promise<DbResult<Note>> {
    try {
      const db = await getDb();

      // Validate input data
      const createNoteSchema = z.object({
        contentPlain: z.string(),
        contentRich: z.record(z.string(), z.unknown()).optional().default({}),
        contactId: z.string().uuid().optional(),
        tags: z.array(z.string()).optional().default([]),
        piiEntities: z.array(z.unknown()).optional().default([]),
        sourceType: z.enum(["typed", "voice", "upload"]).optional().default("typed"),
      });

      const parseResult = createNoteSchema.safeParse(input);

      if (!parseResult.success) {
        return err({
          code: "VALIDATION_ERROR",
          message: `Invalid note data: ${parseResult.error.issues.map((i) => i.message).join(", ")}`,
        });
      }

      const data = parseResult.data;

      // Redact PII from content
      const redactionResult = redactPII(data.contentPlain);

      const [newNote] = await db
        .insert(notes)
        .values({
          userId,
          contactId: data.contactId ?? null,
          contentPlain: redactionResult.sanitizedText,
          contentRich: data.contentRich,
          tags: data.tags,
          piiEntities: redactionResult.entities,
          sourceType: data.sourceType,
        })
        .returning();

      if (!newNote) {
        return err({
          code: "DB_INSERT_FAILED",
          message: "Failed to create note - no data returned",
        });
      }

      return ok(newNote);
    } catch (error) {
      return err({
        code: "DB_INSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to create note",
        details: error,
      });
    }
  }

  /**
   * Update an existing note
   */
  static async updateNote(
    userId: string,
    noteId: string,
    input: unknown,
  ): Promise<DbResult<Note | null>> {
    try {
      const db = await getDb();

      // Validate input data
      const updateNoteSchema = z.object({
        contentPlain: z.string().optional(),
        contentRich: z.record(z.string(), z.unknown()).optional(),
        tags: z.array(z.string()).optional(),
        piiEntities: z.array(z.unknown()).optional(),
      });

      const parseResult = updateNoteSchema.safeParse(input);

      if (!parseResult.success) {
        return err({
          code: "VALIDATION_ERROR",
          message: `Invalid update data: ${parseResult.error.issues.map((i) => i.message).join(", ")}`,
        });
      }

      const data = parseResult.data;

      // Build update object with only defined fields
      const updateValues: Record<string, unknown> = {
        updatedAt: new Date(),
      };

      // Redact PII if contentPlain is being updated
      if (data.contentPlain !== undefined) {
        const redactionResult = redactPII(data.contentPlain);
        updateValues["contentPlain"] = redactionResult.sanitizedText;
        updateValues["piiEntities"] = redactionResult.entities;
      }

      if (data.contentRich !== undefined) updateValues["contentRich"] = data.contentRich;
      if (data.tags !== undefined) updateValues["tags"] = data.tags;

      const [updatedNote] = await db
        .update(notes)
        .set(updateValues)
        .where(and(eq(notes.userId, userId), eq(notes.id, noteId)))
        .returning();

      return ok(updatedNote || null);
    } catch (error) {
      return err({
        code: "DB_UPDATE_FAILED",
        message: error instanceof Error ? error.message : "Failed to update note",
        details: error,
      });
    }
  }

  /**
   * Delete a note
   */
  static async deleteNote(userId: string, noteId: string): Promise<DbResult<boolean>> {
    try {
      const db = await getDb();

      const result = await db
        .delete(notes)
        .where(and(eq(notes.userId, userId), eq(notes.id, noteId)))
        .returning({ id: notes.id });

      return ok(result.length > 0);
    } catch (error) {
      return err({
        code: "DB_DELETE_FAILED",
        message: error instanceof Error ? error.message : "Failed to delete note",
        details: error,
      });
    }
  }
}



===== packages/repo/src/onboarding.repo.ts =====
import { eq, and, gt, sql } from "drizzle-orm";
import { onboardingTokens, contacts, clientConsents, type CreateContact } from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import { ok, err, DbResult, dbError } from "@/lib/utils/result";

export type OnboardingToken = typeof onboardingTokens.$inferSelect;
export type CreateOnboardingToken = typeof onboardingTokens.$inferInsert;

export interface ClientData {
  display_name: string;
  primary_email: string;
  primary_phone?: string | null;
  date_of_birth?: string | null;
  emergency_contact_name?: string | null;
  emergency_contact_phone?: string | null;
  referral_source?: string | null;
  address?: Record<string, unknown> | null;
  health_context?: Record<string, unknown> | null;
  preferences?: Record<string, unknown> | null;
}

export interface ConsentData {
  consent_type: "data_processing" | "marketing" | "hipaa" | "photography";
  consent_text_version: string;
  granted: boolean;
  signature_svg?: string;
  signature_image_url?: string;
  ip_address: string;
  user_agent: string;
}

export interface TokenValidationResult {
  isValid: boolean;
  token?: OnboardingToken;
  error?: string;
}

export class OnboardingRepository {
  /**
   * Create a new onboarding token
   */
  static async createToken(
    userId: string,
    expiresAt: Date,
    label?: string,
    maxUses: number = 1,
  ): Promise<DbResult<OnboardingToken>> {
    try {
      const db = await getDb();

      // Generate a secure token
      const token = crypto.randomUUID() + "-" + Date.now().toString(36);

      const tokenData: CreateOnboardingToken = {
        userId,
        token,
        expiresAt: expiresAt,
        maxUses,
        label,
        createdBy: userId,
      };

      const [createdToken] = await db.insert(onboardingTokens).values(tokenData).returning();

      if (!createdToken) {
        return dbError("DB_INSERT_FAILED", "Failed to create onboarding token");
      }

      return ok(createdToken);
    } catch (error) {
      console.error("Error creating onboarding token:", error);
      return dbError(
        "DB_QUERY_FAILED",
        error instanceof Error ? error.message : "Failed to create onboarding token",
        error,
      );
    }
  }

  /**
   * Get active tokens for a user
   */
  static async getActiveTokens(userId: string): Promise<DbResult<OnboardingToken[]>> {
    try {
      const db = await getDb();
      const now = new Date();

      const tokens = await db
        .select()
        .from(onboardingTokens)
        .where(
          and(
            eq(onboardingTokens.userId, userId),
            eq(onboardingTokens.disabled, false),
            gt(onboardingTokens.expiresAt, now),
          ),
        );

      return ok(tokens);
    } catch (error) {
      console.error("Error getting active tokens:", error);
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to get active tokens",
        details: error,
      });
    }
  }

  /**
   * Validate a token and check if it can be used
   */
  static async validateToken(tokenValue: string): Promise<DbResult<TokenValidationResult>> {
    try {
      const db = await getDb();
      const now = new Date();

      const [token] = await db
        .select()
        .from(onboardingTokens)
        .where(eq(onboardingTokens.token, tokenValue));

      if (!token) {
        return ok({ isValid: false, error: "Token not found" });
      }

      if (token.disabled) {
        return ok({ isValid: false, error: "Token is disabled" });
      }

      if (token.expiresAt < now) {
        return ok({ isValid: false, error: "Token has expired" });
      }

      if (token.maxUses !== null && token.usedCount !== null && token.usedCount >= token.maxUses) {
        return ok({ isValid: false, error: "Token usage limit exceeded" });
      }

      return ok({ isValid: true, token });
    } catch (error) {
      console.error("Error validating token:", error);
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to validate token",
        details: error,
      });
    }
  }

  /**
   * Increment token usage count
   */
  static async incrementTokenUsage(tokenValue: string): Promise<DbResult<void>> {
    try {
      const db = await getDb();

      await db
        .update(onboardingTokens)
        .set({
          usedCount: sql`coalesce(${onboardingTokens.usedCount}, 0) + 1`,
        })
        .where(eq(onboardingTokens.token, tokenValue));

      return ok(undefined);
    } catch (error) {
      console.error("Error incrementing token usage:", error);
      return err({
        code: "DB_UPDATE_FAILED",
        message: error instanceof Error ? error.message : "Failed to increment token usage",
        details: error,
      });
    }
  }

  /**
   * Update token last accessed timestamp (if that field exists)
   */
  static async updateTokenAccess(_tokenValue: string): Promise<DbResult<void>> {
    try {
      // Note: The schema doesn't show last_accessed_at field, but the service references it
      // If this field exists in the database but not in the schema, it should be added to schema
      // For now, this is a no-op that succeeds
      return ok(undefined);
    } catch (error) {
      console.error("Error updating token access:", error);
      return err({
        code: "DB_UPDATE_FAILED",
        message: error instanceof Error ? error.message : "Failed to update token access",
        details: error,
      });
    }
  }

  /**
   * Disable a token
   */
  static async disableToken(tokenId: string, userId: string): Promise<DbResult<void>> {
    try {
      const db = await getDb();

      await db
        .update(onboardingTokens)
        .set({ disabled: true })
        .where(and(eq(onboardingTokens.id, tokenId), eq(onboardingTokens.userId, userId)));

      return ok(undefined);
    } catch (error) {
      console.error("Error disabling token:", error);
      return err({
        code: "DB_UPDATE_FAILED",
        message: error instanceof Error ? error.message : "Failed to disable token",
        details: error,
      });
    }
  }

  /**
   * Create contact and consent record within a transaction
   * This replaces the RPC call pattern
   */
  static async createContactWithConsent(
    userId: string,
    tokenValue: string,
    clientData: ClientData,
    consentData: ConsentData,
    photoPath?: string,
    photoSize?: number,
  ): Promise<DbResult<string>> {
    try {
      const db = await getDb();

      // Validate token first
      const tokenResult = await this.validateToken(tokenValue);
      if (!tokenResult.success) {
        return err(tokenResult.error);
      }

      const validation = tokenResult.data;
      if (!validation.isValid) {
        return err({
          code: "INVALID_TOKEN",
          message: validation.error || "Invalid token",
          details: validation,
        });
      }

      // Wrap all operations in a transaction
      const result = await db.transaction(async (trx) => {
        // Create contact without photoUrl initially
        const contactData: CreateContact = {
          userId,
          displayName: clientData.display_name,
          primaryEmail: clientData.primary_email,
          primaryPhone: clientData.primary_phone,
          dateOfBirth: clientData.date_of_birth,
          emergencyContactName: clientData.emergency_contact_name,
          emergencyContactPhone: clientData.emergency_contact_phone,
          referralSource: clientData.referral_source,
          address: clientData.address,
          healthContext: clientData.health_context,
          preferences: clientData.preferences,
          source: "onboarding",
          photoUrl: null, // Will be set after creating client_files record
        };

        const [contact] = await trx.insert(contacts).values(contactData).returning();

        if (!contact) {
          throw new Error("CONTACT_CREATION_FAILED");
        }

        // If there's a photo, create client_files record and update contact
        if (photoPath) {
          const { clientFiles } = await import("@/server/db/schema");

          // Create client_files record
          await trx.insert(clientFiles).values({
            contactId: contact.id,
            userId,
            filePath: photoPath,
            mimeType: "image/webp", // Photos are optimized to webp
            fileSize: photoSize ?? null, // Optimized file size from upload
            fileType: "photo",
          });

          // Update contact with photo URL (using the file path as the URL)
          await trx
            .update(contacts)
            .set({ photoUrl: photoPath })
            .where(eq(contacts.id, contact.id));
        }

        // Create consent record
        await trx.insert(clientConsents).values({
          contactId: contact.id,
          userId,
          consentType: consentData.consent_type,
          consentTextVersion: consentData.consent_text_version,
          granted: consentData.granted,
          signatureSvg: consentData.signature_svg || null,
          signatureImageUrl: consentData.signature_image_url || null,
          ipAddress: consentData.ip_address,
          userAgent: consentData.user_agent,
        });

        // Increment token usage within the same transaction
        await trx
          .update(onboardingTokens)
          .set({
            usedCount: sql`coalesce(${onboardingTokens.usedCount}, 0) + 1`,
          })
          .where(eq(onboardingTokens.token, tokenValue));

        return contact.id;
      });

      return ok(result);
    } catch (error) {
      console.error("Error creating contact with consent:", error);
      return err({
        code: "DB_TRANSACTION_FAILED",
        message: error instanceof Error ? error.message : "Failed to create contact with consent",
        details: error,
      });
    }
  }
}



===== packages/repo/src/raw-events.repo.ts =====
import { eq, and, desc, asc, gte, lte, inArray, count, sql, type SQL } from "drizzle-orm";
import { getDb } from "@/server/db/client";
import {
  RawEvent,
  CreateRawEvent,
  RawEventError,
  CreateRawEventError,
  rawEvents,
  rawEventErrors,
} from "@/server/db/schema";
import { ok, err, DbResult } from "@/lib/utils/result";

// Local type aliases for repository layer
type RawEventDTO = RawEvent;
type CreateRawEventDTO = CreateRawEvent;
type RawEventErrorDTO = RawEventError;
type CreateRawEventErrorDTO = CreateRawEventError;

interface RawEventFilters {
  provider?: string[];
  contactId?: string;
  batchId?: string;
  sourceId?: string;
  occurredAfter?: Date;
  occurredBefore?: Date;
}

export type RawEventListParams = {
  provider?: string; // e.g. 'gmail'
  sort?: "occurredAt" | "createdAt";
  order?: "asc" | "desc";
  page: number;
  pageSize: number;
  dateRange?: { from?: Date; to?: Date }; // applied to occurredAt
};

export type RawEventListItem = {
  id: string;
  userId: string;
  provider: string;
  payload: unknown;
  contactId: string | null;
  occurredAt: Date;
  sourceMeta: unknown | null;
  batchId: string | null;
  sourceId: string | null;
  createdAt: Date | null;
};

export class RawEventsRepository {
  /**
   * Create a new raw event
   */
  static async createRawEvent(
    data: CreateRawEventDTO & { userId: string },
  ): Promise<DbResult<RawEventDTO>> {
    try {
      const db = await getDb();

      const insertValues = {
        userId: data.userId,
        provider: data.provider,
        payload: data.payload,
        contactId: data.contactId ?? null,
        occurredAt: data.occurredAt,
        sourceMeta: data.sourceMeta ?? null,
        batchId: data.batchId ?? null,
        sourceId: data.sourceId ?? null,
      };

      const [newRawEvent] = await db.insert(rawEvents).values(insertValues).returning({
        id: rawEvents.id,
        userId: rawEvents.userId,
        provider: rawEvents.provider,
        payload: rawEvents.payload,
        contactId: rawEvents.contactId,
        occurredAt: rawEvents.occurredAt,
        sourceMeta: rawEvents.sourceMeta,
        batchId: rawEvents.batchId,
        sourceId: rawEvents.sourceId,
        createdAt: rawEvents.createdAt,
      });

      if (!newRawEvent) {
        return err({
          code: "DB_INSERT_FAILED",
          message: "Failed to create raw event - no data returned",
        });
      }

      return ok(newRawEvent);
    } catch (error) {
      return err({
        code: "DB_INSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to create raw event",
        details: error,
      });
    }
  }

  /**
   * Bulk create raw events for batch ingestion
   */
  static async createBulkRawEvents(
    events: Array<CreateRawEventDTO & { userId: string }>,
  ): Promise<RawEventDTO[]> {
    if (events.length === 0) {
      return [];
    }

    const db = await getDb();

    const insertValues = events.map((event) => ({
      userId: event.userId,
      provider: event.provider,
      payload: event.payload,
      contactId: event.contactId ?? null,
      occurredAt: event.occurredAt,
      sourceMeta: event.sourceMeta ?? null,
      batchId: event.batchId ?? null,
      sourceId: event.sourceId ?? null,
    }));

    const newRawEvents = await db.insert(rawEvents).values(insertValues).returning({
      id: rawEvents.id,
      userId: rawEvents.userId,
      provider: rawEvents.provider,
      payload: rawEvents.payload,
      contactId: rawEvents.contactId,
      occurredAt: rawEvents.occurredAt,
      sourceMeta: rawEvents.sourceMeta,
      batchId: rawEvents.batchId,
      sourceId: rawEvents.sourceId,
      createdAt: rawEvents.createdAt,
    });

    return newRawEvents.map((event) => event);
  }

  /**
   * Get raw events for a user with optional filtering
   */
  static async listRawEvents(
    userId: string,
    filters?: RawEventFilters,
    limit: number = 100,
  ): Promise<RawEventDTO[]> {
    const db = await getDb();

    const conditions = [eq(rawEvents.userId, userId)];

    if (filters?.provider && filters.provider.length > 0) {
      conditions.push(inArray(rawEvents.provider, filters.provider));
    }

    if (filters?.contactId) {
      conditions.push(eq(rawEvents.contactId, filters.contactId));
    }

    if (filters?.batchId) {
      conditions.push(eq(rawEvents.batchId, filters.batchId));
    }

    if (filters?.sourceId) {
      conditions.push(eq(rawEvents.sourceId, filters.sourceId));
    }

    if (filters?.occurredAfter) {
      conditions.push(gte(rawEvents.occurredAt, filters.occurredAfter));
    }

    if (filters?.occurredBefore) {
      conditions.push(lte(rawEvents.occurredAt, filters.occurredBefore));
    }

    const rows = await db
      .select({
        id: rawEvents.id,
        userId: rawEvents.userId,
        provider: rawEvents.provider,
        payload: rawEvents.payload,
        contactId: rawEvents.contactId,
        occurredAt: rawEvents.occurredAt,
        sourceMeta: rawEvents.sourceMeta,
        batchId: rawEvents.batchId,
        sourceId: rawEvents.sourceId,
        createdAt: rawEvents.createdAt,
      })
      .from(rawEvents)
      .where(and(...conditions))
      .orderBy(desc(rawEvents.occurredAt))
      .limit(limit);

    return rows.map((row) => row);
  }

  /**
   * List raw events with pagination and advanced filtering (matches server version API)
   */
  static async listRawEventsPaginated(
    userId: string,
    params: RawEventListParams,
  ): Promise<DbResult<{ items: RawEventListItem[]; total: number }>> {
    try {
      const db = await getDb();

      let whereExpr: SQL<unknown> = eq(rawEvents.userId, userId);
      if (params.provider) {
        whereExpr = and(whereExpr, eq(rawEvents.provider, params.provider)) as SQL<unknown>;
      }
      if (params.dateRange?.from)
        whereExpr = and(
          whereExpr,
          gte(rawEvents.occurredAt, params.dateRange.from as Date),
        ) as SQL<unknown>;
      if (params.dateRange?.to)
        whereExpr = and(
          whereExpr,
          lte(rawEvents.occurredAt, params.dateRange.to as Date),
        ) as SQL<unknown>;

      const sortKey = params.sort ?? "occurredAt";
      const sortDir = params.order === "desc" ? "desc" : "asc";
      const orderExpr =
        sortKey === "createdAt"
          ? sortDir === "desc"
            ? desc(rawEvents.createdAt)
            : asc(rawEvents.createdAt)
          : sortDir === "desc"
            ? desc(rawEvents.occurredAt)
            : asc(rawEvents.occurredAt);

      const page = params.page;
      const pageSize = params.pageSize;

      const [items, totalRow] = await Promise.all([
        db
          .select({
            id: rawEvents.id,
            userId: rawEvents.userId,
            provider: rawEvents.provider,
            payload: rawEvents.payload,
            contactId: rawEvents.contactId,
            occurredAt: rawEvents.occurredAt,
            sourceMeta: rawEvents.sourceMeta,
            batchId: rawEvents.batchId,
            sourceId: rawEvents.sourceId,
            createdAt: rawEvents.createdAt,
          })
          .from(rawEvents)
          .where(whereExpr)
          .orderBy(orderExpr)
          .limit(pageSize)
          .offset((page - 1) * pageSize),
        db
          .select({ n: sql<number>`count(*)` })
          .from(rawEvents)
          .where(whereExpr)
          .limit(1),
      ]);

      return ok({
        items: items.map((r) => ({
          id: r.id,
          userId: r.userId,
          provider: r.provider,
          payload: r.payload,
          contactId: r.contactId ?? null,
          occurredAt: r.occurredAt,
          sourceMeta: r.sourceMeta ?? null,
          batchId: r.batchId ?? null,
          sourceId: r.sourceId ?? null,
          createdAt: r.createdAt,
        })),
        total: Number(totalRow[0]?.n) || 0,
      });
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to list raw events",
        details: error,
      });
    }
  }

  /**
   * Get a single raw event by ID
   */
  static async getRawEventById(userId: string, eventId: string): Promise<RawEventDTO | null> {
    const db = await getDb();

    const rows = await db
      .select({
        id: rawEvents.id,
        userId: rawEvents.userId,
        provider: rawEvents.provider,
        payload: rawEvents.payload,
        contactId: rawEvents.contactId,
        occurredAt: rawEvents.occurredAt,
        sourceMeta: rawEvents.sourceMeta,
        batchId: rawEvents.batchId,
        sourceId: rawEvents.sourceId,
        createdAt: rawEvents.createdAt,
      })
      .from(rawEvents)
      .where(and(eq(rawEvents.userId, userId), eq(rawEvents.id, eventId)))
      .limit(1);

    if (rows.length === 0) {
      return null;
    }

    return rows[0]!;
  }

  /**
   * Count raw events for a user with optional filtering
   */
  static async countRawEvents(userId: string, filters?: RawEventFilters): Promise<number> {
    const db = await getDb();

    const conditions = [eq(rawEvents.userId, userId)];

    if (filters?.provider && filters.provider.length > 0) {
      conditions.push(inArray(rawEvents.provider, filters.provider));
    }

    if (filters?.contactId) {
      conditions.push(eq(rawEvents.contactId, filters.contactId));
    }

    if (filters?.batchId) {
      conditions.push(eq(rawEvents.batchId, filters.batchId));
    }

    if (filters?.sourceId) {
      conditions.push(eq(rawEvents.sourceId, filters.sourceId));
    }

    const result = await db
      .select({ count: count() })
      .from(rawEvents)
      .where(and(...conditions));

    return result[0]?.count ?? 0;
  }

  /**
   * Delete raw events by batch ID
   */
  static async deleteRawEventsByBatch(userId: string, batchId: string): Promise<number> {
    const db = await getDb();

    const result = await db
      .delete(rawEvents)
      .where(and(eq(rawEvents.userId, userId), eq(rawEvents.batchId, batchId)));

    return result.length;
  }

  /**
   * Create a raw event error
   */
  static async createRawEventError(
    data: CreateRawEventErrorDTO & { userId: string },
  ): Promise<RawEventErrorDTO> {
    const db = await getDb();

    const insertValues = {
      rawEventId: data.rawEventId ?? null,
      userId: data.userId,
      provider: data.provider,
      errorAt: new Date(),
      stage: data.stage,
      error: data.error,
      context: data.context ?? null,
    };

    const [newError] = await db.insert(rawEventErrors).values(insertValues).returning({
      id: rawEventErrors.id,
      rawEventId: rawEventErrors.rawEventId,
      userId: rawEventErrors.userId,
      provider: rawEventErrors.provider,
      errorAt: rawEventErrors.errorAt,
      stage: rawEventErrors.stage,
      error: rawEventErrors.error,
      context: rawEventErrors.context,
    });

    if (!newError) {
      throw new Error("Failed to create raw event error");
    }

    return newError;
  }

  /**
   * Get raw event errors for a user
   */
  static async listRawEventErrors(userId: string, limit: number = 50): Promise<RawEventErrorDTO[]> {
    const db = await getDb();

    const rows = await db
      .select({
        id: rawEventErrors.id,
        rawEventId: rawEventErrors.rawEventId,
        userId: rawEventErrors.userId,
        provider: rawEventErrors.provider,
        errorAt: rawEventErrors.errorAt,
        stage: rawEventErrors.stage,
        error: rawEventErrors.error,
        context: rawEventErrors.context,
      })
      .from(rawEventErrors)
      .where(eq(rawEventErrors.userId, userId))
      .orderBy(desc(rawEventErrors.errorAt))
      .limit(limit);

    return rows.map((row) => row);
  }

  /**
   * Check if raw event exists by source ID and provider
   */
  static async findRawEventBySourceId(
    userId: string,
    provider: string,
    sourceId: string,
  ): Promise<RawEventDTO | null> {
    const db = await getDb();

    const rows = await db
      .select({
        id: rawEvents.id,
        userId: rawEvents.userId,
        provider: rawEvents.provider,
        payload: rawEvents.payload,
        contactId: rawEvents.contactId,
        occurredAt: rawEvents.occurredAt,
        sourceMeta: rawEvents.sourceMeta,
        batchId: rawEvents.batchId,
        sourceId: rawEvents.sourceId,
        createdAt: rawEvents.createdAt,
      })
      .from(rawEvents)
      .where(
        and(
          eq(rawEvents.userId, userId),
          eq(rawEvents.provider, provider),
          eq(rawEvents.sourceId, sourceId),
        ),
      )
      .limit(1);

    if (rows.length === 0) {
      return null;
    }

    return rows[0]!;
  }

  /**
   * Get events by batch ID
   */
  static async getRawEventsByBatch(userId: string, batchId: string): Promise<RawEventDTO[]> {
    const db = await getDb();

    const rows = await db
      .select({
        id: rawEvents.id,
        userId: rawEvents.userId,
        provider: rawEvents.provider,
        payload: rawEvents.payload,
        contactId: rawEvents.contactId,
        occurredAt: rawEvents.occurredAt,
        sourceMeta: rawEvents.sourceMeta,
        batchId: rawEvents.batchId,
        sourceId: rawEvents.sourceId,
        createdAt: rawEvents.createdAt,
      })
      .from(rawEvents)
      .where(and(eq(rawEvents.userId, userId), eq(rawEvents.batchId, batchId)))
      .orderBy(desc(rawEvents.occurredAt));

    return rows.map((row) => row);
  }
}



===== packages/repo/src/schema-canaries.test.ts =====
import { describe, it, expect } from "vitest";
import { contacts } from "@/server/db/schema";
import type { Contact as DbContact } from "@/server/db/schema";
import type { Contact as BusinessContact } from "@/server/db/business-schemas/contacts";
import { toContact } from "@/server/adapters/contacts";

/**
 * Schema Canary Tests
 *
 * These tests act as early warning system for schema drift.
 * They will fail if critical fields are removed from queries or types.
 *
 * CRITICAL: Do not remove or skip these tests without team discussion.
 */
describe("Schema Drift Detection - OmniClient/Contact", () => {
  describe("Database Schema", () => {
    it("contacts table must have all critical business fields", () => {
      const requiredFields = [
        "id",
        "userId",
        "displayName",
        "primaryEmail",
        "primaryPhone",
        "lifecycleStage", // Client lifecycle
        "tags", // Wellness segmentation
        "confidenceScore", // AI confidence
        "createdAt",
        "updatedAt",
      ];

      const actualFields = Object.keys(contacts);

      requiredFields.forEach((field) => {
        expect(actualFields).toContain(field);
      });
    });
  });

  describe("TypeScript Types", () => {
    it("Contact type must have nullable confidenceScore", () => {
      // Type-level test using conditional types
      type ConfidenceScoreType = DbContact["confidenceScore"];
      type IsNullable = null extends ConfidenceScoreType ? true : false;

      const typeCheck: IsNullable = true;
      expect(typeCheck).toBe(true);
    });

    it("Contact type must have tags as jsonb", () => {
      type TagsType = DbContact["tags"];
      // Tags should be unknown (jsonb) or a specific array type
      type IsCorrectType = TagsType extends unknown ? true : false;

      const typeCheck: IsCorrectType = true;
      expect(typeCheck).toBe(true);
    });
  });

  describe("Adapter Integration", () => {
    it("should preserve critical fields in toContact adapter", () => {
      const testRow: Partial<DbContact> = {
        id: "test-id",
        displayName: "Test Client",
        lifecycleStage: "prospect",
        tags: ["wellness"],
        confidenceScore: "0.85",
      };

      const result = toContact(testRow);

      // These will fail if adapter doesn't preserve fields
      expect(result).toHaveProperty("lifecycleStage");
      expect(result).toHaveProperty("tags");
      expect(result).toHaveProperty("confidenceScore");
    });

    it("should preserve critical fields in API response builder", () => {
      // This would be your actual API response builder
      type ApiContactResponse = Omit<BusinessContact, "createdAt" | "updatedAt"> & {
        createdAt: string;
        updatedAt: string;
      };

      const buildApiResponse = (client: BusinessContact): ApiContactResponse => {
        return {
          id: client.id,
          userId: client.userId,
          displayName: client.displayName,
          primaryEmail: client.primaryEmail,
          primaryPhone: client.primaryPhone,
          source: client.source,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          tags: client.tags as string[],
          lifecycleStage: client.lifecycleStage,
          confidenceScore: client.confidenceScore,
          dateOfBirth: client.dateOfBirth,
          emergencyContactName: client.emergencyContactName,
          emergencyContactPhone: client.emergencyContactPhone,
          clientStatus: client.contactStatus,
          referralSource: client.referralSource,
          address: client.address,
          healthContext: client.healthContext,
          preferences: client.preferences,
          photoUrl: client.photoUrl,
        };
      };

      const mockClient: BusinessContact = {
        id: "test-id",
        userId: "user-id",
        displayName: "Test Client",
        primaryEmail: "test@example.com",
        primaryPhone: null,
        source: "manual",
        lifecycleStage: "prospect",
        tags: ["wellness", "vip"],
        confidenceScore: "0.95",
        createdAt: new Date(),
        updatedAt: new Date(),
        dateOfBirth: null,
        emergencyContactName: null,
        emergencyContactPhone: null,
        clientStatus: null,
        referralSource: null,
        address: null,
        healthContext: null,
        preferences: null,
        photoUrl: null,
      };

      const response = buildApiResponse(mockClient);

      // Critical assertions
      expect(response).toHaveProperty("lifecycleStage");
      expect(response).toHaveProperty("tags");
      expect(response).toHaveProperty("confidenceScore");
    });
  });
});

/**
 * REGRESSION PREVENTION
 *
 * If any of these tests fail, it means:
 * 1. A database migration removed a critical field
 * 2. A type definition was changed incorrectly
 * 3. A repository query was modified to exclude fields
 * 4. An adapter is not preserving required data
 *
 * DO NOT SKIP OR REMOVE THESE TESTS
 * They are your safety net against breaking changes.
 */



===== packages/repo/src/search.repo.ts =====
import { eq, and, ilike, or } from "drizzle-orm";
import {
  contacts,
  notes,
  interactions,
  calendarEvents,
  tasks,
  embeddings,
} from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import { ok, err, DbResult } from "@/lib/utils/result";

export interface SearchResultDTO {
  id: string;
  type: "contact" | "note" | "interaction" | "calendar_event" | "task";
  title: string;
  content: string;
  metadata: Record<string, unknown>;
  similarity?: number;
  score?: number;
  source?: "traditional" | "semantic" | "hybrid";
  createdAt?: Date | null;
  updatedAt?: Date | null;
}

export interface TraditionalSearchParams {
  userId: string;
  query: string;
  limit: number;
  types?: Array<"contact" | "note" | "interaction" | "calendar_event" | "task">;
}

export interface SemanticSearchParams {
  userId: string;
  embedding: number[];
  limit: number;
  similarityThreshold?: number;
  types?: Array<"contact" | "note" | "interaction" | "calendar_event" | "task">;
}

export class SearchRepository {
  /**
   * Perform traditional text-based search across multiple entity types
   */
  static async searchTraditional(
    params: TraditionalSearchParams,
  ): Promise<DbResult<SearchResultDTO[]>> {
    try {
      const db = await getDb();
      const { userId, query, limit, types } = params;
      const searchTerm = `%${query}%`;
      const results: SearchResultDTO[] = [];

      // Calculate limit per type - distribute evenly
      const enabledTypes = types || ["contact", "note", "interaction", "calendar_event", "task"];
      const limitPerType = Math.max(1, Math.ceil(limit / enabledTypes.length));

      // Search contacts
      if (enabledTypes.includes("contact")) {
        const contactRows = await db
          .select()
          .from(contacts)
          .where(
            and(
              eq(contacts.userId, userId),
              or(
                ilike(contacts.displayName, searchTerm),
                ilike(contacts.primaryEmail, searchTerm),
                ilike(contacts.primaryPhone, searchTerm),
              ),
            ),
          )
          .limit(limitPerType);

        for (const row of contactRows) {
          results.push({
            id: row.id,
            type: "contact",
            title: row.displayName,
            content: [row.primaryEmail, row.primaryPhone].filter(Boolean).join(" "),
            metadata: {
              email: row.primaryEmail,
              phone: row.primaryPhone,
              lifecycleStage: row.lifecycleStage,
              tags: row.tags,
            },
            score: 1,
            source: "traditional",
            createdAt: row.createdAt,
            updatedAt: row.updatedAt,
          });
        }
      }

      // Search notes
      if (enabledTypes.includes("note")) {
        const noteRows = await db
          .select({
            note: notes,
            contact: contacts,
          })
          .from(notes)
          .leftJoin(contacts, eq(notes.contactId, contacts.id))
          .where(
            and(
              eq(notes.userId, userId),
              ilike(notes.contentPlain, searchTerm),
            ),
          )
          .limit(limitPerType);

        for (const row of noteRows) {
          results.push({
            id: row.note.id,
            type: "note",
            title: row.note.contentPlain.slice(0, 50) + (row.note.contentPlain.length > 50 ? "..." : ""),
            content: row.note.contentPlain,
            metadata: {
              contactId: row.note.contactId,
              contactName: row.contact?.displayName,
              tags: row.note.tags,
              sourceType: row.note.sourceType,
            },
            score: 1,
            source: "traditional",
            createdAt: row.note.createdAt,
            updatedAt: row.note.updatedAt,
          });
        }
      }

      // Search interactions
      if (enabledTypes.includes("interaction")) {
        const interactionRows = await db
          .select({
            interaction: interactions,
            contact: contacts,
          })
          .from(interactions)
          .leftJoin(contacts, eq(interactions.contactId, contacts.id))
          .where(
            and(
              eq(interactions.userId, userId),
              or(ilike(interactions.subject, searchTerm), ilike(interactions.bodyText, searchTerm)),
            ),
          )
          .limit(limitPerType);

        for (const row of interactionRows) {
          results.push({
            id: row.interaction.id,
            type: "interaction",
            title: row.interaction.subject || `${row.interaction.type} interaction`,
            content: row.interaction.bodyText || "",
            metadata: {
              type: row.interaction.type,
              contactId: row.interaction.contactId,
              contactName: row.contact?.displayName,
              occurredAt: row.interaction.occurredAt,
              source: row.interaction.source,
            },
            score: 1,
            source: "traditional",
            createdAt: row.interaction.createdAt,
          });
        }
      }

      // Search calendar events
      if (enabledTypes.includes("calendar_event")) {
        const eventRows = await db
          .select()
          .from(calendarEvents)
          .where(
            and(
              eq(calendarEvents.userId, userId),
              or(
                ilike(calendarEvents.title, searchTerm),
                ilike(calendarEvents.description, searchTerm),
                ilike(calendarEvents.location, searchTerm),
              ),
            ),
          )
          .limit(limitPerType);

        for (const row of eventRows) {
          results.push({
            id: row.id,
            type: "calendar_event",
            title: row.title,
            content: row.description || "",
            metadata: {
              startTime: row.startTime,
              endTime: row.endTime,
              location: row.location,
              isAllDay: row.isAllDay,
              eventType: row.eventType,
            },
            score: 1,
            source: "traditional",
            createdAt: row.createdAt,
            updatedAt: row.updatedAt,
          });
        }
      }

      // Search tasks
      if (enabledTypes.includes("task")) {
        const taskRows = await db
          .select()
          .from(tasks)
          .where(and(eq(tasks.userId, userId), or(ilike(tasks.name, searchTerm))))
          .limit(limitPerType);

        for (const row of taskRows) {
          results.push({
            id: row["id"],
            type: "task",
            title: row["name"],
            content: JSON.stringify(row["details"] || {}),
            metadata: {
              status: row["status"],
              priority: row["priority"],
              dueDate: row["dueDate"],
              projectId: row["projectId"],
            },
            score: 1,
            source: "traditional",
            createdAt: row["createdAt"],
            updatedAt: row["updatedAt"],
          });
        }
      }

      // Sort by creation date (most recent first) and limit
      const sortedResults = results
        .sort((a, b) => {
          const aTime = a.createdAt?.getTime() || 0;
          const bTime = b.createdAt?.getTime() || 0;
          return bTime - aTime;
        })
        .slice(0, limit);

      return ok(sortedResults);
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Traditional search failed",
        details: error,
      });
    }
  }

  /**
   * Perform semantic search using embeddings
   */
  static async searchSemantic(params: SemanticSearchParams): Promise<DbResult<SearchResultDTO[]>> {
    try {
      const db = await getDb();
      const { userId, embedding, limit, similarityThreshold = 0.7 } = params;

      // Use the semantic_search RPC function if it exists
      // For now, let's implement a basic embeddings search
      const embeddingRows = await db
        .select()
        .from(embeddings)
        .where(eq(embeddings.userId, userId))
        .limit(limit * 2); // Get more results to filter

      // Convert embedding string back to array and calculate similarity
      const results: SearchResultDTO[] = [];

      for (const row of embeddingRows) {
        if (!row.embedding) continue;

        // Skip if types filter is provided and this row's ownerType is not included
        if (
          params.types &&
          params.types.length > 0 &&
          !params.types.includes(
            row.ownerType as "contact" | "note" | "interaction" | "calendar_event" | "task",
          )
        ) {
          continue;
        }

        try {
          const rowEmbedding = JSON.parse(row.embedding) as number[];
          const similarity = calculateCosineSimilarity(embedding, rowEmbedding);

          if (similarity >= similarityThreshold) {
            // Get the actual entity based on ownerType and ownerId
            const entityResult = await this.getEntityById(userId, row.ownerType, row.ownerId);

            if (entityResult.success && entityResult.data) {
              results.push({
                ...entityResult.data,
                similarity,
                score: similarity,
                source: "semantic",
              });
            }
          }
        } catch (_error) {
          // Skip malformed embedding data
          continue;
        }
      }

      // Sort by similarity (highest first) and limit
      const sortedResults = results
        .sort((a, b) => (b.similarity || 0) - (a.similarity || 0))
        .slice(0, limit);

      return ok(sortedResults);
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Semantic search failed",
        details: error,
      });
    }
  }

  /**
   * Get entity by type and ID for semantic search results
   */
  private static async getEntityById(
    userId: string,
    ownerType: string,
    ownerId: string,
  ): Promise<DbResult<SearchResultDTO | null>> {
    try {
      const db = await getDb();

      switch (ownerType) {
        case "contact": {
          const [contact] = await db
            .select()
            .from(contacts)
            .where(and(eq(contacts.userId, userId), eq(contacts.id, ownerId)))
            .limit(1);

          if (!contact) return ok(null);

          return ok({
            id: contact.id,
            type: "contact",
            title: contact.displayName,
            content: [contact.primaryEmail, contact.primaryPhone].filter(Boolean).join(" "),
            metadata: {
              email: contact.primaryEmail,
              phone: contact.primaryPhone,
              lifecycleStage: contact.lifecycleStage,
              tags: contact.tags,
            },
            createdAt: contact.createdAt,
            updatedAt: contact.updatedAt,
          });
        }

        case "note": {
          const noteRows = await db
            .select({
              note: notes,
              contact: contacts,
            })
            .from(notes)
            .leftJoin(contacts, eq(notes.contactId, contacts.id))
            .where(and(eq(notes.userId, userId), eq(notes.id, ownerId)))
            .limit(1);

          const row = noteRows[0];
          if (!row) return ok(null);

          return ok({
            id: row.note.id,
            type: "note",
            title: row.note.contentPlain.slice(0, 50) + (row.note.contentPlain.length > 50 ? "..." : ""),
            content: row.note.contentPlain,
            metadata: {
              contactId: row.note.contactId,
              contactName: row.contact?.displayName,
              tags: row.note.tags,
              sourceType: row.note.sourceType,
            },
            createdAt: row.note.createdAt,
            updatedAt: row.note.updatedAt,
          });
        }

        case "interaction": {
          const interactionRows = await db
            .select({
              interaction: interactions,
              contact: contacts,
            })
            .from(interactions)
            .leftJoin(contacts, eq(interactions.contactId, contacts.id))
            .where(and(eq(interactions.userId, userId), eq(interactions.id, ownerId)))
            .limit(1);

          const row = interactionRows[0];
          if (!row) return ok(null);

          return ok({
            id: row.interaction.id,
            type: "interaction",
            title: row.interaction.subject || `${row.interaction.type} interaction`,
            content: row.interaction.bodyText || "",
            metadata: {
              type: row.interaction.type,
              contactId: row.interaction.contactId,
              contactName: row.contact?.displayName,
              occurredAt: row.interaction.occurredAt,
              source: row.interaction.source,
            },
            createdAt: row.interaction.createdAt,
          });
        }

        case "calendar_event": {
          const [event] = await db
            .select()
            .from(calendarEvents)
            .where(and(eq(calendarEvents.userId, userId), eq(calendarEvents.id, ownerId)))
            .limit(1);

          if (!event) return ok(null);

          return ok({
            id: event.id,
            type: "calendar_event",
            title: event.title,
            content: event.description || "",
            metadata: {
              startTime: event.startTime,
              endTime: event.endTime,
              location: event.location,
              isAllDay: event.isAllDay,
              eventType: event.eventType,
            },
            createdAt: event.createdAt,
            updatedAt: event.updatedAt,
          });
        }

        case "task": {
          const [task] = await db
            .select()
            .from(tasks)
            .where(and(eq(tasks.userId, userId), eq(tasks.id, ownerId)))
            .limit(1);

          if (!task) return ok(null);

          return ok({
            id: task["id"],
            type: "task",
            title: task["name"],
            content: JSON.stringify(task["details"] || {}),
            metadata: {
              status: task["status"],
              priority: task["priority"],
              dueDate: task["dueDate"],
              projectId: task["projectId"],
            },
            createdAt: task["createdAt"],
            updatedAt: task["updatedAt"],
          });
        }

        default:
          return ok(null);
      }
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to get entity",
        details: error,
      });
    }
  }
}

/**
 * Calculate cosine similarity between two embedding vectors
 */
function calculateCosineSimilarity(a: number[], b: number[]): number {
  if (a.length !== b.length) return 0;

  let dotProduct = 0;
  let normA = 0;
  let normB = 0;

  for (let i = 0; i < a.length; i++) {
    const aVal = a[i] ?? 0;
    const bVal = b[i] ?? 0;
    dotProduct += aVal * bVal;
    normA += aVal * aVal;
    normB += bVal * bVal;
  }

  if (normA === 0 || normB === 0) return 0;

  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}



===== packages/repo/src/sync-sessions.repo.ts =====
import { eq, and, desc, notInArray } from "drizzle-orm";
import { syncSessions } from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import type { SyncSession, CreateSyncSession } from "@/server/db/schema";
import { ok, err, DbResult } from "@/lib/utils/result";

// Local type aliases for repository layer
type SyncSessionDTO = SyncSession;
type CreateSyncSessionDTO = CreateSyncSession;
type UpdateSyncSessionDTO = Partial<CreateSyncSession>;

interface SyncSessionFilters {
  service?: string;
  status?: string;
}

export class SyncSessionsRepository {
  /**
   * List sync sessions for a user with optional filtering
   */
  static async listSyncSessions(
    userId: string,
    filters?: SyncSessionFilters,
  ): Promise<DbResult<SyncSessionDTO[]>> {
    try {
      const db = await getDb();

      // Build conditions array
      const conditions = [eq(syncSessions.userId, userId)];

      if (filters?.service) {
        conditions.push(eq(syncSessions.service, filters.service));
      }

      if (filters?.status) {
        conditions.push(eq(syncSessions.status, filters.status));
      }

      const query = db
        .select({
          id: syncSessions.id,
          userId: syncSessions.userId,
          service: syncSessions.service,
          status: syncSessions.status,
          progressPercentage: syncSessions.progressPercentage,
          currentStep: syncSessions.currentStep,
          totalItems: syncSessions.totalItems,
          importedItems: syncSessions.importedItems,
          processedItems: syncSessions.processedItems,
          failedItems: syncSessions.failedItems,
          startedAt: syncSessions.startedAt,
          completedAt: syncSessions.completedAt,
          errorDetails: syncSessions.errorDetails,
          preferences: syncSessions.preferences,
        })
        .from(syncSessions)
        .where(and(...conditions))
        .orderBy(desc(syncSessions.startedAt));

      const rows = await query;

      return ok(rows.map((row) => row));
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to list sync sessions",
        details: error,
      });
    }
  }

  /**
   * Get a single sync session by ID
   */
  static async getSyncSessionById(
    userId: string,
    sessionId: string,
  ): Promise<SyncSessionDTO | null> {
    const db = await getDb();

    const rows = await db
      .select({
        id: syncSessions.id,
        userId: syncSessions.userId,
        service: syncSessions.service,
        status: syncSessions.status,
        progressPercentage: syncSessions.progressPercentage,
        currentStep: syncSessions.currentStep,
        totalItems: syncSessions.totalItems,
        importedItems: syncSessions.importedItems,
        processedItems: syncSessions.processedItems,
        failedItems: syncSessions.failedItems,
        startedAt: syncSessions.startedAt,
        completedAt: syncSessions.completedAt,
        errorDetails: syncSessions.errorDetails,
        preferences: syncSessions.preferences,
      })
      .from(syncSessions)
      .where(and(eq(syncSessions.userId, userId), eq(syncSessions.id, sessionId)))
      .limit(1);

    return rows[0] || null;
  }

  /**
   * Get the latest sync session for a service
   */
  static async getLatestSyncSession(
    userId: string,
    service: string,
  ): Promise<SyncSessionDTO | null> {
    const db = await getDb();

    const rows = await db
      .select({
        id: syncSessions.id,
        userId: syncSessions.userId,
        service: syncSessions.service,
        status: syncSessions.status,
        progressPercentage: syncSessions.progressPercentage,
        currentStep: syncSessions.currentStep,
        totalItems: syncSessions.totalItems,
        importedItems: syncSessions.importedItems,
        processedItems: syncSessions.processedItems,
        failedItems: syncSessions.failedItems,
        startedAt: syncSessions.startedAt,
        completedAt: syncSessions.completedAt,
        errorDetails: syncSessions.errorDetails,
        preferences: syncSessions.preferences,
      })
      .from(syncSessions)
      .where(and(eq(syncSessions.userId, userId), eq(syncSessions.service, service)))
      .orderBy(desc(syncSessions.startedAt))
      .limit(1);

    return rows[0] || null;
  }

  /**
   * Get active sync sessions (not completed, failed, or cancelled)
   */
  static async getActiveSyncSessions(userId: string): Promise<SyncSessionDTO[]> {
    const db = await getDb();

    const rows = await db
      .select({
        id: syncSessions.id,
        userId: syncSessions.userId,
        service: syncSessions.service,
        status: syncSessions.status,
        progressPercentage: syncSessions.progressPercentage,
        currentStep: syncSessions.currentStep,
        totalItems: syncSessions.totalItems,
        importedItems: syncSessions.importedItems,
        processedItems: syncSessions.processedItems,
        failedItems: syncSessions.failedItems,
        startedAt: syncSessions.startedAt,
        completedAt: syncSessions.completedAt,
        errorDetails: syncSessions.errorDetails,
        preferences: syncSessions.preferences,
      })
      .from(syncSessions)
      .where(
        and(
          eq(syncSessions.userId, userId),
          // Status is not a terminal state - exclude completed, failed, cancelled
          notInArray(syncSessions.status, ["completed", "failed", "cancelled"]),
        ),
      )
      .orderBy(desc(syncSessions.startedAt));

    return rows.map((row) => row);
  }

  /**
   * Create a new sync session
   */
  static async createSyncSession(
    userId: string,
    data: CreateSyncSessionDTO,
  ): Promise<DbResult<SyncSessionDTO>> {
    try {
      const db = await getDb();

      const [newSession] = await db
        .insert(syncSessions)
        .values({
          userId: userId,
          service: data.service,
          status: "pending",
          preferences: data.preferences ?? {},
        })
        .returning({
          id: syncSessions.id,
          userId: syncSessions.userId,
          service: syncSessions.service,
          status: syncSessions.status,
          progressPercentage: syncSessions.progressPercentage,
          currentStep: syncSessions.currentStep,
          totalItems: syncSessions.totalItems,
          importedItems: syncSessions.importedItems,
          processedItems: syncSessions.processedItems,
          failedItems: syncSessions.failedItems,
          startedAt: syncSessions.startedAt,
          completedAt: syncSessions.completedAt,
          errorDetails: syncSessions.errorDetails,
          preferences: syncSessions.preferences,
        });

      if (!newSession) {
        return err({
          code: "DB_INSERT_FAILED",
          message: "Failed to create sync session - no data returned",
        });
      }

      return ok(newSession);
    } catch (error) {
      return err({
        code: "DB_INSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to create sync session",
        details: error,
      });
    }
  }

  /**
   * Update an existing sync session
   */
  static async updateSyncSession(
    userId: string,
    sessionId: string,
    data: UpdateSyncSessionDTO,
  ): Promise<SyncSessionDTO | null> {
    const db = await getDb();

    // If status is being set to a terminal state, set completedAt
    const updateData = { ...data };
    if (data.status && ["completed", "failed", "cancelled"].includes(data.status)) {
      updateData.completedAt = new Date();
    }

    // Convert undefined to null for database nullable fields with exactOptionalPropertyTypes
    const updateValues = {
      ...(updateData.status !== undefined && { status: updateData.status }),
      ...(updateData.progressPercentage !== undefined && {
        progressPercentage: updateData.progressPercentage,
      }),
      ...(updateData.currentStep !== undefined && { currentStep: updateData.currentStep ?? null }),
      ...(updateData.totalItems !== undefined && { totalItems: updateData.totalItems }),
      ...(updateData.importedItems !== undefined && { importedItems: updateData.importedItems }),
      ...(updateData.processedItems !== undefined && { processedItems: updateData.processedItems }),
      ...(updateData.failedItems !== undefined && { failedItems: updateData.failedItems }),
      ...(updateData.completedAt !== undefined && { completedAt: updateData.completedAt ?? null }),
      ...(updateData.errorDetails !== undefined && {
        errorDetails: updateData.errorDetails ?? null,
      }),
    };

    const [updatedSession] = await db
      .update(syncSessions)
      .set(updateValues)
      .where(and(eq(syncSessions.userId, userId), eq(syncSessions.id, sessionId)))
      .returning({
        id: syncSessions.id,
        userId: syncSessions.userId,
        service: syncSessions.service,
        status: syncSessions.status,
        progressPercentage: syncSessions.progressPercentage,
        currentStep: syncSessions.currentStep,
        totalItems: syncSessions.totalItems,
        importedItems: syncSessions.importedItems,
        processedItems: syncSessions.processedItems,
        failedItems: syncSessions.failedItems,
        startedAt: syncSessions.startedAt,
        completedAt: syncSessions.completedAt,
        errorDetails: syncSessions.errorDetails,
        preferences: syncSessions.preferences,
      });

    if (!updatedSession) {
      return null;
    }

    return updatedSession;
  }

  /**
   * Update sync session progress
   */
  static async updateSyncProgress(
    userId: string,
    sessionId: string,
    progress: {
      progressPercentage?: number;
      currentStep?: string;
      totalItems?: number;
      importedItems?: number;
      processedItems?: number;
      failedItems?: number;
    },
  ): Promise<SyncSessionDTO | null> {
    const db = await getDb();

    const [updatedSession] = await db
      .update(syncSessions)
      .set({
        ...progress,
      })
      .where(and(eq(syncSessions.userId, userId), eq(syncSessions.id, sessionId)))
      .returning({
        id: syncSessions.id,
        userId: syncSessions.userId,
        service: syncSessions.service,
        status: syncSessions.status,
        progressPercentage: syncSessions.progressPercentage,
        currentStep: syncSessions.currentStep,
        totalItems: syncSessions.totalItems,
        importedItems: syncSessions.importedItems,
        processedItems: syncSessions.processedItems,
        failedItems: syncSessions.failedItems,
        startedAt: syncSessions.startedAt,
        completedAt: syncSessions.completedAt,
        errorDetails: syncSessions.errorDetails,
        preferences: syncSessions.preferences,
      });

    if (!updatedSession) {
      return null;
    }

    return updatedSession;
  }

  /**
   * Mark sync session as failed with error details
   */
  static async markSyncSessionFailed(
    userId: string,
    sessionId: string,
    errorDetails: Record<string, unknown>,
  ): Promise<SyncSessionDTO | null> {
    return this.updateSyncSession(userId, sessionId, {
      status: "failed",
      errorDetails,
    });
  }

  /**
   * Mark sync session as completed
   */
  static async markSyncSessionCompleted(
    userId: string,
    sessionId: string,
  ): Promise<SyncSessionDTO | null> {
    return this.updateSyncSession(userId, sessionId, {
      status: "completed",
      progressPercentage: 100,
    });
  }

  /**
   * Cancel a sync session
   */
  static async cancelSyncSession(
    userId: string,
    sessionId: string,
  ): Promise<SyncSessionDTO | null> {
    return this.updateSyncSession(userId, sessionId, {
      status: "cancelled",
    });
  }

  /**
   * Delete a sync session
   */
  static async deleteSyncSession(userId: string, sessionId: string): Promise<boolean> {
    const db = await getDb();

    const result = await db
      .delete(syncSessions)
      .where(and(eq(syncSessions.userId, userId), eq(syncSessions.id, sessionId)));

    return result.length > 0;
  }
}



===== packages/repo/src/user-integrations.repo.ts =====
import { eq, and, gt, lte } from "drizzle-orm";
import { userIntegrations, UserIntegration, CreateUserIntegration } from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import { ok, err, DbResult } from "@/lib/utils/result";

// Local type aliases for repository layer
type UserIntegrationDTO = UserIntegration & { hasValidToken?: boolean };
type CreateUserIntegrationDTO = CreateUserIntegration;
type UpdateUserIntegrationDTO = Partial<CreateUserIntegration>;

export class UserIntegrationsRepository {
  /**
   * List integrations for a user
   */
  static async listUserIntegrations(userId: string): Promise<DbResult<UserIntegrationDTO[]>> {
    try {
      const db = await getDb();

      const rows = await db
        .select({
          userId: userIntegrations.userId,
          provider: userIntegrations.provider,
          service: userIntegrations.service,
          accessToken: userIntegrations.accessToken,
          refreshToken: userIntegrations.refreshToken,
          expiryDate: userIntegrations.expiryDate,
          createdAt: userIntegrations.createdAt,
          updatedAt: userIntegrations.updatedAt,
        })
        .from(userIntegrations)
        .where(eq(userIntegrations.userId, userId));

      // Map to DTO format with derived hasValidToken field
      return ok(
        rows.map((row) => ({
          userId: row.userId,
          provider: row.provider,
          service: row.service,
          accessToken: row.accessToken,
          refreshToken: row.refreshToken,
          expiryDate: row.expiryDate,
          createdAt: row.createdAt,
          updatedAt: row.updatedAt,
          hasValidToken: row.expiryDate ? new Date() < new Date(row.expiryDate) : true,
        })),
      );
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to list user integrations",
        details: error,
      });
    }
  }

  /**
   * Get integration by user, provider, and service
   */
  static async getUserIntegration(
    userId: string,
    provider: string,
    service: string,
  ): Promise<UserIntegrationDTO | null> {
    const db = await getDb();

    const rows = await db
      .select({
        userId: userIntegrations.userId,
        provider: userIntegrations.provider,
        service: userIntegrations.service,
        accessToken: userIntegrations.accessToken,
        refreshToken: userIntegrations.refreshToken,
        expiryDate: userIntegrations.expiryDate,
        createdAt: userIntegrations.createdAt,
        updatedAt: userIntegrations.updatedAt,
      })
      .from(userIntegrations)
      .where(
        and(
          eq(userIntegrations.userId, userId),
          eq(userIntegrations.provider, provider),
          eq(userIntegrations.service, service),
        ),
      )
      .limit(1);

    if (rows.length === 0) {
      return null;
    }

    const row = rows[0];
    if (!row) {
      return null;
    }
    return {
      userId: row.userId,
      provider: row.provider,
      service: row.service,
      accessToken: row.accessToken,
      refreshToken: row.refreshToken,
      expiryDate: row.expiryDate,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt,
      hasValidToken: row.expiryDate ? new Date() < new Date(row.expiryDate) : true,
    };
  }

  /**
   * Get all integrations for a specific provider
   */
  static async getUserIntegrationsByProvider(
    userId: string,
    provider: string,
  ): Promise<UserIntegrationDTO[]> {
    const db = await getDb();

    const rows = await db
      .select({
        userId: userIntegrations.userId,
        provider: userIntegrations.provider,
        service: userIntegrations.service,
        accessToken: userIntegrations.accessToken,
        refreshToken: userIntegrations.refreshToken,
        expiryDate: userIntegrations.expiryDate,
        createdAt: userIntegrations.createdAt,
        updatedAt: userIntegrations.updatedAt,
      })
      .from(userIntegrations)
      .where(and(eq(userIntegrations.userId, userId), eq(userIntegrations.provider, provider)));

    return rows.map((row) => row);
  }

  /**
   * Create or update user integration (upsert)
   */
  static async upsertUserIntegration(
    userId: string,
    data: CreateUserIntegrationDTO,
  ): Promise<DbResult<UserIntegrationDTO>> {
    try {
      const db = await getDb();

      const [result] = await db
        .insert(userIntegrations)
        .values({
          userId: userId,
          provider: data.provider,
          service: data.service,
          accessToken: data.accessToken,
          refreshToken: data.refreshToken ?? null,
          expiryDate: data.expiryDate ?? null,
        })
        .onConflictDoUpdate({
          target: [userIntegrations.userId, userIntegrations.provider, userIntegrations.service],
          set: {
            accessToken: data.accessToken,
            refreshToken: data.refreshToken ?? null,
            expiryDate: data.expiryDate ?? null,
            updatedAt: new Date(),
          },
        })
        .returning({
          userId: userIntegrations.userId,
          provider: userIntegrations.provider,
          service: userIntegrations.service,
          accessToken: userIntegrations.accessToken,
          refreshToken: userIntegrations.refreshToken,
          expiryDate: userIntegrations.expiryDate,
          createdAt: userIntegrations.createdAt,
          updatedAt: userIntegrations.updatedAt,
        });

      if (!result) {
        return err({
          code: "DB_UPSERT_FAILED",
          message: "Failed to upsert user integration - no data returned",
        });
      }

      return ok(result);
    } catch (error) {
      return err({
        code: "DB_UPSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to upsert user integration",
        details: error,
      });
    }
  }

  /**
   * Update user integration
   */
  static async updateUserIntegration(
    userId: string,
    provider: string,
    service: string,
    data: UpdateUserIntegrationDTO,
  ): Promise<UserIntegrationDTO | null> {
    const db = await getDb();

    // Convert undefined to null for database nullable fields with exactOptionalPropertyTypes
    const updateValues = {
      updatedAt: new Date(),
      ...(data.provider !== undefined && { provider: data.provider }),
      ...(data.service !== undefined && { service: data.service }),
      ...(data.accessToken !== undefined && { accessToken: data.accessToken }),
      ...(data.refreshToken !== undefined && { refreshToken: data.refreshToken ?? null }),
      ...(data.expiryDate !== undefined && { expiryDate: data.expiryDate ?? null }),
    };

    const [updatedIntegration] = await db
      .update(userIntegrations)
      .set(updateValues)
      .where(
        and(
          eq(userIntegrations.userId, userId),
          eq(userIntegrations.provider, provider),
          eq(userIntegrations.service, service),
        ),
      )
      .returning({
        userId: userIntegrations.userId,
        provider: userIntegrations.provider,
        service: userIntegrations.service,
        accessToken: userIntegrations.accessToken,
        refreshToken: userIntegrations.refreshToken,
        expiryDate: userIntegrations.expiryDate,
        createdAt: userIntegrations.createdAt,
        updatedAt: userIntegrations.updatedAt,
      });

    if (!updatedIntegration) {
      return null;
    }

    return updatedIntegration;
  }

  /**
   * Delete user integration
   */
  static async deleteUserIntegration(
    userId: string,
    provider: string,
    service: string,
  ): Promise<boolean> {
    const db = await getDb();

    const result = await db
      .delete(userIntegrations)
      .where(
        and(
          eq(userIntegrations.userId, userId),
          eq(userIntegrations.provider, provider),
          eq(userIntegrations.service, service),
        ),
      );

    return result.length > 0;
  }

  /**
   * Delete all integrations for a user and provider
   */
  static async deleteUserIntegrationsByProvider(userId: string, provider: string): Promise<number> {
    const db = await getDb();

    const result = await db
      .delete(userIntegrations)
      .where(and(eq(userIntegrations.userId, userId), eq(userIntegrations.provider, provider)));

    return result.length;
  }

  /**
   * Check if user has active integration for provider/service
   */
  static async hasActiveIntegration(
    userId: string,
    provider: string,
    service: string,
  ): Promise<boolean> {
    const integration = await this.getUserIntegration(userId, provider, service);

    if (!integration) {
      return false;
    }

    // Check if token is not expired (if expiryDate exists)
    if (integration.expiryDate) {
      return new Date() < integration.expiryDate;
    }

    // If no expiry date, assume it's active
    return true;
  }

  /**
   * Get integrations that are expiring soon (within next hour)
   */
  static async getExpiringIntegrations(userId: string): Promise<UserIntegrationDTO[]> {
    const db = await getDb();
    const now = new Date();
    const oneHourFromNow = new Date(Date.now() + 60 * 60 * 1000);

    const rows = await db
      .select({
        userId: userIntegrations.userId,
        provider: userIntegrations.provider,
        service: userIntegrations.service,
        accessToken: userIntegrations.accessToken,
        refreshToken: userIntegrations.refreshToken,
        expiryDate: userIntegrations.expiryDate,
        createdAt: userIntegrations.createdAt,
        updatedAt: userIntegrations.updatedAt,
      })
      .from(userIntegrations)
      .where(
        and(
          eq(userIntegrations.userId, userId),
          // Token expires within the next hour - use range instead of exact match
          gt(userIntegrations.expiryDate, now),
          lte(userIntegrations.expiryDate, oneHourFromNow),
        ),
      );

    return rows.map((row) => row);
  }

  /**
   * INTERNAL: Get raw integration data with sensitive tokens for Google client
   * This method exposes sensitive data and should only be used by the Google client layer
   */
  static async getRawIntegrationData(
    userId: string,
    provider: string,
  ): Promise<
    Array<{
      userId: string;
      provider: string;
      service: string | null;
      accessToken: string;
      refreshToken: string | null;
      expiryDate: Date | null;
      createdAt: Date | null;
      updatedAt: Date | null;
    }>
  > {
    const db = await getDb();

    const rows = await db
      .select()
      .from(userIntegrations)
      .where(and(eq(userIntegrations.userId, userId), eq(userIntegrations.provider, provider)));

    return rows;
  }

  /**
   * INTERNAL: Update raw integration tokens for Google client
   * This method handles sensitive data and should only be used by the Google client layer
   */
  static async updateRawTokens(
    userId: string,
    provider: string,
    service: string,
    updates: {
      accessToken?: string;
      refreshToken?: string | null;
      expiryDate?: Date | null;
    },
  ): Promise<void> {
    const db = await getDb();

    await db
      .update(userIntegrations)
      .set({
        ...updates,
        updatedAt: new Date(),
      })
      .where(
        and(
          eq(userIntegrations.userId, userId),
          eq(userIntegrations.provider, provider),
          eq(userIntegrations.service, service),
        ),
      );
  }
}



===== packages/repo/src/zones.repo.ts =====
import { eq, asc } from "drizzle-orm";
import { zones } from "@/server/db/schema";
import { getDb } from "@/server/db/client";
import type { Zone, CreateZone } from "@/server/db/schema";
import { ok, err, DbResult } from "@/lib/utils/result";

// Local type aliases for repository layer
type ZoneDTO = Zone;
type CreateZoneDTO = CreateZone;
type UpdateZoneDTO = Partial<CreateZone>;

type ZoneWithStatsDTO = Zone & {
  projectCount: number;
  taskCount: number;
  activeTaskCount: number;
};

export class ZonesRepository {
  /**
   * List all zones ordered by name
   */
  static async listZones(): Promise<DbResult<ZoneDTO[]>> {
    try {
      const db = await getDb();

      const rows = await db
        .select({
          id: zones.id,
          name: zones.name,
          color: zones.color,
          iconName: zones.iconName,
        })
        .from(zones)
        .orderBy(asc(zones.name));

      return ok(rows.map((row) => row));
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to list zones",
        details: error,
      });
    }
  }

  /**
   * Get a single zone by ID
   */
  static async getZoneById(zoneId: number): Promise<ZoneDTO | null> {
    const db = await getDb();

    const rows = await db
      .select({
        id: zones.id,
        name: zones.name,
        color: zones.color,
        iconName: zones.iconName,
      })
      .from(zones)
      .where(eq(zones.id, zoneId))
      .limit(1);

    if (rows.length === 0) {
      return null;
    }

    return rows[0] ?? null;
  }

  /**
   * Get a single zone by name
   */
  static async getZoneByName(name: string): Promise<ZoneDTO | null> {
    const db = await getDb();

    const rows = await db
      .select({
        id: zones.id,
        name: zones.name,
        color: zones.color,
        iconName: zones.iconName,
      })
      .from(zones)
      .where(eq(zones.name, name))
      .limit(1);

    if (rows.length === 0) {
      return null;
    }

    return rows[0] ?? null;
  }

  /**
   * Create a new zone (admin function)
   */
  static async createZone(data: CreateZoneDTO): Promise<DbResult<ZoneDTO>> {
    try {
      const db = await getDb();

      const insertValues = {
        id: data.id ?? undefined, // Let database handle auto-increment if not provided
        name: data.name,
        color: data.color ?? null,
        iconName: data.iconName ?? null,
      };

      const [newZone] = await db.insert(zones).values(insertValues).returning({
        id: zones.id,
        name: zones.name,
        color: zones.color,
        iconName: zones.iconName,
      });

      if (!newZone) {
        return err({
          code: "DB_INSERT_FAILED",
          message: "Failed to create zone - no data returned",
        });
      }

      return ok(newZone);
    } catch (error) {
      return err({
        code: "DB_INSERT_FAILED",
        message: error instanceof Error ? error.message : "Failed to create zone",
        details: error,
      });
    }
  }

  /**
   * Update an existing zone (admin function)
   */
  static async updateZone(zoneId: number, data: UpdateZoneDTO): Promise<ZoneDTO | null> {
    const db = await getDb();

    const updateValues = {
      ...(data.name !== undefined && { name: data.name }),
      ...(data.color !== undefined && { color: data.color ?? null }),
      ...(data.iconName !== undefined && { iconName: data.iconName ?? null }),
    };

    const [updatedZone] = await db
      .update(zones)
      .set(updateValues)
      .where(eq(zones.id, zoneId))
      .returning({
        id: zones.id,
        name: zones.name,
        color: zones.color,
        iconName: zones.iconName,
      });

    if (!updatedZone) {
      return null;
    }

    return updatedZone;
  }

  /**
   * Delete a zone (admin function)
   */
  static async deleteZone(zoneId: number): Promise<boolean> {
    const db = await getDb();

    const result = await db.delete(zones).where(eq(zones.id, zoneId)).returning({ id: zones.id });

    return result.length > 0;
  }

  /**
   * Get zones with usage statistics
   */
  static async getZonesWithStats(): Promise<DbResult<ZoneWithStatsDTO[]>> {
    try {
      const db = await getDb();

      // For now, return zones with zero counts since we'll implement usage stats later
      // TODO: Add actual project and task count queries when those repositories are implemented
      const rows = await db
        .select({
          id: zones.id,
          name: zones.name,
          color: zones.color,
          iconName: zones.iconName,
        })
        .from(zones)
        .orderBy(asc(zones.name));

      const zonesWithStats = rows.map((row) => ({
        ...row,
        projectCount: 0,
        taskCount: 0,
        activeTaskCount: 0,
      }));

      return ok(zonesWithStats.map((row) => row));
    } catch (error) {
      return err({
        code: "DB_QUERY_FAILED",
        message: error instanceof Error ? error.message : "Failed to get zones with stats",
        details: error,
      });
    }
  }
}




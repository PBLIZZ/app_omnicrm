===== docs/features/notes-wellness-practitioner-spec.md =====
# Notes System - Wellness Practitioner Specification

## Research Summary

Health coaches and wellness practitioners rely on session notes as the **core artifact** for documenting goals, interventions, progress, and agreed actions. Notes support continuity of care, accountability, and outcome tracking.

### Key Findings

1. **Notes are the primary pane** - Session notes are the backbone of clinical reasoning; insights/automations should enrich, not displace, notes
2. **Fast capture is essential** - Single-click Add Note (voice-to-text, type, upload→OCR) with minimal friction
3. **Chronological narrative > heavy structure** - Clean feed with lightweight structure (headings, tags, goal links) beats complex forms
4. **PII redaction by design** - Server-side redaction with client-side nudges; store only sanitized text
5. **Progressive disclosure** - Latest note preview prominent; older notes, attachments, AI insights, timeline on demand

---

## Implementation Roadmap

### Phase 1: Current State (✅ Completed)

**Status**: Basic notes CRUD with PII redaction

- [x] Notes table in database with `contentPlain`, `contentRich`, `piiEntities`, `tags`, `sourceType`
- [x] API routes: `GET/POST /api/notes`, `GET/PUT/DELETE /api/notes/[noteId]`
- [x] TipTap rich text editor with SSR-safe rendering
- [x] Server-side PII detection and redaction (emails, phones, SSN, addresses)
- [x] Client-side PII warnings with amber alert banner
- [x] Notes-first layout on contact card (default tab)
- [x] Basic note creation and display

### Phase 2: Above-the-Fold Essentials (🚧 Next Priority)

**Goal**: Make notes the engine of care continuity

#### 2.1 Latest Note Excerpt on Contact Card

- [ ] Show latest 2-3 paragraphs (~300-500 chars) above the fold
- [ ] Display timestamp, author (currently single user, future-proof)
- [ ] "View full note" link → `/contacts/[contactId]/notes/[noteId]`
- [ ] Create dedicated note detail page at `src/app/(authorisedRoute)/contacts/[contactId]/notes/[noteId]/page.tsx`

#### 2.2 Fast Capture Controls

- [ ] **Voice-to-text button** - Integrate browsers mediaRecorder API to record audio and send to OpenAI Whisper API via an HTTP POST request.

  Example endpoint (as of 2025):

  ```typescript
  const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
      method: "POST",
      headers: {
          "Content-Type": "multipart/form-data",
          "Authorization": `Bearer ${OPENAI_API_KEY}`,
      },
      body: formData,
  });
  ```

  Required fields:
  - file (audio file)
  - model (usually "whisper-1")
  Optional: prompt (context), language, etc.

  Receive & Store Transcription

  The API returns the transcribed text.

  Save this in your database (notes table, one row per note).
  - Streaming transcription with interim results
  - Store only final sanitized text
  - Error handling for browser compatibility

- [ ] **Upload → AI Text Extraction button** - Photo/PDF upload with text extraction by llm, (not ocr tech) use a model that is strong at reading documents
  - Accept `.jpg`, `.png`, `.pdf` file types
  - Background job processing with retry logic
  - Store only extracted text, delete uploaded file
- [ ] **Type button** (current editor) - Default option

#### 2.3 Quick Metadata at Point of Entry

- [ ] **Goal link picker** - Inline dropdown to associate note with goals
  - Query `goals` table WHERE `contactId` AND `status != 'abandoned'`
  - Allow multiple goal associations via `note_goals` junction table
  - Display linked goals as chips on note
- [ ] **Quick tags input** - Inline dropdown to associate note with tags
  - Store in `notes.tags` array column
  - Auto-suggest from existing tags for contact
- [ ] **Next step prompt** - Read nextsteps from AI Insights table
  - Stored in `next_steps` JSONB field in AI Insights table
  - Link to OmniMomentum task creation

#### 2.4 Status Signals on Contact Card

- [ ] Last session date (query most recent `interaction` where calendarEvent matches contactId)
- [ ] Next session scheduled (query future `interaction` where contactId matches)
- [ ] "Documentation overdue" badge - If scheduled session has no note within 24h window
  - Calculation: `interaction.endTime < NOW() - INTERVAL '24 hours'` AND no matching note

### Phase 3: Progressive Disclosure & Retrieval (📋 Planned)

#### 3.1 Full Notes Feed

- [ ] Reverse-chronological collapsible sections per date
- [ ] Expand/collapse by date grouping
- [ ] Show note preview (first 100 chars) when collapsed
- [ ] Full rich text when expanded

#### 3.2 Filtering & Search

- [ ] **Filters**:
  - By tag (multi-select chips)
  - By goal (dropdown from contact's goals)
  - By date range (date picker)
  - By source type (typed/voice/upload)
- [ ] **Full-text search** across `contentPlain`
  - PostgreSQL full-text search using tsvector
  - Relevance ranking with `ts_rank`
  - Highlight search terms in results
- [ ] **Smart recall shortcuts** (AI-powered):
  - "Last plan" → Find most recent note with planning keywords
  - "Last breakthrough" → Sentiment analysis for positive progress
  - "Last adverse reaction" → Flag health concern keywords

#### 3.3 Note Deep Links

- [ ] Generate shareable link: `/contacts/[contactId]/notes/[noteId]`
- [ ] Copy link button on each note
- [ ] Use in tasks, messages, internal documentation
- [ ] Permission check: user must own contact to access note

### Phase 4: Lightweight Structure & Actions (📋 Planned)

#### 4.1 Structured Content Blocks (JSONB in contentRich)

Instead of heavy forms, use inline affordances:

```typescript
// Example contentRich structure
{
  "blocks": [
    { "type": "paragraph", "content": "Client reported..." },
    { "type": "decision", "content": "Agreed to try..." },
    { "type": "plan", "content": "Next session: practice breathing..." },
    { "type": "homework", "content": "Client will journal 3x this week" }
  ]
}
```

- [ ] Add block type selector in TipTap editor
- [ ] Custom TipTap extensions for Decision/Plan/Homework blocks
- [ ] Visual distinction (icons, background colors) for block types
- [ ] Extract structured data for reporting (e.g., all "homework" blocks)

#### 4.2 Noted-but-Unscheduled Prompt

When note includes plan/homework without scheduled follow-up:

**Deterministic Logic**:

- Detect keywords in `contentPlain`: "next session", "follow up", "homework", "practice"
- Check if contact has upcoming `calendarEvent` within 14 days
- If NO → Show gentle nudge: "Create task or schedule session?"
- One-click action: Pre-fill task in OmniMomentum or open calendar booking

**Implementation**:

- [ ] Server-side keyword detection after note creation
- [ ] Store `hasUnscheduledAction` boolean flag on note
- [ ] Client-side toast with action buttons
- [ ] Integration with `/api/tasks` and calendar booking flow

### Phase 5: AI Insights Panel (📋 Planned)

#### 5.1 Secondary Sidebar for AI (Collapsed by Default)

- [ ] Suggested next session agenda (from last 1-3 notes)
- [ ] Risk flags with citations to specific note excerpts
- [ ] Adherence/variability summaries (e.g., "Sleep adherence last 4 weeks")
- [ ] Keep separate from human narrative to preserve trust

#### 5.2 AI Input Constraint

- [ ] AI only processes sanitized `contentPlain` (never raw input)
- [ ] Display source note citations for all AI claims
- [ ] "AI-generated" label on all insights
- [ ] Allow practitioner to dismiss/hide insights per contact

### Phase 6: Timeline & Journey View (📋 Planned)

#### 6.1 Stitched Timeline

Overlay notes with:

- Calendar events (`calendarEvents` table)
- Messages/emails (`interactions` table)
- Tasks/actions (`tasks` table / OmniMomentum)

**Visual Timeline**:

- [ ] Vertical timeline with date markers
- [ ] Icons for each event type (note, session, email, task)
- [ ] Hover preview for each item
- [ ] Click to expand full content
- [ ] Filter by event type

---

## Database Schema Enhancements

### Current Schema (✅ Exists)

```sql
CREATE TABLE notes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  contact_id UUID REFERENCES contacts(id),
  content_plain TEXT NOT NULL,
  content_rich JSONB NOT NULL DEFAULT '{}',
  pii_entities JSONB NOT NULL DEFAULT '[]',
  tags TEXT[] NOT NULL DEFAULT '{}',
  source_type note_source_type NOT NULL DEFAULT 'typed',
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### Proposed Additions

#### 1. Note-Goal Junction Table (Phase 2.3)

```sql
-- Already exists: note_goals table
CREATE TABLE note_goals (
  note_id UUID NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
  goal_id UUID NOT NULL REFERENCES goals(id) ON DELETE CASCADE,
  PRIMARY KEY (note_id, goal_id)
);
```

#### 2. Add Metadata Fields to Notes (Phase 4.2)

```sql
ALTER TABLE notes
ADD COLUMN has_unscheduled_action BOOLEAN DEFAULT FALSE,
ADD COLUMN next_step_extracted TEXT,
ADD COLUMN content_blocks JSONB DEFAULT '[]';
```

#### 3. Full-Text Search (Phase 3.2)

```sql
-- Add tsvector column for search
ALTER TABLE notes ADD COLUMN search_vector tsvector;

-- Create index
CREATE INDEX notes_search_idx ON notes USING GIN(search_vector);

-- Auto-update trigger
CREATE TRIGGER notes_search_update BEFORE INSERT OR UPDATE ON notes
FOR EACH ROW EXECUTE FUNCTION
tsvector_update_trigger(search_vector, 'pg_catalog.english', content_plain);
```

---

## API Enhancements

### New Endpoints Needed

#### Phase 2: Fast Capture

```typescript
// Voice transcription
POST /api/notes/transcribe
Body: { audioBlob: Blob, contactId: string }
Response: { text: string, redacted: boolean, piiTypes: string[] }

// OCR upload
POST /api/notes/ocr
Body: { file: File, contactId: string }
Response: { text: string, redacted: boolean, confidence: number }
```

#### Phase 3: Search & Filtering

```typescript
// Full-text search
GET /api/notes/search?q=breathing&contactId=uuid&tags=wellness,yoga&goalId=uuid&from=2024-01-01&to=2024-12-31
Response: { notes: Note[], total: number, highlights: Record<noteId, string[]> }
```

#### Phase 4: Smart Actions

```typescript
// Detect unscheduled actions
POST /api/notes/[noteId]/detect-actions
Response: { hasAction: boolean, keywords: string[], suggestedTask?: string }

// Create task from note
POST /api/notes/[noteId]/create-task
Body: { taskName: string, dueDate?: Date }
Response: { taskId: string }
```

---

## Component Architecture

### Current Components (✅ Implemented)

- `ContactDetailsCard.tsx` - Main contact view with tabs
- `NoteEditor.tsx` - TipTap rich text editor with PII warnings
- `NotesHoverCard.tsx` - Quick note preview in table

### New Components Needed

#### Phase 2

```typescript
// Latest note excerpt component
<LatestNotePreview
  contactId={string}
  note={Note | null}
  onViewFull={() => void}
/>

// Fast capture action bar
<NoteCaptureActions
  contactId={string}
  onType={() => void}
  onVoice={() => void}
  onUpload={() => void}
/>

// Goal picker component
<GoalPicker
  contactId={string}
  selectedGoals={UUID[]}
  onChange={(goals: UUID[]) => void}
/>

// Status indicators
<ContactNoteStatus
  contactId={string}
  lastSessionDate={Date | null}
  nextSessionDate={Date | null}
  hasOverdueDocumentation={boolean}
/>
```

#### Phase 3

```typescript
// Notes feed with grouping
<NotesFeed
  notes={Note[]}
  groupBy="date"
  collapsible={true}
  onNoteClick={(noteId: string) => void}
/>

// Search and filter bar
<NotesSearchBar
  onSearch={(query: string) => void}
  filters={{
    tags: string[],
    goals: UUID[],
    dateRange: [Date, Date],
    sourceType: NoteSourceType[]
  }}
  onFilterChange={(filters) => void}
/>
```

#### Phase 4

```typescript
// Structured content block editor
<StructuredContentEditor
  content={ContentBlock[]}
  onChange={(blocks: ContentBlock[]) => void}
  allowedBlocks={['decision', 'plan', 'homework']}
/>

// Unscheduled action prompt
<UnscheduledActionPrompt
  note={Note}
  onCreateTask={() => void}
  onScheduleSession={() => void}
  onDismiss={() => void}
/>
```

#### Phase 5

```typescript
// AI insights sidebar
<AIInsightsSidebar
  contactId={string}
  collapsed={boolean}
  insights={{
    nextAgenda: string[],
    riskFlags: RiskFlag[],
    adherenceSummary: AdherenceSummary
  }}
  onToggle={() => void}
/>
```

#### Phase 6

```typescript
// Timeline view
<ContactTimeline
  contactId={string}
  events={TimelineEvent[]}
  filters={{
    showNotes: boolean,
    showSessions: boolean,
    showMessages: boolean,
    showTasks: boolean
  }}
  onEventClick={(event: TimelineEvent) => void}
/>
```

---

## Compliance & Safety

### Current Implementation (✅)

- [x] Server-side PII redaction before database write
- [x] Client-side PII warnings (amber banner)
- [x] No content in logs (only metadata)
- [x] RLS on notes table (user_id + contact_id scoping)

### Enhancements Needed

#### C&S Phase 2

- [ ] **Redaction feedback loop**
  - Show "Redacted X items" toast after save
  - One-click pathway: "Add email to contact record instead"
  - Link to EditContactDialog with pre-filled field
- [ ] **Prevent copy/paste detection**
  - Inline detection for common patterns (email@, phone formats)
  - Show hint: "Detected email/phone - use contact fields instead"
  - Don't block, just nudge toward proper fields

#### C&S Phase 3

- [ ] **Configurable redaction patterns**
  - Admin setting: custom regex patterns per tenant
  - Support for local IDs, member numbers, regional formats
  - UI in `/settings/privacy` for pattern management

#### C&S Phase 4

- [ ] **OCR/transcription pipeline safety**
  - Idempotent processing with retry logic
  - Dead-letter queue for failed jobs
  - Delete uploaded files after text extraction
  - Guarantee only sanitized text reaches database

#### Testing

- [ ] Unit tests for PII detector (emails, phones, SSN, addresses across locales)
- [ ] Integration tests for redaction pipeline
- [ ] E2E tests for copy/paste prevention
- [ ] Observability metrics:
  - Redaction event count per tenant
  - Note creation latency (p50, p95, p99)
  - OCR/transcription success rate
  - Voice-to-text accuracy (WER if possible)

---

## Information Architecture

### Contact Card Section Order (Top-Level Tabs)

1. **Notes** (default, primary) - ≥50% of card
2. **Overview** (demographics, consents, key goals)
3. **Journey** (timeline stitching sessions, messages, tasks)
4. **Insights** (AI summaries, risk flags, adherence trends)

### Notes Tab Internal Layout

```bash
┌─────────────────────────────────────────────────┐
│ Latest Note Excerpt (always visible)           │
│ [View Full Note →]                              │
├─────────────────────────────────────────────────┤
│ Fast Capture: [Type] [Voice] [Upload]          │
├─────────────────────────────────────────────────┤
│ Status: Last session 2 days ago | Next: Jan 15 │
│ ⚠️ Documentation overdue for Jan 12 session     │
├─────────────────────────────────────────────────┤
│ ┌─── All Notes (collapsible) ─────────────┐    │
│ │ [Search & Filters]                       │    │
│ │ ┌── Jan 12, 2024 ──────────────────┐    │    │
│ │ │ • Note preview...                 │    │    │
│ │ │ • Note preview...                 │    │    │
│ │ └───────────────────────────────────┘    │    │
│ │ ┌── Jan 5, 2024 ───────────────────┐    │    │
│ │ │ • Note preview...                 │    │    │
│ │ └───────────────────────────────────┘    │    │
│ └──────────────────────────────────────────┘    │
└─────────────────────────────────────────────────┘

┌─── AI Insights (secondary sidebar, collapsed) ──┐
│ [Expand to show agenda, risks, adherence]       │
└──────────────────────────────────────────────────┘
```

---

## Developer Acceptance Criteria

### Phase 2 Completion Criteria

- [ ] Latest note excerpt renders on contact card with timestamp
- [ ] Deep link `/contacts/[contactId]/notes/[noteId]` works with proper auth
- [ ] Voice-to-text captures audio, transcribes, redacts, saves as note
- [ ] Upload→OCR extracts text from photos/PDFs with >80% accuracy
- [ ] Goal picker associates note with 1+ goals via `note_goals` table
- [ ] Status signals show correct last/next session dates
- [ ] "Documentation overdue" badge appears when appropriate
- [ ] All redaction events logged to observability (count only, no content)
- [ ] RLS tests pass: users can only access their own contact's notes
- [ ] Performance: Note creation latency <500ms p95

### Phase 3 Completion Criteria

- [ ] Full-text search returns relevant results with highlighted terms
- [ ] Filters (tag, goal, date, source) narrow results correctly
- [ ] Reverse-chronological feed groups notes by date
- [ ] Expand/collapse date groups works smoothly
- [ ] Deep link copy button works, links are shareable (with auth)
- [ ] PostgreSQL full-text index improves search speed >10x vs LIKE

### Phase 4 Completion Criteria

- [ ] TipTap extensions for Decision/Plan/Homework blocks render correctly
- [ ] Structured blocks extract to `content_blocks` JSONB field
- [ ] Noted-but-unscheduled detection identifies keywords deterministically
- [ ] Toast prompt appears when action detected + no upcoming session
- [ ] One-click task creation from note works via OmniMomentum API
- [ ] Performance: Keyword detection adds <50ms to note save latency

---

## Questions for User

### Immediate Clarifications Needed

1. **Tags Table Purpose**:
   - You mentioned "tags table" - does a `tags` table exist separately from `notes.tags` array?
   - Should tags be normalized (separate table with junction) or keep as array on notes?
   - Current implementation uses `notes.tags` array - is this correct?

2. **Goals Table Relationship**:
   - Confirmed: `note_goals` junction table exists for many-to-many relationship?
   - Goal picker should query `goals WHERE contactId = X AND status != 'abandoned'`?
   - Should we display goal name/description in note UI, or just chips?

3. **Next Steps Storage**:
   - AI insights table has "next steps" - are these different from note-extracted next steps?
   - Should we store "next agreed action" as:
     a) New field `notes.next_step_extracted` (simple text)?
     b) Link to `tasks` table via new `noteId` foreign key?
     c) Store in `ai_insights` table as special insight type?

4. **OmniMomentum Integration**:
   - Confirmed: OmniMomentum = tasks system?
   - API endpoint for creating task from note: `POST /api/tasks` or different?
   - Should task automatically link back to source note (`task.sourceNoteId`)?

5. **Calendar Events Table**:
   - Use `calendar_events` table for "last/next session" calculations?
   - Or should we query `interactions` table for session events?
   - Definition of "session" - specific `event_type` or `business_category`?

6. **Copy/Paste Detection**:
   - Current PII detector runs on `onUpdate` in editor - is this correct for copy/paste?
   - Should we also add `onPaste` event handler with immediate inline warning?
   - "Don't block, just nudge" - correct approach?

---

## Priority Ranking (Your Input Needed)

Which phase should we tackle next?

**Option A: Phase 2 (Fast Capture)** - Voice + OCR + Goal linking

- Highest practitioner value (reduces friction)
- Complex (Whisper API, Tesseract, file handling)
- ~2-3 weeks implementation

**Option B: Phase 3 (Search & Filtering)** - Full-text search + filters

- High retrieval value ("find last plan")
- Medium complexity (PostgreSQL tsvector, filter UI)
- ~1-2 weeks implementation

**Option C: Phase 4 (Structured Blocks)** - Decision/Plan/Homework affordances

- High documentation quality value
- Low complexity (TipTap extensions, JSONB)
- ~1 week implementation

**Option D: Phase 2.1 only (Latest Note Excerpt + Deep Links)** - Quick win

- Medium value (better above-fold experience)
- Low complexity (component + route)
- ~2-3 days implementation

**Recommendation**: Start with **Option D** (latest note excerpt) → validate UX → then Phase 2 (fast capture) for maximum practitioner adoption.

---

## Next Steps

Please confirm:

1. Answers to clarification questions above
2. Priority ranking (which phase to implement next)
3. Any adjustments to proposed architecture
4. Timeline expectations (sprint planning)

Once confirmed, I'll create detailed implementation tasks for the chosen phase.



===== src/server/db/schema.ts =====
// Generated Drizzle schema based on Supabase database structure
// Synced with database.types.ts for complete accuracy

import {
  pgTable,
  uuid,
  text,
  timestamp,
  jsonb,
  boolean,
  integer,
  date,
  inet,
  pgEnum,
  numeric,
  primaryKey,
} from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// Enums from database
export const consentTypeEnum = pgEnum("consent_type", [
  "data_processing",
  "marketing",
  "hipaa",
  "photography",
]);
export const fileTypeEnum = pgEnum("file_type", ["photo", "document", "form"]);
export const providerTypeEnum = pgEnum("provider_type", ["gmail", "calendar", "drive", "upload"]);
export const goalStatusEnum = pgEnum("goal_status", [
  "on_track",
  "at_risk",
  "achieved",
  "abandoned",
]);
export const goalTypeEnum = pgEnum("goal_type", [
  "practitioner_business",
  "practitioner_personal",
  "client_wellness",
]);
export const noteSourceTypeEnum = pgEnum("note_source_type", ["typed", "voice", "upload"]);
export const inboxItemStatusEnum = pgEnum("inbox_item_status", [
  "unprocessed",
  "processed",
  "archived",
]);
export const projectStatusEnum = pgEnum("project_status", [
  "active",
  "on_hold",
  "completed",
  "archived",
]);
export const taskPriorityEnum = pgEnum("task_priority", ["low", "medium", "high", "urgent"]);
export const taskStatusEnum = pgEnum("task_status", ["todo", "in_progress", "done", "canceled"]);

// ============================================================================
// CRM - Customer Relationship Management
// ============================================================================

// Client Tables
export const clientConsents = pgTable("client_consents", {
  id: uuid("id").primaryKey().defaultRandom(),
  contactId: uuid("contact_id")
    .notNull()
    .references(() => contacts.id),
  userId: uuid("user_id").notNull(),
  consentType: consentTypeEnum("consent_type").notNull(),
  consentTextVersion: text("consent_text_version").notNull(),
  granted: boolean("granted").default(true),
  grantedAt: timestamp("granted_at", { withTimezone: true }).defaultNow(),
  ipAddress: inet("ip_address"),
  userAgent: text("user_agent"),
  signatureSvg: text("signature_svg"),
  signatureImageUrl: text("signature_image_url"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
});

export const clientFiles = pgTable("client_files", {
  id: uuid("id").primaryKey().defaultRandom(),
  contactId: uuid("contact_id")
    .notNull()
    .references(() => contacts.id),
  userId: uuid("user_id").notNull(),
  fileType: fileTypeEnum("file_type").notNull(),
  filePath: text("file_path").notNull(),
  mimeType: text("mime_type"),
  fileSize: integer("file_size"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

// Contact Tables
export const contacts = pgTable("contacts", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  displayName: text("display_name").notNull(),
  primaryEmail: text("primary_email"),
  primaryPhone: text("primary_phone"),
  photoUrl: text("photo_url"),
  source: text("source"),
  lifecycleStage: text("lifecycle_stage"),
  clientStatus: text("client_status"),
  referralSource: text("referral_source"),
  confidenceScore: text("confidence_score"),
  dateOfBirth: date("date_of_birth"),
  emergencyContactName: text("emergency_contact_name"),
  emergencyContactPhone: text("emergency_contact_phone"),
  address: jsonb("address"),
  healthContext: jsonb("health_context"),
  preferences: jsonb("preferences"),
  tags: jsonb("tags"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
});

export const notes = pgTable("notes", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  contactId: uuid("contact_id").references(() => contacts.id),
  contentRich: jsonb("content_rich").notNull().default({}),
  contentPlain: text("content_plain").notNull().default(""),
  piiEntities: jsonb("pii_entities").notNull().default([]),
  tags: text("tags").array().notNull().default([]),
  sourceType: noteSourceTypeEnum("source_type").notNull().default("typed"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow().notNull(),
});

export const photoAccessAudit = pgTable("photo_access_audit", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  contactId: uuid("contact_id").notNull(),
  photoPath: text("photo_path").notNull(),
  accessedAt: timestamp("accessed_at", { withTimezone: true }).defaultNow(),
  ipAddress: inet("ip_address"),
  userAgent: text("user_agent"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const onboardingTokens = pgTable("onboarding_tokens", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  token: text("token").notNull().unique(),
  label: text("label"),
  expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(),
  maxUses: integer("max_uses").default(1).notNull(),
  usedCount: integer("used_count").default(0).notNull(),
  createdBy: uuid("created_by").notNull(),
  disabled: boolean("disabled").default(false).notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow().notNull(),
});

// ============================================================================
// PRODUCTIVITY SUITE - Tasks, Goals, Projects
// ============================================================================

// Core Tables
export const dailyPulseLogs = pgTable("daily_pulse_logs", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  logDate: date("log_date").notNull(),
  details: jsonb("details"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const noteGoals = pgTable(
  "note_goals",
  {
    noteId: uuid("note_id")
      .notNull()
      .references(() => notes.id, { onDelete: "cascade" }),
    goalId: uuid("goal_id")
      .notNull()
      .references(() => goals.id, { onDelete: "cascade" }),
  },
  (table) => ({
    pk: primaryKey({ columns: [table.noteId, table.goalId] }),
  }),
);

export const goals = pgTable("goals", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  contactId: uuid("contact_id").references(() => contacts.id),
  name: text("name").notNull(),
  goalType: goalTypeEnum("goal_type").notNull(),
  status: goalStatusEnum("status").default("on_track").notNull(),
  targetDate: date("target_date"),
  details: jsonb("details"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
});

export const inboxItems = pgTable("inbox_items", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  rawText: text("raw_text").notNull(),
  status: inboxItemStatusEnum("status").default("unprocessed").notNull(),
  processedAt: timestamp("processed_at", { withTimezone: true }),
  createdTaskId: uuid("created_task_id"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
});

export const projects = pgTable("projects", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  name: text("name").notNull(),
  status: projectStatusEnum("status").default("active").notNull(),
  dueDate: date("due_date"),
  details: jsonb("details"),
  zoneId: integer("zone_id").references(() => zones.id),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
});

// Self-referential table: tasks can have parent tasks
// TypeScript can't infer the type correctly due to circular reference
// @ts-expect-error - TS7022: Self-referential table definition
export const tasks = pgTable("tasks", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  projectId: uuid("project_id").references(() => projects.id),
  // @ts-expect-error - TS7024: Self-referential foreign key
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access
  parentTaskId: uuid("parent_task_id").references(() => tasks.id),
  name: text("name").notNull(),
  status: taskStatusEnum("status").default("todo").notNull(),
  priority: taskPriorityEnum("priority").default("medium").notNull(),
  dueDate: date("due_date"),
  details: jsonb("details"),
  completedAt: timestamp("completed_at", { withTimezone: true }),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
});

export const taskContactTags = pgTable(
  "task_contact_tags",
  {
    taskId: uuid("task_id")
      .notNull()
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access
      .references(() => tasks.id),
    contactId: uuid("contact_id")
      .notNull()
      .references(() => contacts.id),
  },
  (t) => ({
    pk: primaryKey({ columns: [t.taskId, t.contactId] }),
  }),
);

export const zones = pgTable("zones", {
  id: integer("id").primaryKey(),
  name: text("name").notNull(),
  color: text("color"),
  iconName: text("icon_name"),
});

// ============================================================================
// DATA INTELLIGENCE - Raw Events, Interactions, AI Insights
// ============================================================================

export const aiInsights = pgTable("ai_insights", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  subjectType: text("subject_type").notNull(),
  subjectId: uuid("subject_id"),
  kind: text("kind").notNull(),
  content: jsonb("content").notNull(),
  model: text("model"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  fingerprint: text("fingerprint"),
});

export const contactIdentities = pgTable("contact_identities", {
  id: uuid("id").primaryKey().defaultRandom(),
  contactId: uuid("contact_id")
    .notNull()
    .references(() => contacts.id),
  userId: uuid("user_id").notNull(),
  kind: text("kind").notNull(),
  provider: text("provider"),
  value: text("value").notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const embeddings = pgTable("embeddings", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  ownerType: text("owner_type").notNull(),
  ownerId: uuid("owner_id").notNull(),
  embedding: text("embedding"),
  embeddingV: text("embedding_v"),
  contentHash: text("content_hash"),
  chunkIndex: integer("chunk_index"),
  meta: jsonb("meta"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const documents = pgTable("documents", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  ownerContactId: uuid("owner_contact_id"),
  title: text("title"),
  text: text("text"),
  mime: text("mime"),
  meta: jsonb("meta"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const ignoredIdentifiers = pgTable("ignored_identifiers", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  kind: text("kind").notNull(),
  value: text("value").notNull(),
  reason: text("reason"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const interactions = pgTable("interactions", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  contactId: uuid("contact_id")
    .notNull()
    .references(() => contacts.id, { onDelete: "cascade" }),
  type: text("type").notNull(),
  subject: text("subject"),
  bodyText: text("body_text"),
  occurredAt: timestamp("occurred_at", { withTimezone: true }).notNull(),
  source: text("source"),
  sourceId: text("source_id").notNull(),
  sourceMeta: jsonb("source_meta"),
  batchId: uuid("batch_id"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const rawEvents = pgTable("raw_events", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  provider: providerTypeEnum("provider").notNull(),
  payload: jsonb("payload").notNull(),
  occurredAt: timestamp("occurred_at", { withTimezone: true }).notNull(),
  sourceId: text("source_id").notNull(),
  sourceMeta: jsonb("source_meta"),
  batchId: uuid("batch_id"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  // Processing state columns (added in migration 40)
  processingStatus: text("processing_status").default("pending"),
  processingAttempts: integer("processing_attempts").default(0),
  processingError: text("processing_error"),
  processedAt: timestamp("processed_at", { withTimezone: true }),
  // Contact extraction workflow (added in migration 46, enhanced in 50)
  contactExtractionStatus: text("contact_extraction_status"),
  extractedAt: timestamp("extracted_at", { withTimezone: true }),
});

// ============================================================================
// ADMIN - User Management, Jobs, Quotas
// ============================================================================

// User Tables
export const userIntegrations = pgTable(
  "user_integrations",
  {
    userId: uuid("user_id").notNull(),
    provider: text("provider").notNull(),
    service: text("service").notNull(),
    accessToken: text("access_token").notNull(),
    refreshToken: text("refresh_token"),
    expiryDate: timestamp("expiry_date", { withTimezone: true }),
    config: jsonb("config"),
    createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
    updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
  },
  (t) => ({
    pk: primaryKey({ columns: [t.userId, t.provider, t.service] }),
  }),
);

export const aiQuotas = pgTable("ai_quotas", {
  userId: uuid("user_id").primaryKey().notNull(),
  creditsLeft: integer("credits_left").notNull(),
  periodStart: timestamp("period_start", { withTimezone: true }).notNull(),
});

export const aiUsage = pgTable("ai_usage", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  model: text("model").notNull(),
  inputTokens: integer("input_tokens").default(0),
  outputTokens: integer("output_tokens").default(0),
  costUsd: numeric("cost_usd").default("0"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const jobs = pgTable("jobs", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  kind: text("kind").notNull(),
  payload: jsonb("payload"),
  status: text("status").default("queued").notNull(),
  attempts: integer("attempts").default(0).notNull(),
  lastError: text("last_error"),
  result: jsonb("result"),
  batchId: uuid("batch_id"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
});

// ============================================================================
// AI CHAT - Threads, Messages, Tool Invocations
// ============================================================================

export const messages = pgTable("messages", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  threadId: uuid("thread_id")
    .notNull()
    .references(() => threads.id),
  role: text("role").notNull(),
  content: jsonb("content").notNull(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const threads = pgTable("threads", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  title: text("title"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
});

export const toolInvocations = pgTable("tool_invocations", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull(),
  messageId: uuid("message_id")
    .notNull()
    .references(() => messages.id),
  tool: text("tool").notNull(),
  args: jsonb("args").notNull(),
  result: jsonb("result"),
  latencyMs: integer("latency_ms"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

// ============================================================================
// RELATIONS - Inferred from Foreign Keys
// ============================================================================

export const clientConsentsRelations = relations(clientConsents, ({ one }) => ({
  contact: one(contacts, {
    fields: [clientConsents.contactId],
    references: [contacts.id],
  }),
}));

export const clientFilesRelations = relations(clientFiles, ({ one }) => ({
  contact: one(contacts, {
    fields: [clientFiles.contactId],
    references: [contacts.id],
  }),
}));

export const contactIdentitiesRelations = relations(contactIdentities, ({ one }) => ({
  contact: one(contacts, {
    fields: [contactIdentities.contactId],
    references: [contacts.id],
  }),
}));

export const goalsRelations = relations(goals, ({ one }) => ({
  contact: one(contacts, {
    fields: [goals.contactId],
    references: [contacts.id],
  }),
}));

export const interactionsRelations = relations(interactions, ({ one }) => ({
  contact: one(contacts, {
    fields: [interactions.contactId],
    references: [contacts.id],
  }),
}));

export const messagesRelations = relations(messages, ({ one }) => ({
  thread: one(threads, {
    fields: [messages.threadId],
    references: [threads.id],
  }),
}));

export const notesRelations = relations(notes, ({ one, many }) => ({
  contact: one(contacts, {
    fields: [notes.contactId],
    references: [contacts.id],
  }),
  noteGoals: many(noteGoals),
}));

export const noteGoalsRelations = relations(noteGoals, ({ one }) => ({
  note: one(notes, {
    fields: [noteGoals.noteId],
    references: [notes.id],
  }),
  goal: one(goals, {
    fields: [noteGoals.goalId],
    references: [goals.id],
  }),
}));

export const projectsRelations = relations(projects, ({ one }) => ({
  zone: one(zones, {
    fields: [projects.zoneId],
    references: [zones.id],
  }),
}));

// Raw events no longer have direct contact relations - contact linking happens in interactions table

export const taskContactTagsRelations = relations(taskContactTags, ({ one }) => ({
  task: one(tasks, {
    fields: [taskContactTags.taskId],
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
    references: [tasks.id],
  }),
  contact: one(contacts, {
    fields: [taskContactTags.contactId],
    references: [contacts.id],
  }),
}));

export const tasksRelations = relations(tasks, ({ one }) => ({
  project: one(projects, {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    fields: [tasks.projectId],
    references: [projects.id],
  }),
  parentTask: one(tasks, {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    fields: [tasks.parentTaskId],
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
    references: [tasks.id],
  }),
}));

export const toolInvocationsRelations = relations(toolInvocations, ({ one }) => ({
  message: one(messages, {
    fields: [toolInvocations.messageId],
    references: [messages.id],
  }),
}));

// ============================================================================
// TYPE EXPORTS - Inferred from Drizzle Schema
// ============================================================================

// Core entity types inferred from Drizzle schema
export type Contact = typeof contacts.$inferSelect;
export type CreateContact = typeof contacts.$inferInsert;
export type UpdateContact = Partial<CreateContact>;

export type Note = typeof notes.$inferSelect;
export type CreateNote = typeof notes.$inferInsert;
export type UpdateNote = Partial<CreateNote>;

export type NoteGoal = typeof noteGoals.$inferSelect;
export type CreateNoteGoal = typeof noteGoals.$inferInsert;

export type Interaction = typeof interactions.$inferSelect;
export type CreateInteraction = typeof interactions.$inferInsert;
export type UpdateInteraction = Partial<CreateInteraction>;

export type Task = typeof tasks.$inferSelect;
export type CreateTask = typeof tasks.$inferInsert;
export type UpdateTask = Partial<CreateTask>;

export type Project = typeof projects.$inferSelect;
export type CreateProject = typeof projects.$inferInsert;
export type UpdateProject = Partial<CreateProject>;

export type Zone = typeof zones.$inferSelect;
export type CreateZone = typeof zones.$inferInsert;
export type UpdateZone = Partial<CreateZone>;

export type AiInsight = typeof aiInsights.$inferSelect;
export type CreateAiInsight = typeof aiInsights.$inferInsert;
export type UpdateAiInsight = Partial<CreateAiInsight>;

export type Job = typeof jobs.$inferSelect;
export type CreateJob = typeof jobs.$inferInsert;

export type UserIntegration = typeof userIntegrations.$inferSelect;
export type CreateUserIntegration = typeof userIntegrations.$inferInsert;

export type InboxItem = typeof inboxItems.$inferSelect;
export type CreateInboxItem = typeof inboxItems.$inferInsert;
export type UpdateInboxItem = Partial<CreateInboxItem>;

export type Goal = typeof goals.$inferSelect;
export type CreateGoal = typeof goals.$inferInsert;

export type DailyPulseLog = typeof dailyPulseLogs.$inferSelect;
export type CreateDailyPulseLog = typeof dailyPulseLogs.$inferInsert;

export type RawEvent = typeof rawEvents.$inferSelect;
export type CreateRawEvent = typeof rawEvents.$inferInsert;
export type UpdateRawEvent = Partial<CreateRawEvent>;

export type IgnoredIdentifier = typeof ignoredIdentifiers.$inferSelect;
export type CreateIgnoredIdentifier = typeof ignoredIdentifiers.$inferInsert;
export type UpdateIgnoredIdentifier = Partial<CreateIgnoredIdentifier>;

export type ContactIdentity = typeof contactIdentities.$inferSelect;
export type CreateContactIdentity = typeof contactIdentities.$inferInsert;
export type UpdateContactIdentity = Partial<CreateContactIdentity>;

export type Embedding = typeof embeddings.$inferSelect;
export type CreateEmbedding = typeof embeddings.$inferInsert;
export type UpdateEmbedding = Partial<CreateEmbedding>;

export type IntelligenceDocument = typeof documents.$inferSelect;
export type CreateIntelligenceDocument = typeof documents.$inferInsert;
export type UpdateIntelligenceDocument = Partial<CreateIntelligenceDocument>;

export type Thread = typeof threads.$inferSelect;
export type CreateThread = typeof threads.$inferInsert;
export type UpdateThread = Partial<CreateThread>;

export type Message = typeof messages.$inferSelect;
export type CreateMessage = typeof messages.$inferInsert;
export type UpdateMessage = Partial<CreateMessage>;

export type ToolInvocation = typeof toolInvocations.$inferSelect;
export type CreateToolInvocation = typeof toolInvocations.$inferInsert;
export type UpdateToolInvocation = Partial<CreateToolInvocation>;

// Extended types for common patterns
export type ContactWithNotes = Contact & { notes: Note[] };
export type ThreadWithMessages = Thread & { messages: Message[] };
export type MessageWithTools = Message & { toolInvocations: ToolInvocation[] };



===== src/server/db/business-schemas/notes.ts =====
/**
 * Notes Business Schemas
 *
 * For base types, import from @/server/db/schema:
 * - Note (select type)
 * - CreateNote (insert type)
 * - UpdateNote (partial insert type)
 *
 * This file contains ONLY API-specific schemas for note operations.
 * 
 * Updated for new Notes spec:
 * - content_rich (TipTap JSON)
 * - content_plain (redacted text for search/AI)
 * - pii_entities (redaction metadata)
 * - tags (text array)
 * - source_type (typed | voice | upload)
 */

import { z } from "zod";

// Re-export base types from schema for convenience
export type { Note, CreateNote, UpdateNote } from "@/server/db/schema";

// ============================================================================
// API-SPECIFIC SCHEMAS
// ============================================================================

/**
 * Note Source Type Enum
 */
export const NoteSourceTypeSchema = z.enum(["typed", "voice", "upload"]);
export type NoteSourceType = z.infer<typeof NoteSourceTypeSchema>;

/**
 * Create Note Body Schema - for API input validation
 * Accepts either plain text or rich content
 */
export const CreateNoteBodySchema = z.object({
  contentPlain: z.string().min(1, "Note content is required"),
  contentRich: z.record(z.string(), z.unknown()).optional(), // TipTap JSON (optional, can be derived)
  tags: z.array(z.string()).optional().default([]),
  goalIds: z.array(z.string().uuid()).optional(),
  sourceType: NoteSourceTypeSchema.optional().default("typed"),
  contactId: z.string().uuid().optional(),
});


/**
 * Update Note Schema
 */
export const UpdateNoteBodySchema = z.object({
  contentPlain: z.string().min(1).optional(),
  contentRich: z.record(z.string(), z.unknown()).optional(),
  tags: z.array(z.string()).optional(),
  goalIds: z.array(z.string().uuid()).optional(),
});


/**
 * Notes List Response Schema
 */
export const NotesListResponseSchema = z.object({
  notes: z.array(z.unknown()), // Will be validated as Note[] at runtime
  total: z.number(),
});

export type NotesListResponse = z.infer<typeof NotesListResponseSchema>;

// ============================================================================
// QUERY SCHEMAS
// ============================================================================

/**
 * Get Notes Query Schema
 */
export const GetNotesQuerySchema = z.object({
  contactId: z.string().uuid().optional(),
  search: z.string().optional(),
  limit: z.coerce.number().int().min(1).max(100).default(50),
  offset: z.coerce.number().int().min(0).default(0),
});




===== src/server/db/database.types.ts =====
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  // Allows to automatically instantiate createClient with right options
  // instead of createClient<Database, { PostgrestVersion: 'XX' }>(URL, KEY)
  __InternalSupabase: {
    PostgrestVersion: "13.0.5"
  }
  graphql_public: {
    Tables: {
      [_ in never]: never
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      graphql: {
        Args: {
          extensions?: Json
          operationName?: string
          query?: string
          variables?: Json
        }
        Returns: Json
      }
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
  public: {
    Tables: {
      ai_insights: {
        Row: {
          content: Json
          created_at: string
          fingerprint: string | null
          id: string
          kind: string
          model: string | null
          subject_id: string | null
          subject_type: string
          user_id: string
        }
        Insert: {
          content: Json
          created_at?: string
          fingerprint?: string | null
          id?: string
          kind: string
          model?: string | null
          subject_id?: string | null
          subject_type: string
          user_id: string
        }
        Update: {
          content?: Json
          created_at?: string
          fingerprint?: string | null
          id?: string
          kind?: string
          model?: string | null
          subject_id?: string | null
          subject_type?: string
          user_id?: string
        }
        Relationships: []
      }
      ai_quotas: {
        Row: {
          credits_left: number
          period_start: string
          user_id: string
        }
        Insert: {
          credits_left: number
          period_start: string
          user_id: string
        }
        Update: {
          credits_left?: number
          period_start?: string
          user_id?: string
        }
        Relationships: []
      }
      ai_usage: {
        Row: {
          cost_usd: number
          created_at: string
          id: string
          input_tokens: number
          model: string
          output_tokens: number
          user_id: string
        }
        Insert: {
          cost_usd?: number
          created_at?: string
          id?: string
          input_tokens?: number
          model: string
          output_tokens?: number
          user_id: string
        }
        Update: {
          cost_usd?: number
          created_at?: string
          id?: string
          input_tokens?: number
          model?: string
          output_tokens?: number
          user_id?: string
        }
        Relationships: []
      }
      client_consents: {
        Row: {
          consent_text_version: string
          consent_type: Database["public"]["Enums"]["consent_type"]
          contact_id: string
          created_at: string
          granted: boolean
          granted_at: string
          id: string
          ip_address: unknown | null
          signature_image_url: string | null
          signature_svg: string | null
          updated_at: string
          user_agent: string | null
          user_id: string
        }
        Insert: {
          consent_text_version: string
          consent_type: Database["public"]["Enums"]["consent_type"]
          contact_id: string
          created_at?: string
          granted?: boolean
          granted_at?: string
          id?: string
          ip_address?: unknown | null
          signature_image_url?: string | null
          signature_svg?: string | null
          updated_at?: string
          user_agent?: string | null
          user_id: string
        }
        Update: {
          consent_text_version?: string
          consent_type?: Database["public"]["Enums"]["consent_type"]
          contact_id?: string
          created_at?: string
          granted?: boolean
          granted_at?: string
          id?: string
          ip_address?: unknown | null
          signature_image_url?: string | null
          signature_svg?: string | null
          updated_at?: string
          user_agent?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "client_consents_contact_id_fkey"
            columns: ["contact_id"]
            isOneToOne: false
            referencedRelation: "contacts"
            referencedColumns: ["id"]
          },
        ]
      }
      client_files: {
        Row: {
          contact_id: string
          created_at: string
          file_path: string
          file_size: number | null
          file_type: Database["public"]["Enums"]["file_type"]
          id: string
          mime_type: string | null
          user_id: string
        }
        Insert: {
          contact_id: string
          created_at?: string
          file_path: string
          file_size?: number | null
          file_type?: Database["public"]["Enums"]["file_type"]
          id?: string
          mime_type?: string | null
          user_id: string
        }
        Update: {
          contact_id?: string
          created_at?: string
          file_path?: string
          file_size?: number | null
          file_type?: Database["public"]["Enums"]["file_type"]
          id?: string
          mime_type?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "client_files_contact_id_fkey"
            columns: ["contact_id"]
            isOneToOne: false
            referencedRelation: "contacts"
            referencedColumns: ["id"]
          },
        ]
      }
      contact_identities: {
        Row: {
          contact_id: string
          created_at: string
          id: string
          kind: string
          provider: string | null
          user_id: string
          value: string
        }
        Insert: {
          contact_id: string
          created_at?: string
          id?: string
          kind: string
          provider?: string | null
          user_id: string
          value: string
        }
        Update: {
          contact_id?: string
          created_at?: string
          id?: string
          kind?: string
          provider?: string | null
          user_id?: string
          value?: string
        }
        Relationships: [
          {
            foreignKeyName: "contact_identities_contact_id_fkey"
            columns: ["contact_id"]
            isOneToOne: false
            referencedRelation: "contacts"
            referencedColumns: ["id"]
          },
        ]
      }
      contacts: {
        Row: {
          address: Json | null
          client_status: string | null
          confidence_score: string | null
          created_at: string
          date_of_birth: string | null
          display_name: string
          emergency_contact_name: string | null
          emergency_contact_phone: string | null
          health_context: Json | null
          id: string
          lifecycle_stage: string | null
          photo_url: string | null
          preferences: Json | null
          primary_email: string | null
          primary_phone: string | null
          referral_source: string | null
          source: string | null
          tags: Json | null
          updated_at: string
          user_id: string
        }
        Insert: {
          address?: Json | null
          client_status?: string | null
          confidence_score?: string | null
          created_at?: string
          date_of_birth?: string | null
          display_name: string
          emergency_contact_name?: string | null
          emergency_contact_phone?: string | null
          health_context?: Json | null
          id?: string
          lifecycle_stage?: string | null
          photo_url?: string | null
          preferences?: Json | null
          primary_email?: string | null
          primary_phone?: string | null
          referral_source?: string | null
          source?: string | null
          tags?: Json | null
          updated_at?: string
          user_id: string
        }
        Update: {
          address?: Json | null
          client_status?: string | null
          confidence_score?: string | null
          created_at?: string
          date_of_birth?: string | null
          display_name?: string
          emergency_contact_name?: string | null
          emergency_contact_phone?: string | null
          health_context?: Json | null
          id?: string
          lifecycle_stage?: string | null
          photo_url?: string | null
          preferences?: Json | null
          primary_email?: string | null
          primary_phone?: string | null
          referral_source?: string | null
          source?: string | null
          tags?: Json | null
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      daily_pulse_logs: {
        Row: {
          created_at: string
          details: Json | null
          id: string
          log_date: string
          user_id: string
        }
        Insert: {
          created_at?: string
          details?: Json | null
          id?: string
          log_date: string
          user_id: string
        }
        Update: {
          created_at?: string
          details?: Json | null
          id?: string
          log_date?: string
          user_id?: string
        }
        Relationships: []
      }
      documents: {
        Row: {
          created_at: string
          id: string
          meta: Json | null
          mime: string | null
          owner_contact_id: string | null
          text: string | null
          title: string | null
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          meta?: Json | null
          mime?: string | null
          owner_contact_id?: string | null
          text?: string | null
          title?: string | null
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          meta?: Json | null
          mime?: string | null
          owner_contact_id?: string | null
          text?: string | null
          title?: string | null
          user_id?: string
        }
        Relationships: []
      }
      embeddings: {
        Row: {
          chunk_index: number | null
          content_hash: string | null
          created_at: string
          embedding: string | null
          embedding_v: string | null
          id: string
          meta: Json | null
          owner_id: string
          owner_type: string
          user_id: string
        }
        Insert: {
          chunk_index?: number | null
          content_hash?: string | null
          created_at?: string
          embedding?: string | null
          embedding_v?: string | null
          id?: string
          meta?: Json | null
          owner_id: string
          owner_type: string
          user_id: string
        }
        Update: {
          chunk_index?: number | null
          content_hash?: string | null
          created_at?: string
          embedding?: string | null
          embedding_v?: string | null
          id?: string
          meta?: Json | null
          owner_id?: string
          owner_type?: string
          user_id?: string
        }
        Relationships: []
      }
      goals: {
        Row: {
          contact_id: string | null
          created_at: string
          details: Json | null
          goal_type: Database["public"]["Enums"]["goal_type"]
          id: string
          name: string
          status: Database["public"]["Enums"]["goal_status"]
          target_date: string | null
          updated_at: string
          user_id: string
        }
        Insert: {
          contact_id?: string | null
          created_at?: string
          details?: Json | null
          goal_type: Database["public"]["Enums"]["goal_type"]
          id?: string
          name: string
          status?: Database["public"]["Enums"]["goal_status"]
          target_date?: string | null
          updated_at?: string
          user_id: string
        }
        Update: {
          contact_id?: string | null
          created_at?: string
          details?: Json | null
          goal_type?: Database["public"]["Enums"]["goal_type"]
          id?: string
          name?: string
          status?: Database["public"]["Enums"]["goal_status"]
          target_date?: string | null
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "goals_contact_id_fkey"
            columns: ["contact_id"]
            isOneToOne: false
            referencedRelation: "contacts"
            referencedColumns: ["id"]
          },
        ]
      }
      ignored_identifiers: {
        Row: {
          created_at: string
          id: string
          kind: string
          reason: string | null
          user_id: string
          value: string
        }
        Insert: {
          created_at?: string
          id?: string
          kind: string
          reason?: string | null
          user_id: string
          value: string
        }
        Update: {
          created_at?: string
          id?: string
          kind?: string
          reason?: string | null
          user_id?: string
          value?: string
        }
        Relationships: []
      }
      inbox_items: {
        Row: {
          created_at: string
          created_task_id: string | null
          id: string
          processed_at: string | null
          raw_text: string
          status: Database["public"]["Enums"]["inbox_item_status"]
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          created_task_id?: string | null
          id?: string
          processed_at?: string | null
          raw_text: string
          status?: Database["public"]["Enums"]["inbox_item_status"]
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          created_task_id?: string | null
          id?: string
          processed_at?: string | null
          raw_text?: string
          status?: Database["public"]["Enums"]["inbox_item_status"]
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      interactions: {
        Row: {
          batch_id: string | null
          body_text: string | null
          contact_id: string
          created_at: string
          id: string
          occurred_at: string
          source: string | null
          source_id: string
          source_meta: Json | null
          subject: string | null
          type: string
          user_id: string
        }
        Insert: {
          batch_id?: string | null
          body_text?: string | null
          contact_id: string
          created_at?: string
          id?: string
          occurred_at: string
          source?: string | null
          source_id: string
          source_meta?: Json | null
          subject?: string | null
          type: string
          user_id: string
        }
        Update: {
          batch_id?: string | null
          body_text?: string | null
          contact_id?: string
          created_at?: string
          id?: string
          occurred_at?: string
          source?: string | null
          source_id?: string
          source_meta?: Json | null
          subject?: string | null
          type?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "interactions_contact_id_fkey"
            columns: ["contact_id"]
            isOneToOne: false
            referencedRelation: "contacts"
            referencedColumns: ["id"]
          },
        ]
      }
      jobs: {
        Row: {
          attempts: number
          batch_id: string | null
          created_at: string
          id: string
          kind: string
          last_error: string | null
          payload: Json | null
          result: Json | null
          status: string
          updated_at: string
          user_id: string
        }
        Insert: {
          attempts?: number
          batch_id?: string | null
          created_at?: string
          id?: string
          kind: string
          last_error?: string | null
          payload?: Json | null
          result?: Json | null
          status?: string
          updated_at?: string
          user_id: string
        }
        Update: {
          attempts?: number
          batch_id?: string | null
          created_at?: string
          id?: string
          kind?: string
          last_error?: string | null
          payload?: Json | null
          result?: Json | null
          status?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      messages: {
        Row: {
          content: Json
          created_at: string
          id: string
          role: string
          thread_id: string
          user_id: string
        }
        Insert: {
          content: Json
          created_at?: string
          id?: string
          role: string
          thread_id: string
          user_id: string
        }
        Update: {
          content?: Json
          created_at?: string
          id?: string
          role?: string
          thread_id?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "messages_thread_id_fkey"
            columns: ["thread_id"]
            isOneToOne: false
            referencedRelation: "threads"
            referencedColumns: ["id"]
          },
        ]
      }
      note_goals: {
        Row: {
          goal_id: string
          note_id: string
        }
        Insert: {
          goal_id: string
          note_id: string
        }
        Update: {
          goal_id?: string
          note_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "note_goals_goal_id_fkey"
            columns: ["goal_id"]
            isOneToOne: false
            referencedRelation: "goals"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "note_goals_note_id_fkey"
            columns: ["note_id"]
            isOneToOne: false
            referencedRelation: "notes"
            referencedColumns: ["id"]
          },
        ]
      }
      notes: {
        Row: {
          contact_id: string | null
          content_plain: string
          content_rich: Json
          created_at: string
          id: string
          pii_entities: Json
          source_type: Database["public"]["Enums"]["note_source_type"]
          tags: string[]
          updated_at: string
          user_id: string
        }
        Insert: {
          contact_id?: string | null
          content_plain?: string
          content_rich?: Json
          created_at?: string
          id?: string
          pii_entities?: Json
          source_type?: Database["public"]["Enums"]["note_source_type"]
          tags?: string[]
          updated_at?: string
          user_id: string
        }
        Update: {
          contact_id?: string | null
          content_plain?: string
          content_rich?: Json
          created_at?: string
          id?: string
          pii_entities?: Json
          source_type?: Database["public"]["Enums"]["note_source_type"]
          tags?: string[]
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "notes_contact_id_fkey"
            columns: ["contact_id"]
            isOneToOne: false
            referencedRelation: "contacts"
            referencedColumns: ["id"]
          },
        ]
      }
      onboarding_tokens: {
        Row: {
          created_at: string
          created_by: string
          disabled: boolean
          expires_at: string
          id: string
          label: string | null
          max_uses: number
          token: string
          used_count: number
          user_id: string
        }
        Insert: {
          created_at?: string
          created_by: string
          disabled?: boolean
          expires_at: string
          id?: string
          label?: string | null
          max_uses?: number
          token: string
          used_count?: number
          user_id: string
        }
        Update: {
          created_at?: string
          created_by?: string
          disabled?: boolean
          expires_at?: string
          id?: string
          label?: string | null
          max_uses?: number
          token?: string
          used_count?: number
          user_id?: string
        }
        Relationships: []
      }
      photo_access_audit: {
        Row: {
          accessed_at: string
          contact_id: string
          created_at: string | null
          id: string
          ip_address: unknown | null
          photo_path: string
          user_agent: string | null
          user_id: string
        }
        Insert: {
          accessed_at?: string
          contact_id: string
          created_at?: string | null
          id?: string
          ip_address?: unknown | null
          photo_path: string
          user_agent?: string | null
          user_id: string
        }
        Update: {
          accessed_at?: string
          contact_id?: string
          created_at?: string | null
          id?: string
          ip_address?: unknown | null
          photo_path?: string
          user_agent?: string | null
          user_id?: string
        }
        Relationships: []
      }
      projects: {
        Row: {
          created_at: string
          details: Json | null
          due_date: string | null
          id: string
          name: string
          status: Database["public"]["Enums"]["project_status"]
          updated_at: string
          user_id: string
          zone_id: number | null
        }
        Insert: {
          created_at?: string
          details?: Json | null
          due_date?: string | null
          id?: string
          name: string
          status?: Database["public"]["Enums"]["project_status"]
          updated_at?: string
          user_id: string
          zone_id?: number | null
        }
        Update: {
          created_at?: string
          details?: Json | null
          due_date?: string | null
          id?: string
          name?: string
          status?: Database["public"]["Enums"]["project_status"]
          updated_at?: string
          user_id?: string
          zone_id?: number | null
        }
        Relationships: [
          {
            foreignKeyName: "projects_zone_id_fkey"
            columns: ["zone_id"]
            isOneToOne: false
            referencedRelation: "zones"
            referencedColumns: ["id"]
          },
        ]
      }
      raw_events: {
        Row: {
          batch_id: string | null
          contact_extraction_status: string | null
          created_at: string
          extracted_at: string | null
          id: string
          occurred_at: string
          payload: Json
          processed_at: string | null
          processing_attempts: number | null
          processing_error: string | null
          processing_status: string | null
          provider: Database["public"]["Enums"]["provider_type"]
          source_id: string
          source_meta: Json | null
          user_id: string
        }
        Insert: {
          batch_id?: string | null
          contact_extraction_status?: string | null
          created_at?: string
          extracted_at?: string | null
          id?: string
          occurred_at: string
          payload: Json
          processed_at?: string | null
          processing_attempts?: number | null
          processing_error?: string | null
          processing_status?: string | null
          provider: Database["public"]["Enums"]["provider_type"]
          source_id: string
          source_meta?: Json | null
          user_id: string
        }
        Update: {
          batch_id?: string | null
          contact_extraction_status?: string | null
          created_at?: string
          extracted_at?: string | null
          id?: string
          occurred_at?: string
          payload?: Json
          processed_at?: string | null
          processing_attempts?: number | null
          processing_error?: string | null
          processing_status?: string | null
          provider?: Database["public"]["Enums"]["provider_type"]
          source_id?: string
          source_meta?: Json | null
          user_id?: string
        }
        Relationships: []
      }
      task_contact_tags: {
        Row: {
          contact_id: string
          task_id: string
        }
        Insert: {
          contact_id: string
          task_id: string
        }
        Update: {
          contact_id?: string
          task_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "task_contact_tags_contact_id_fkey"
            columns: ["contact_id"]
            isOneToOne: false
            referencedRelation: "contacts"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "task_contact_tags_task_id_fkey"
            columns: ["task_id"]
            isOneToOne: false
            referencedRelation: "tasks"
            referencedColumns: ["id"]
          },
        ]
      }
      tasks: {
        Row: {
          completed_at: string | null
          created_at: string
          details: Json | null
          due_date: string | null
          id: string
          name: string
          parent_task_id: string | null
          priority: Database["public"]["Enums"]["task_priority"]
          project_id: string | null
          status: Database["public"]["Enums"]["task_status"]
          updated_at: string
          user_id: string
        }
        Insert: {
          completed_at?: string | null
          created_at?: string
          details?: Json | null
          due_date?: string | null
          id?: string
          name: string
          parent_task_id?: string | null
          priority?: Database["public"]["Enums"]["task_priority"]
          project_id?: string | null
          status?: Database["public"]["Enums"]["task_status"]
          updated_at?: string
          user_id: string
        }
        Update: {
          completed_at?: string | null
          created_at?: string
          details?: Json | null
          due_date?: string | null
          id?: string
          name?: string
          parent_task_id?: string | null
          priority?: Database["public"]["Enums"]["task_priority"]
          project_id?: string | null
          status?: Database["public"]["Enums"]["task_status"]
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "tasks_parent_task_id_fkey"
            columns: ["parent_task_id"]
            isOneToOne: false
            referencedRelation: "tasks"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tasks_project_id_fkey"
            columns: ["project_id"]
            isOneToOne: false
            referencedRelation: "projects"
            referencedColumns: ["id"]
          },
        ]
      }
      threads: {
        Row: {
          created_at: string
          id: string
          title: string | null
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          title?: string | null
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          title?: string | null
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      tool_invocations: {
        Row: {
          args: Json
          created_at: string
          id: string
          latency_ms: number | null
          message_id: string
          result: Json | null
          tool: string
          user_id: string
        }
        Insert: {
          args: Json
          created_at?: string
          id?: string
          latency_ms?: number | null
          message_id: string
          result?: Json | null
          tool: string
          user_id: string
        }
        Update: {
          args?: Json
          created_at?: string
          id?: string
          latency_ms?: number | null
          message_id?: string
          result?: Json | null
          tool?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "tool_invocations_message_id_fkey"
            columns: ["message_id"]
            isOneToOne: false
            referencedRelation: "messages"
            referencedColumns: ["id"]
          },
        ]
      }
      user_integrations: {
        Row: {
          access_token: string
          config: Json | null
          created_at: string
          expiry_date: string | null
          provider: string
          refresh_token: string | null
          service: string
          updated_at: string
          user_id: string
        }
        Insert: {
          access_token: string
          config?: Json | null
          created_at?: string
          expiry_date?: string | null
          provider: string
          refresh_token?: string | null
          service?: string
          updated_at?: string
          user_id: string
        }
        Update: {
          access_token?: string
          config?: Json | null
          created_at?: string
          expiry_date?: string | null
          provider?: string
          refresh_token?: string | null
          service?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      zones: {
        Row: {
          color: string | null
          icon_name: string | null
          id: number
          name: string
        }
        Insert: {
          color?: string | null
          icon_name?: string | null
          id?: number
          name: string
        }
        Update: {
          color?: string | null
          icon_name?: string | null
          id?: number
          name?: string
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      check_client_consent: {
        Args: {
          p_consent_type: string
          p_contact_id: string
          p_user_id?: string
        }
        Returns: boolean
      }
      gtrgm_compress: {
        Args: { "": unknown }
        Returns: unknown
      }
      gtrgm_decompress: {
        Args: { "": unknown }
        Returns: unknown
      }
      gtrgm_in: {
        Args: { "": unknown }
        Returns: unknown
      }
      gtrgm_options: {
        Args: { "": unknown }
        Returns: undefined
      }
      gtrgm_out: {
        Args: { "": unknown }
        Returns: unknown
      }
      immutable_90_days_ago: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      onboard_client_with_token: {
        Args: {
          p_client: Json
          p_consent: Json
          p_photo_path?: string
          p_token: string
        }
        Returns: string
      }
      set_limit: {
        Args: { "": number }
        Returns: number
      }
      show_limit: {
        Args: Record<PropertyKey, never>
        Returns: number
      }
      show_trgm: {
        Args: { "": string }
        Returns: string[]
      }
      stable_90_days_ago: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
    }
    Enums: {
      consent_type: "data_processing" | "marketing" | "hipaa" | "photography"
      file_type: "photo" | "document" | "form"
      goal_status: "on_track" | "at_risk" | "achieved" | "abandoned"
      goal_type:
        | "practitioner_business"
        | "practitioner_personal"
        | "client_wellness"
      inbox_item_status: "unprocessed" | "processed" | "archived"
      note_source_type: "typed" | "voice" | "upload"
      project_status: "active" | "on_hold" | "completed" | "archived"
      provider_type: "gmail" | "calendar" | "drive" | "upload"
      task_priority: "low" | "medium" | "high" | "urgent"
      task_status: "todo" | "in_progress" | "done" | "canceled"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof DatabaseWithoutInternals },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  graphql_public: {
    Enums: {},
  },
  public: {
    Enums: {
      consent_type: ["data_processing", "marketing", "hipaa", "photography"],
      file_type: ["photo", "document", "form"],
      goal_status: ["on_track", "at_risk", "achieved", "abandoned"],
      goal_type: [
        "practitioner_business",
        "practitioner_personal",
        "client_wellness",
      ],
      inbox_item_status: ["unprocessed", "processed", "archived"],
      note_source_type: ["typed", "voice", "upload"],
      project_status: ["active", "on_hold", "completed", "archived"],
      provider_type: ["gmail", "calendar", "drive", "upload"],
      task_priority: ["low", "medium", "high", "urgent"],
      task_status: ["todo", "in_progress", "done", "canceled"],
    },
  },
} as const



===== supabase/sql/17_enhanced_contacts_schema.sql =====
-- Enhanced contacts schema for AI features and calendar integration
-- Add new columns to contacts table for AI features

ALTER TABLE contacts 
ADD COLUMN IF NOT EXISTS notes text,
ADD COLUMN IF NOT EXISTS stage text,
ADD COLUMN IF NOT EXISTS tags jsonb DEFAULT '[]'::jsonb,
ADD COLUMN IF NOT EXISTS confidence_score text;

-- Update the embeddings table to support calendar events
-- (owner_type already supports 'calendar_event' from the schema)

-- Create notes table for detailed contact notes
CREATE TABLE IF NOT EXISTS notes (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    contact_id uuid REFERENCES contacts(id) ON DELETE CASCADE,
    title text,
    content text NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Create calendar_events table for Google Calendar integration
CREATE TABLE IF NOT EXISTS calendar_events (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    google_event_id text UNIQUE NOT NULL,
    title text NOT NULL,
    description text,
    start_time timestamp with time zone NOT NULL,
    end_time timestamp with time zone NOT NULL,
    attendees jsonb DEFAULT '[]'::jsonb,
    location text,
    status text DEFAULT 'confirmed',
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Create contact_timeline table to track contact interactions
CREATE TABLE IF NOT EXISTS contact_timeline (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    contact_id uuid NOT NULL REFERENCES contacts(id) ON DELETE CASCADE,
    event_type text NOT NULL, -- 'email', 'call', 'meeting', 'note', 'calendar'
    title text NOT NULL,
    description text,
    event_data jsonb DEFAULT '{}'::jsonb,
    occurred_at timestamp with time zone NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_notes_user_id ON notes(user_id);
CREATE INDEX IF NOT EXISTS idx_notes_contact_id ON notes(contact_id);
CREATE INDEX IF NOT EXISTS idx_notes_created_at ON notes(created_at DESC);

CREATE INDEX IF NOT EXISTS idx_calendar_events_user_id ON calendar_events(user_id);
CREATE INDEX IF NOT EXISTS idx_calendar_events_google_id ON calendar_events(google_event_id);
CREATE INDEX IF NOT EXISTS idx_calendar_events_start_time ON calendar_events(start_time);
CREATE INDEX IF NOT EXISTS idx_calendar_events_attendees ON calendar_events USING gin(attendees);

CREATE INDEX IF NOT EXISTS idx_contact_timeline_user_id ON contact_timeline(user_id);
CREATE INDEX IF NOT EXISTS idx_contact_timeline_contact_id ON contact_timeline(contact_id);
CREATE INDEX IF NOT EXISTS idx_contact_timeline_occurred_at ON contact_timeline(occurred_at DESC);
CREATE INDEX IF NOT EXISTS idx_contact_timeline_event_type ON contact_timeline(event_type);

-- Add RLS policies for new tables
ALTER TABLE notes ENABLE ROW LEVEL SECURITY;
ALTER TABLE calendar_events ENABLE ROW LEVEL SECURITY;
ALTER TABLE contact_timeline ENABLE ROW LEVEL SECURITY;

-- Notes RLS policies
CREATE POLICY "Users can manage their own notes" ON notes
    FOR ALL USING (user_id = auth.uid());

-- Calendar events RLS policies
CREATE POLICY "Users can manage their own calendar events" ON calendar_events
    FOR ALL USING (user_id = auth.uid());

-- Contact timeline RLS policies
CREATE POLICY "Users can manage their own contact timeline" ON contact_timeline
    FOR ALL USING (user_id = auth.uid());

-- Add updated_at trigger for new tables
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_notes_updated_at BEFORE UPDATE ON notes
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_calendar_events_updated_at BEFORE UPDATE ON calendar_events
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();


===== src/app/api/notes/route.ts =====
import { handleGetWithQueryAuth, handleAuth } from "@/lib/api";
import {
  GetNotesQuerySchema,
  CreateNoteBodySchema,
  NotesListResponseSchema,
  type Note,
} from "@/server/db/business-schemas/notes";
import { listNotesService, createNoteService } from "@/server/services/notes.service";
import { z } from "zod";

/**
 * Notes API - List and Create
 */

export const GET = handleGetWithQueryAuth(
  GetNotesQuerySchema,
  NotesListResponseSchema,
  async (query, userId): Promise<{ notes: Note[]; total: number }> => {
    const notes = await listNotesService(userId, {
      contactId: query.contactId,
      search: query.search,
    });
    return { notes, total: notes.length };
  },
);

export const POST = handleAuth(
  CreateNoteBodySchema,
  z.custom<Note>(),
  async (data, userId): Promise<Note> => {
    return await createNoteService(userId, data);
  },
);



===== src/app/api/notes/[noteId]/route.ts =====
import { z } from "zod";
import { handleAuth } from "@/lib/api";
import {
  getNoteByIdService,
  updateNoteService,
  deleteNoteService,
} from "@/server/services/notes.service";
import { UpdateNoteBodySchema } from "@/server/db/business-schemas/notes";

/**
 * Individual Note Management API Routes
 *
 * Migrated to handleAuth pattern for consistent error handling and validation
 */

interface RouteParams {
  params: Promise<{ noteId: string }>;
}

// Response schema for note
const NoteSchema = z.object({
  id: z.string().uuid(),
  userId: z.string().uuid(),
  contactId: z.string().uuid().nullable(),
  contentRich: z.unknown(),
  contentPlain: z.string(),
  piiEntities: z.unknown(),
  tags: z.array(z.string()),
  sourceType: z.enum(["typed", "voice", "upload"]),
  createdAt: z.date().nullable(),
  updatedAt: z.date().nullable(),
});

const NoteResponseSchema = z.object({
  success: z.boolean(),
  data: NoteSchema,
});

const DeleteNoteResponseSchema = z.object({
  success: z.boolean(),
  data: z.object({
    deleted: z.boolean(),
  }),
});

/**
 * GET /api/notes/[noteId] - Get a specific note by ID
 */
export async function GET(request: Request, context: RouteParams): Promise<Response> {
  const params = await context.params;

  return handleAuth(
    z.object({}),
    NoteResponseSchema,
    async (_voidInput, userId): Promise<z.infer<typeof NoteResponseSchema>> => {
      const note = await getNoteByIdService(userId, params.noteId);
      return { success: true, data: note };
    },
  )(request);
}

/**
 * PUT /api/notes/[noteId] - Update a note with PII redaction
 */
export async function PUT(request: Request, context: RouteParams): Promise<Response> {
  const params = await context.params;

  return handleAuth(
    UpdateNoteBodySchema,
    NoteResponseSchema,
    async (data, userId): Promise<z.infer<typeof NoteResponseSchema>> => {
      const note = await updateNoteService(userId, params.noteId, data);
      return { success: true, data: note };
    },
  )(request);
}

/**
 * DELETE /api/notes/[noteId] - Delete a note
 */
export async function DELETE(request: Request, context: RouteParams): Promise<Response> {
  const params = await context.params;

  return handleAuth(
    z.object({}),
    DeleteNoteResponseSchema,
    async (_voidInput, userId): Promise<z.infer<typeof DeleteNoteResponseSchema>> => {
      await deleteNoteService(userId, params.noteId);
      return { success: true, data: { deleted: true } };
    },
  )(request);
}



===== src/server/services/notes.service.ts =====
/**
 * Notes Service Layer
 *
 * Business logic and orchestration for notes.
 * - PII redaction before storage
 * - Unwraps DbResult from repos → throws AppError
 * - Data validation orchestration
 * - Business rule enforcement
 */

import { createNotesRepository } from "@repo";
import type { Note } from "@/server/db/schema";
import { AppError } from "@/lib/errors/app-error";
import { redactPII } from "@/server/lib/pii-detector";
import { getDb } from "@/server/db/client";

// ============================================================================
// SERVICE LAYER TYPES
// ============================================================================

export interface CreateNoteInput {
  contentPlain: string;
  contentRich?: unknown;
  contactId?: string | undefined;
  tags?: string[] | undefined;
  sourceType?: "typed" | "voice" | "upload" | undefined;
}

export interface UpdateNoteInput {
  contentPlain?: string | undefined;
  contentRich?: unknown;
  tags?: string[] | undefined;
}

export interface ListNotesParams {
  contactId?: string | undefined;
  search?: string | undefined;
}

// ============================================================================
// LIST OPERATIONS
// ============================================================================

/**
 * List notes for a user with optional filtering
 */
export async function listNotesService(
  userId: string,
  params: ListNotesParams = {},
): Promise<Note[]> {
  const db = await getDb();
  const repo = createNotesRepository(db);
  const { contactId, search } = params;

  try {
    // Use search if provided, otherwise list by contactId
    const notes = search
      ? await repo.searchNotes(userId, search)
      : await repo.listNotes(userId, contactId);

    return notes;
  } catch (error) {
    throw new AppError(
      error instanceof Error ? error.message : "Failed to list notes",
      "DB_ERROR",
      "database",
      false
    );
  }
}

/**
 * Get a single note by ID
 */
export async function getNoteByIdService(userId: string, noteId: string): Promise<Note> {
  const db = await getDb();
  const repo = createNotesRepository(db);

  try {
    const note = await repo.getNoteById(userId, noteId);

    if (!note) {
      throw new AppError("Note not found", "NOTE_NOT_FOUND", "validation", false);
    }

    return note;
  } catch (error) {
    if (error instanceof AppError) throw error;
    throw new AppError(
      error instanceof Error ? error.message : "Failed to get note",
      "DB_ERROR",
      "database",
      false
    );
  }
}

/**
 * Get notes for a specific contact
 */
export async function getNotesByContactIdService(
  userId: string,
  contactId: string,
): Promise<Note[]> {
  const db = await getDb();
  const repo = createNotesRepository(db);

  try {
    const notes = await repo.getNotesByContactId(userId, contactId);
    return notes;
  } catch (error) {
    throw new AppError(
      error instanceof Error ? error.message : "Failed to get notes by contact",
      "DB_ERROR",
      "database",
      false
    );
  }
}

// ============================================================================
// CREATE OPERATION
// ============================================================================

/**
 * Create a new note with PII redaction
 *
 * Business logic:
 * - Redacts PII from contentPlain before storage
 * - Stores redaction metadata in piiEntities
 * - Validates required fields
 */
export async function createNoteService(userId: string, input: CreateNoteInput): Promise<Note> {
  const db = await getDb();
  const repo = createNotesRepository(db);

  // Validate required fields
  if (!input.contentPlain || input.contentPlain.trim().length === 0) {
    throw new AppError("Note content is required", "VALIDATION_ERROR", "validation", false);
  }

  // Business logic: Redact PII from content
  const redactionResult = redactPII(input.contentPlain);

  if (redactionResult.hasRedactions) {
    throw new AppError("PII detected in note content", "VALIDATION_ERROR", "validation", false);
  }

  try {
    // Call repository with sanitized data
    const note = await repo.createNote({
      userId,
      contactId: input.contactId ?? null,
      contentPlain: redactionResult.sanitizedText,
      contentRich: input.contentRich ?? {},
      tags: input.tags ?? [],
      piiEntities: redactionResult.entities,
      sourceType: input.sourceType ?? "typed",
    });

    return note;
  } catch (error) {
    throw new AppError(
      error instanceof Error ? error.message : "Failed to create note",
      "DB_ERROR",
      "database",
      false
    );
  }
}

// ============================================================================
// UPDATE OPERATION
// ============================================================================

/**
 * Update an existing note with PII redaction
 *
 * Business logic:
 * - If contentPlain is updated, redacts PII
 * - Updates piiEntities metadata
 * - Preserves existing data for fields not provided
 */
export async function updateNoteService(
  userId: string,
  noteId: string,
  input: UpdateNoteInput,
): Promise<Note> {
  // Validate at least one field is provided
  if (!input.contentPlain && !input.contentRich && !input.tags) {
    throw new AppError(
      "At least one field must be provided for update",
      "VALIDATION_ERROR",
      "validation",
      false,
    );
  }

  // Build update data with PII redaction if contentPlain is updated
  const updateData: {
    contentPlain?: string;
    contentRich?: unknown;
    tags?: string[];
    piiEntities?: unknown;
  } = {};

  if (input.contentPlain !== undefined) {
    if (input.contentPlain.trim().length === 0) {
      throw new AppError("Note content cannot be empty", "VALIDATION_ERROR", "validation", false);
    }

    // Business logic: Redact PII from updated content
    const redactionResult = redactPII(input.contentPlain);

    if (redactionResult.hasRedactions) {
      throw new AppError("PII detected in note content", "VALIDATION_ERROR", "validation", false);
    }

    updateData.contentPlain = redactionResult.sanitizedText;
    updateData.piiEntities = redactionResult.entities;
  }

  if (input.contentRich !== undefined) {
    updateData.contentRich = input.contentRich;
  }

  if (input.tags !== undefined) {
    updateData.tags = input.tags;
  }

  const db = await getDb();
  const repo = createNotesRepository(db);

  try {
    // Call repository
    const note = await repo.updateNote(userId, noteId, updateData);

    if (!note) {
      throw new AppError("Note not found", "NOTE_NOT_FOUND", "validation", false);
    }

    return note;
  } catch (error) {
    if (error instanceof AppError) throw error;
    throw new AppError(
      error instanceof Error ? error.message : "Failed to update note",
      "DB_ERROR",
      "database",
      false
    );
  }
}

// ============================================================================
// DELETE OPERATION
// ============================================================================

/**
 * Delete a note
 */
export async function deleteNoteService(userId: string, noteId: string): Promise<void> {
  const db = await getDb();
  const repo = createNotesRepository(db);

  try {
    const deleted = await repo.deleteNote(userId, noteId);

    if (!deleted) {
      throw new AppError("Note not found", "NOTE_NOT_FOUND", "validation", false);
    }
  } catch (error) {
    if (error instanceof AppError) throw error;
    throw new AppError(
      error instanceof Error ? error.message : "Failed to delete note",
      "DB_ERROR",
      "database",
      false
    );
  }
}



===== src/server/services/contacts.service.ts =====
/**
 * Contacts Service Layer
 *
 * Business logic and orchestration.
 * - Unwraps DbResult from repos → throws AppError
 * - Data enrichment (add computed fields)
 * - Business rule validation
 */

import { createContactsRepository, createNotesRepository } from "@repo";
import type { Contact, Note } from "@/server/db/schema";
import { AppError } from "@/lib/errors/app-error";
import { logger } from "@/lib/observability";
import {
  getBatchSignedUrlsService,
  logBatchPhotoAccessService,
} from "@/server/services/storage.service";
import { getDb } from "@/server/db/client";
import { sql } from "drizzle-orm";
import { validateNotesQueryRows } from "@/lib/utils/type-guards/contacts";
import type { ContactWithLastNote as ContactWithLastNoteType } from "@/server/db/business-schemas/contacts";
import { getContactSuggestions } from "../ai/contacts/suggest-contacts";

// ============================================================================
// SERVICE LAYER TYPES (Data enrichment)
// ============================================================================

/**
 * Contact enriched with last note preview
 * Used by list endpoint to show note snippets
 * Re-exported from business schemas for consistency
 */
export type ContactWithLastNote = ContactWithLastNoteType;

/**
 * Contact with full notes array
 * Used by detail view
 */
export type ContactWithNotes = Contact & {
  notes: Array<{
    id: string;
    userId: string;
    contactId: string | null;
    contentRich: unknown;
    contentPlain: string;
    piiEntities: unknown;
    tags: string[];
    sourceType: "typed" | "voice" | "upload";
    createdAt: Date;
    updatedAt: Date;
  }>;
};

export type ContactListParams = {
  search?: string | undefined;
  sort?: "displayName" | "createdAt" | "updatedAt" | undefined;
  order?: "asc" | "desc" | undefined;
  page: number;
  pageSize: number;
  dateRange?: { from?: Date; to?: Date } | undefined;
};

export interface BulkDeleteRequest {
  ids: string[];
}

export interface BulkDeleteResponse {
  deleted: number;
  errors: { id: string; error: string }[];
}

// ============================================================================
// PUBLIC API - CONTACT SUGGESTIONS
// ============================================================================

/**
 * Get contact suggestions from calendar events
 * Note: Requires calendar sync to be active
 */
export async function getContactSuggestionsService(userId: string): Promise<Array<unknown>> {
  // Call AI suggestion logic directly (it returns the array, not a Result)
  const suggestions = await getContactSuggestions(userId);
  return suggestions;
}

/**
 * Count contacts for user with optional search filter
 */
export async function countContactsService(userId: string, search?: string): Promise<number> {
  const db = await getDb();
  const repo = createContactsRepository(db);

  try {
    return await repo.countContacts(userId, search);
  } catch (_error) {
    throw new AppError("Failed to count contacts", "DB_ERROR", "database", false);
  }
}

/**
 * Create contacts from approved suggestion IDs
 *
 * Implementation:
 * 1. Get all suggestions from calendar
 * 2. Filter by provided IDs
 * 3. Transform to contact data
 * 4. Batch create contacts
 */
export async function createContactsFromSuggestionsService(
  userId: string,
  suggestionIds: string[],
): Promise<{ createdCount: number; contacts: Contact[] }> {
  // 1. Get all suggestions
  const allSuggestions = await getContactSuggestions(userId);

  // 2. Filter to only requested IDs
  const selectedSuggestions = allSuggestions.filter((s) => suggestionIds.includes(s.id));

  if (selectedSuggestions.length === 0) {
    return { createdCount: 0, contacts: [] };
  }

  // 3. Transform suggestions to contact data
  const contactsData = selectedSuggestions.map((suggestion) => ({
    displayName: suggestion.displayName,
    primaryEmail: suggestion.email,
    source: suggestion.source,
    lifecycleStage: "Prospect",
    tags: ["calendar_import"],
  }));

  // 4. Batch create contacts
  const batchResult = await createContactsBatchService(userId, contactsData);

  return {
    createdCount: batchResult.created.length,
    contacts: batchResult.created,
  };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Get last note preview (first 500 chars) for each contact
 */
async function getLastNotePreviewForContacts(
  userId: string,
  contactIds: string[],
): Promise<Map<string, string | null>> {
  if (contactIds.length === 0) {
    return new Map();
  }

  const db = await getDb();
  const uuidArray = sql`ARRAY[${sql.join(
    contactIds.map((id) => sql`${id}`),
    sql`, `,
  )}]::uuid[]`;

  let notesData;
  try {
    notesData = await db.execute(sql`
      SELECT DISTINCT ON (contact_id)
        contact_id,
        LEFT(content_plain, 500) as last_note_preview
      FROM notes
      WHERE user_id = ${userId} 
      AND contact_id = ANY(${uuidArray})
      ORDER BY contact_id, created_at DESC
    `);
  } catch (error) {
    console.error("Database error in getLastNotePreview:", {
      error: error instanceof Error ? error.message : String(error),
      userId,
      contactIds: contactIds.length,
    });
    return new Map();
  }

  const result = new Map<string, string | null>();

  // Initialize all contacts with null
  for (const contactId of contactIds) {
    result.set(contactId, null);
  }

  // Validate and process database rows
  const validatedRows = validateNotesQueryRows(notesData);
  for (const row of validatedRows) {
    const preview = typeof row.last_note_preview === "string" ? row.last_note_preview : null;
    result.set(row.contact_id, preview);
  }

  return result;
}

// ============================================================================
// CONTACT CRUD OPERATIONS
// ============================================================================

/**
 * List contacts with pagination and enrichment
 */
export async function listContactsService(
  userId: string,
  params: ContactListParams,
): Promise<{
  items: ContactWithLastNote[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}> {
  const db = await getDb();
  const repo = createContactsRepository(db);

  try {
    // 1. Get contacts from repo
    const { items: contacts, total } = await repo.listContacts(userId, {
      page: params.page,
      pageSize: params.pageSize,
      ...(params.search !== undefined && { search: params.search }),
      ...(params.sort !== undefined && { sort: params.sort }),
      ...(params.order !== undefined && { order: params.order }),
    });

    // 2. Enrich with last notes
    const contactIds = contacts.map((c) => c.id);
    const lastNotePreviews = await getLastNotePreviewForContacts(userId, contactIds);

    // 3. Batch generate signed URLs for photos
    const photoPaths = contacts.filter((c) => c.photoUrl).map((c) => c.photoUrl as string);

    let photoUrls: Record<string, string | null> = {};
    if (photoPaths.length > 0) {
      const batchResult = await getBatchSignedUrlsService(photoPaths, 14400); // 4 hours
      photoUrls = batchResult.urls;

      // Log photo access for HIPAA/GDPR compliance (best-effort)
      const contactPhotos = contacts
        .filter((c) => c.photoUrl)
        .map((c) => ({ contactId: c.id, photoPath: c.photoUrl as string }));

      await logBatchPhotoAccessService(userId, contactPhotos);
    }

    // 4. Transform with enrichments
    const itemsWithEnrichments: ContactWithLastNote[] = contacts.map((contact) => ({
      ...contact,
      lastNote: lastNotePreviews.get(contact.id) ?? null,
      photoUrl: contact.photoUrl ? (photoUrls[contact.photoUrl] ?? contact.photoUrl) : null,
    }));

    // 5. Calculate pagination
    const totalPages = Math.ceil(total / params.pageSize);

    return {
      items: itemsWithEnrichments,
      pagination: {
        page: params.page,
        pageSize: params.pageSize,
        total,
        totalPages,
        hasNext: params.page < totalPages,
        hasPrev: params.page > 1,
      },
    };
  } catch (error) {
    throw new AppError(
      error instanceof Error ? error.message : "Failed to list contacts",
      "DB_ERROR",
      "database",
      false,
    );
  }
}

/**
 * Get single contact by ID
 */
export async function getContactByIdService(userId: string, contactId: string): Promise<Contact> {
  const db = await getDb();
  const repo = createContactsRepository(db);

  try {
    const contact = await repo.getContactById(userId, contactId);

    if (!contact) {
      throw new AppError("contact not found", "CONTACT_NOT_FOUND", "validation", false);
    }

    return normalizeContactNulls(contact);
  } catch (error) {
    if (error instanceof AppError) throw error;
    throw new AppError(
      error instanceof Error ? error.message : "Failed to get contact",
      "DB_ERROR",
      "database",
      false,
    );
  }
}

/**
 * Get contact with all notes
 * Replaces repo.getContactWithNotes - composed from two repo calls
 */
export async function getContactWithNotesService(
  userId: string,
  contactId: string,
): Promise<ContactWithNotes> {
  const db = await getDb();
  const repo = createContactsRepository(db);
  const notesRepo = createNotesRepository(db);

  try {
    // 1. Get contact
    const contact = await repo.getContactById(userId, contactId);

    if (!contact) {
      throw new AppError("Contact not found", "CONTACT_NOT_FOUND", "validation", false);
    }

    // 2. Get notes separately
    let notes: Note[] = [];
    try {
      notes = await notesRepo.listNotes(userId, contactId);
    } catch (error) {
      // Notes fetch failed - return contact with empty notes rather than error
      console.warn("Failed to fetch notes for contact:", error);
      notes = [];
    }

    // 3. Combine
    return {
      ...contact,
      notes,
    };
  } catch (error) {
    if (error instanceof AppError) throw error;
    throw new AppError(
      error instanceof Error ? error.message : "Failed to get contact with notes",
      "DB_ERROR",
      "database",
      false,
    );
  }
}

/**
 * Create new contact
 */
export async function createContactService(
  userId: string,
  input: {
    displayName: string;
    primaryEmail?: string | undefined;
    primaryPhone?: string | undefined;
    photoUrl?: string | undefined;
    source?: string | undefined;
    lifecycleStage?: string | undefined;
    tags?: string[] | undefined;
    confidenceScore?: string | undefined;
    dateOfBirth?: string | undefined;
    emergencyContactName?: string | undefined;
    emergencyContactPhone?: string | undefined;
    clientStatus?: string | undefined;
    referralSource?: string | undefined;
    address?: unknown;
    healthContext?: unknown;
    preferences?: unknown;
  },
): Promise<Contact> {
  const db = await getDb();
  const repo = createContactsRepository(db);

  try {
    const contact = await repo.createContact({
      userId,
      displayName: input.displayName,
      primaryEmail: input.primaryEmail ?? null,
      primaryPhone: input.primaryPhone ?? null,
      photoUrl: input.photoUrl ?? null,
      source: input.source ?? null,
      lifecycleStage: input.lifecycleStage ?? null,
      tags: input.tags ?? null,
      confidenceScore: input.confidenceScore ?? null,
      dateOfBirth: input.dateOfBirth ?? null,
      emergencyContactName: input.emergencyContactName ?? null,
      emergencyContactPhone: input.emergencyContactPhone ?? null,
      clientStatus: input.clientStatus ?? null,
      referralSource: input.referralSource ?? null,
      address: input.address ?? null,
      healthContext: input.healthContext ?? null,
      preferences: input.preferences ?? null,
    });

    // Transform null to undefined for exactOptionalPropertyTypes compatibility
    return normalizeContactNulls(contact);
  } catch (error) {
    throw new AppError(
      error instanceof Error ? error.message : "Failed to create contact",
      "DB_ERROR",
      "database",
      false,
    );
  }
}

/**
 * Helper: Convert null values to undefined for schema compatibility
 * Required because exactOptionalPropertyTypes treats null and undefined as distinct
 */
function normalizeContactNulls(contact: Contact): Contact {
  return {
    ...contact,
    primaryEmail: contact.primaryEmail ?? undefined,
    primaryPhone: contact.primaryPhone ?? undefined,
    photoUrl: contact.photoUrl ?? undefined,
    source: contact.source ?? undefined,
    lifecycleStage: contact.lifecycleStage ?? undefined,
    clientStatus: contact.clientStatus ?? undefined,
    referralSource: contact.referralSource ?? undefined,
    confidenceScore: contact.confidenceScore ?? undefined,
    dateOfBirth: contact.dateOfBirth ?? undefined,
    emergencyContactName: contact.emergencyContactName ?? undefined,
    emergencyContactPhone: contact.emergencyContactPhone ?? undefined,
    address: contact.address ?? undefined,
    healthContext: contact.healthContext ?? undefined,
    preferences: contact.preferences ?? undefined,
    tags: contact.tags ?? undefined,
  } as Contact;
}

/**
 * Update contact
 */
export async function updateContactService(
  userId: string,
  contactId: string,
  updates: {
    displayName?: string | undefined;
    primaryEmail?: string | null | undefined;
    primaryPhone?: string | null | undefined;
    photoUrl?: string | null | undefined;
    source?: string | null | undefined;
    lifecycleStage?: string | null | undefined;
    tags?: string[] | null | undefined;
    confidenceScore?: string | null | undefined;
    dateOfBirth?: string | null | undefined;
    emergencyContactName?: string | null | undefined;
    emergencyContactPhone?: string | null | undefined;
    clientStatus?: string | null | undefined;
    referralSource?: string | null | undefined;
    address?: unknown;
    healthContext?: unknown;
    preferences?: unknown;
  },
): Promise<Contact> {
  const db = await getDb();
  const repo = createContactsRepository(db);

  try {
    const cleanUpdates = Object.fromEntries(
      Object.entries(updates).filter(([_, v]) => v !== undefined),
    ) as Partial<typeof updates>;
    const contact = await repo.updateContact(userId, contactId, cleanUpdates);

    if (!contact) {
      throw new AppError("Contact not found", "CONTACT_NOT_FOUND", "validation", false);
    }

    return normalizeContactNulls(contact);
  } catch (error) {
    if (error instanceof AppError) throw error;
    throw new AppError(
      error instanceof Error ? error.message : "Failed to update contact",
      "DB_ERROR",
      "database",
      false,
    );
  }
}

/**
 * Delete contact
 */
export async function deleteContactService(userId: string, contactId: string): Promise<boolean> {
  const db = await getDb();
  const repo = createContactsRepository(db);

  try {
    return await repo.deleteContact(userId, contactId);
  } catch (error) {
    throw new AppError(
      error instanceof Error ? error.message : "Failed to delete contact",
      "DB_ERROR",
      "database",
      false,
    );
  }
}

/**
 * Find contact by email
 */
export async function findContactByEmailService(
  userId: string,
  email: string,
): Promise<Contact | null> {
  const db = await getDb();
  const repo = createContactsRepository(db);

  try {
    const contact = await repo.findContactByEmail(userId, email);
    return contact ? normalizeContactNulls(contact) : null;
  } catch (error) {
    throw new AppError(
      error instanceof Error ? error.message : "Failed to find contact by email",
      "DB_ERROR",
      "database",
      false,
    );
  }
}

// ============================================================================
// BULK OPERATIONS
// ============================================================================

/**
 * Bulk delete contacts
 */
export async function deleteContactsBulk(
  userId: string,
  request: BulkDeleteRequest,
): Promise<BulkDeleteResponse> {
  const { ids } = request;
  const db = await getDb();
  const repo = createContactsRepository(db);

  try {
    const deletedCount = await repo.deleteContactsByIds(userId, ids);

    // Log for audit
    await logger.info("Bulk deleted contacts", {
      operation: "contacts_bulk_delete",
      additionalData: {
        userId: userId.slice(0, 8) + "...",
        deletedCount,
        requestedIds: ids.length,
      },
    });

    return {
      deleted: deletedCount,
      errors: [],
    };
  } catch (error) {
    throw new AppError(
      error instanceof Error ? error.message : "Failed to bulk delete contacts",
      "DB_ERROR",
      "database",
      false,
    );
  }
}

/**
 * Batch create contacts
 */
export async function createContactsBatchService(
  userId: string,
  contactsData: Array<{
    displayName: string;
    primaryEmail?: string;
    primaryPhone?: string;
    source?: string;
    lifecycleStage?: string;
    tags?: string[];
  }>,
): Promise<{
  created: Contact[];
  duplicates: number;
  errors: number;
}> {
  const created: Contact[] = [];
  let duplicates = 0;
  let errors = 0;

  for (const contactData of contactsData) {
    try {
      // Check for duplicates by email
      if (contactData.primaryEmail) {
        const existing = await findContactByEmailService(userId, contactData.primaryEmail);
        if (existing) {
          duplicates++;
          continue;
        }
      }

      const contact = await createContactService(userId, contactData);
      created.push(contact);
    } catch (error) {
      errors++;
      console.error("Error creating contact in batch:", error);
    }
  }

  return { created, duplicates, errors };
}



===== src/server/services/user-deletion.service.ts =====
import { getDb, type DbClient } from "@/server/db/client";
import { count, eq, inArray } from "drizzle-orm";
import type { PgTable, PgColumn } from "drizzle-orm/pg-core";
import {
  contacts,
  interactions,
  threads,
  messages,
  toolInvocations,
  jobs,
  aiUsage,
  aiQuotas,
  userIntegrations,
  notes,
  projects,
  tasks,
  goals,
  dailyPulseLogs,
  inboxItems,
  taskContactTags,
  documents,
} from "@/server/db/schema";
import { logger } from "@/lib/observability";
import { deleteEmbeddingsForUserService } from "@/server/services/embeddings.service";
import { deleteDocumentsForUserService } from "@/server/services/documents.service";
import { deleteAiInsightsForUserService } from "@/server/services/ai-insights.service";
import { deleteRawEventsForUserService } from "@/server/services/raw-events.service";

export interface DeletionRequest {
  confirmation: string;
  acknowledgeIrreversible: boolean;
  ipAddress?: string;
}

export interface DeletionResult {
  deleted: boolean;
  deletedAt: string;
  deletionResults: Record<string, number>;
  message: string;
  auditTrail: string;
  nextSteps: string[];
}

/**
 * Helper to count records in a table for a user
 */
async function countRecords(
  db: DbClient,
  table: PgTable & { userId: PgColumn },
  userId: string,
): Promise<number> {
  const rows = await db.select({ value: count() }).from(table).where(eq(table.userId, userId));

  return Number(rows[0]?.value ?? 0);
}

/**
 * Log deletion request for audit trail
 */
async function logDeletionRequest(
  userId: string,
  request: DeletionRequest,
  timestamp: Date,
): Promise<void> {
  await logger.info("Account deletion requested", {
    operation: "user_deletion_service.audit_requested",
    additionalData: {
      userId,
      confirmation: request.confirmation,
      acknowledgeIrreversible: request.acknowledgeIrreversible,
      deletionTimestamp: timestamp.toISOString(),
      ipAddress: request.ipAddress ?? "unknown",
    },
  });
}

/**
 * Log deletion completion for audit trail
 */
async function logDeletionCompletion(userId: string, timestamp: Date): Promise<void> {
  await logger.info("Account deletion completed", {
    operation: "user_deletion_service.audit_completed",
    additionalData: {
      userId,
      deletionTimestamp: timestamp.toISOString(),
      completedAt: new Date().toISOString(),
      retentionNote:
        "Audit entries are retained via centralized logging per data retention policy",
    },
  });
}
/**
 * Permanently delete all user data for GDPR compliance
 */
export async function deleteUserDataService(userId: string, request: DeletionRequest): Promise<DeletionResult> {
    const deletionTimestamp = new Date();

    await logger.info("Starting account deletion process", {
      operation: "user_deletion_service.delete",
      additionalData: {
        userId,
        timestamp: deletionTimestamp.toISOString(),
      },
    });

    const db = await getDb();

    // Log deletion request to audit trail before deletion
    await logDeletionRequest(userId, request, deletionTimestamp);

    // Start transaction for atomic deletion
    const deletionResults = await db.transaction(async (tx) => {
      const txExecutor = tx as unknown as DbClient;
      const results: Record<string, number> = {};

      // Delete in reverse dependency order to avoid foreign key constraints

      // 1. Delete task contact tags (junction table - need subquery)
      const userTaskIds = await tx
        .select({ id: tasks.id })
        .from(tasks)
        .where(eq(tasks.userId, userId));
      const taskIds = userTaskIds.map((t) => t.id);
      const taskContactTagsResult =
        taskIds.length > 0
          ? await tx.delete(taskContactTags).where(inArray(taskContactTags.taskId, taskIds))
          : { length: 0 };
      results["taskContactTags"] = taskContactTagsResult.length || 0;

      // 2. Delete tasks
      const tasksResult = await tx.delete(tasks).where(eq(tasks.userId, userId));
      results["tasks"] = tasksResult.length;

      // 3. Delete projects
      const projectsResult = await tx.delete(projects).where(eq(projects.userId, userId));
      results["projects"] = projectsResult.length;

      // 4. Delete goals
      const goalsResult = await tx.delete(goals).where(eq(goals.userId, userId));
      results["goals"] = goalsResult.length;

      // 5. Delete daily pulse logs
      const dailyPulseLogsResult = await tx
        .delete(dailyPulseLogs)
        .where(eq(dailyPulseLogs.userId, userId));
      results["dailyPulseLogs"] = dailyPulseLogsResult.length;

      // 6. Delete inbox items
      const inboxItemsResult = await tx.delete(inboxItems).where(eq(inboxItems.userId, userId));
      results["inboxItems"] = inboxItemsResult.length;

      // 7. Delete notes (references contacts)
      const notesResult = await tx.delete(notes).where(eq(notes.userId, userId));
      results["notes"] = notesResult.length;

      // 8. Delete tool invocations (references messages)
      const toolInvocationResult = await tx
        .delete(toolInvocations)
        .where(eq(toolInvocations.userId, userId));
      results["toolInvocations"] = toolInvocationResult.length;

      // 9. Delete messages (references threads)
      const messagesResult = await tx.delete(messages).where(eq(messages.userId, userId));
      results["messages"] = messagesResult.length;

      // 10. Delete threads
      const threadsResult = await tx.delete(threads).where(eq(threads.userId, userId));
      results["threads"] = threadsResult.length;

      // 11. Delete embeddings (references documents/interactions)
      const embeddingsDeleted = await deleteEmbeddingsForUserService(userId, txExecutor);
      results["embeddings"] = embeddingsDeleted;

      // 12. Delete documents
      const documentsDeleted = await deleteDocumentsForUserService(userId, txExecutor);
      results["documents"] = documentsDeleted;

      // 13. Delete AI insights
      const aiInsightsDeleted = await deleteAiInsightsForUserService(userId, txExecutor);
      results["aiInsights"] = aiInsightsDeleted;

      // 14. Delete interactions
      const interactionsResult = await tx
        .delete(interactions)
        .where(eq(interactions.userId, userId));
      results["interactions"] = interactionsResult.length;

      // 15. Delete contacts
      const contactsResult = await tx.delete(contacts).where(eq(contacts.userId, userId));
      results["contacts"] = contactsResult.length;

      // 16. Delete raw events
      const rawEventsDeleted = await deleteRawEventsForUserService(userId, txExecutor);
      results["rawEvents"] = rawEventsDeleted;

      // 17. Delete jobs
      const jobsResult = await tx.delete(jobs).where(eq(jobs.userId, userId));
      results["jobs"] = jobsResult.length;

      // 18. Delete AI usage and quotas
      const aiUsageResult = await tx.delete(aiUsage).where(eq(aiUsage.userId, userId));
      results["aiUsage"] = aiUsageResult.length;

      const aiQuotasResult = await tx.delete(aiQuotas).where(eq(aiQuotas.userId, userId));
      results["aiQuotas"] = aiQuotasResult.length;

      // 19. Delete user integrations (OAuth tokens)
      const integrationsResult = await tx
        .delete(userIntegrations)
        .where(eq(userIntegrations.userId, userId));
      results["integrations"] = integrationsResult.length;

      // Note: Detailed audit information is preserved via the observability pipeline
      // rather than a dedicated sync audit table in the refactored schema.

      return results;
    });

    // Log detailed deletion results
    await logger.info("Account deletion completed successfully", {
      operation: "user_deletion_service.delete",
      additionalData: {
        userId,
        deletionResults,
        completedAt: new Date().toISOString(),
      },
    });

    // Final audit log entry (will be retained for compliance)
    await logDeletionCompletion(userId, deletionTimestamp);

    return {
      deleted: true,
      deletedAt: deletionTimestamp.toISOString(),
      deletionResults,
      message: "Account and all associated data have been permanently deleted",
      auditTrail: "Deletion has been logged for compliance purposes",
      nextSteps: [
        "Your account deletion is complete and cannot be undone",
        "OAuth tokens have been revoked",
        "All personal data has been permanently removed",
        "Minimal audit logs will be retained for 30 days for legal compliance",
      ],
    };
  }

/**
 * Get a preview of what data would be deleted (for confirmation UI)
 */
export async function getDeletionPreviewService(userId: string): Promise<Record<string, number>> {
    const db = await getDb();

    const [
      contactsCount,
      interactionsCount,
      notesCount,
      documentsCount,
      jobsCount,
      tasksCount,
      projectsCount,
      goalsCount,
      inboxItemsCount,
    ] = await Promise.all([
      countRecords(db, contacts, userId),
      countRecords(db, interactions, userId),
      countRecords(db, notes, userId),
      countRecords(db, documents, userId),
      countRecords(db, jobs, userId),
      countRecords(db, tasks, userId),
      countRecords(db, projects, userId),
      countRecords(db, goals, userId),
      countRecords(db, inboxItems, userId),
    ]);

    return {
      contacts: contactsCount,
      interactions: interactionsCount,
      notes: notesCount,
      documents: documentsCount,
      jobs: jobsCount,
      tasks: tasksCount,
      projects: projectsCount,
      goals: goalsCount,
      inboxItems: inboxItemsCount,
    };
  }

/**
 * Validate deletion request
 */
export function validateDeletionRequestService(request: DeletionRequest): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (request.confirmation !== "DELETE MY DATA") {
      errors.push("Confirmation text must be exactly 'DELETE MY DATA'");
    }

    if (request.acknowledgeIrreversible !== true) {
      errors.push("You must acknowledge that this action is irreversible");
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }




===== packages/repo/src/notes.repo.ts =====
import { eq, and, desc, ilike } from "drizzle-orm";
import { notes, type Note, type CreateNote } from "@/server/db/schema";
import type { DbClient } from "@/server/db/client";

/**
 * Notes Repository
 *
 * Pure database operations - no business logic, no validation.
 * Uses DbClient constructor injection pattern.
 * Throws errors on failure - no Result wrapper.
 */

export class NotesRepository {
  constructor(private readonly db: DbClient) {}

  /**
   * List notes for a user with optional contact filtering
   */
  async listNotes(userId: string, contactId?: string): Promise<Note[]> {
    const conditions = [eq(notes.userId, userId)];

    if (contactId) {
      conditions.push(eq(notes.contactId, contactId));
    }

    const rows = await this.db
      .select()
      .from(notes)
      .where(and(...conditions))
      .orderBy(desc(notes.createdAt));

    return rows;
  }

  /**
   * Get a single note by ID
   */
  async getNoteById(userId: string, noteId: string): Promise<Note | null> {
    const rows = await this.db
      .select()
      .from(notes)
      .where(and(eq(notes.userId, userId), eq(notes.id, noteId)))
      .limit(1);

    return rows.length > 0 && rows[0] ? rows[0] : null;
  }

  /**
   * Get notes for a specific contact
   */
  async getNotesByContactId(userId: string, contactId: string): Promise<Note[]> {
    const rows = await this.db
      .select()
      .from(notes)
      .where(and(eq(notes.userId, userId), eq(notes.contactId, contactId)))
      .orderBy(desc(notes.createdAt));

    return rows;
  }

  /**
   * Search notes by content
   */
  async searchNotes(userId: string, searchTerm: string): Promise<Note[]> {
    const rows = await this.db
      .select()
      .from(notes)
      .where(and(eq(notes.userId, userId), ilike(notes.contentPlain, `%${searchTerm}%`)))
      .orderBy(desc(notes.createdAt));

    return rows;
  }

  /**
   * Create a new note
   */
  async createNote(data: CreateNote): Promise<Note> {
    const [newNote] = await this.db
      .insert(notes)
      .values({
        userId: data.userId,
        contactId: data.contactId ?? null,
        contentPlain: data.contentPlain,
        contentRich: data.contentRich ?? {},
        tags: data.tags ?? [],
        piiEntities: data.piiEntities ?? [],
        sourceType: data.sourceType ?? "typed",
      })
      .returning();

    if (!newNote) {
      throw new Error("Insert returned no data");
    }

    return newNote;
  }

  /**
   * Update an existing note
   */
  async updateNote(
    userId: string,
    noteId: string,
    updates: Partial<CreateNote>,
  ): Promise<Note | null> {
    const [updatedNote] = await this.db
      .update(notes)
      .set({
        ...updates,
        updatedAt: new Date(),
      })
      .where(and(eq(notes.userId, userId), eq(notes.id, noteId)))
      .returning();

    return updatedNote ?? null;
  }

  /**
   * Delete a note
   */
  async deleteNote(userId: string, noteId: string): Promise<boolean> {
    const result = await this.db
      .delete(notes)
      .where(and(eq(notes.userId, userId), eq(notes.id, noteId)))
      .returning({ id: notes.id });

    return result.length > 0;
  }
}

export function createNotesRepository(db: DbClient): NotesRepository {
  return new NotesRepository(db);
}



===== src/app/(authorisedRoute)/contacts/_components/ContactDetailsCard.tsx =====
"use client";

import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";
import { EditContactDialog } from "./EditContactDialog";
import { ContactHeader } from "./ContactHeader";
import { NotesMainPane } from "../[contactId]/notes/[noteId]/_components/NotesMainPane";
import { useNotes } from "@/hooks/use-notes";
import { useContact, useDeleteContact } from "@/hooks/use-contacts";
import { type ContactWithNotes } from "@/server/db/schema";

interface ContactDetailsCardProps {
  contactId: string;
}

/**
 * Contact Details Card Component
 * Wellness practitioner optimized: Notes-first layout with AI insights sidebar
 */
export function ContactDetailsCard({ contactId }: ContactDetailsCardProps): JSX.Element {
  const router = useRouter();

  // State management
  const [isAddingNote, setIsAddingNote] = useState(false);
  const [editDialogOpen, setEditDialogOpen] = useState(false);

  // Fetch contact data using centralized hook
  const {
    data: client,
    isLoading: clientLoading,
    error: clientError,
  } = useContact(contactId);

  // Use notes hook for CRUD operations
  const { notes, isLoading: notesLoading, createNote } = useNotes({ contactId });

  // Fetch last interaction (latest note or calendar event)
  const { data: lastInteraction } = useQuery({
    queryKey: [`/api/contacts/${contactId}/last-interaction`],
    queryFn: async (): Promise<{ date: Date; type: string } | null> => {
      if (notes && notes.length > 0 && notes[0]) {
        return {
          date: new Date(notes[0].createdAt),
          type: "note",
        };
      }
      return null;
    },
    enabled: !!notes,
  });

  // Fetch next scheduled event from calendar
  const { data: nextEvent } = useQuery({
    queryKey: [`/api/contacts/${contactId}/next-event`],
    queryFn: async (): Promise<{ date: Date } | null> => {
      // TODO: Query calendar_events table in production
      return null;
    },
  });

  // Mutations
  const deleteContactMutation = useDeleteContact();

  // Loading state
  if (clientLoading) {
    return (
      <div className="container mx-auto py-6">
        <div className="flex items-center justify-center h-64">
          <div className="text-muted-foreground">Loading contact details...</div>
        </div>
      </div>
    );
  }

  // Error state
  if (clientError || !client) {
    return (
      <div className="container mx-auto py-6">
        <div className="text-center">
          <h1 className="text-2xl font-semibold">Contact Not Found</h1>
          <p className="text-muted-foreground mt-2">
            The contact you&apos;re looking for doesn&apos;t exist or you don&apos;t have access to
            it.
          </p>
          <Button onClick={() => router.push("/contacts")} className="mt-4">
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to Contacts
          </Button>
        </div>
      </div>
    );
  }

  // Type assertion after null check
  const safeClient = client as ContactWithNotes;

  // Handlers
  const handleDeleteClient = (): void => {
    if (
      confirm(
        `Are you sure you want to delete ${safeClient.displayName}? This action cannot be undone.`,
      )
    ) {
      deleteContactMutation.mutate(contactId, {
        onSuccess: () => {
          router.push("/contacts");
        },
      });
    }
  };

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Back Button */}
      <div className="flex items-center">
        <Button variant="ghost" onClick={() => router.push("/contacts")} className="h-8 w-8 p-0">
          <ArrowLeft className="h-4 w-4" />
        </Button>
      </div>

      {/* Contact Header with Photo, Name, Tags, Timeline */}
      <ContactHeader
        contact={safeClient}
        lastInteraction={lastInteraction ?? null}
        nextEvent={nextEvent ?? null}
        onEdit={() => setEditDialogOpen(true)}
        onDelete={handleDeleteClient}
        onAddNote={() => setIsAddingNote(true)}
      />

      {/* Main Content: Notes */}
      <div>
        <NotesMainPane
          contactId={contactId}
          notes={notes}
          isLoading={notesLoading}
          isAddingNote={isAddingNote}
          setIsAddingNote={setIsAddingNote}
          createNote={createNote}
        />
      </div>

      {/* Dialogs */}
      <EditContactDialog
        contact={safeClient}
        open={editDialogOpen}
        onOpenChange={setEditDialogOpen}
      />
    </div>
  );
}



===== src/app/(authorisedRoute)/contacts/[contactId]/notes/[noteId]/_components/NotesMainPane.tsx =====
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { formatDistanceToNow } from "date-fns";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { MessageSquare, Plus, Link2, NotebookPen } from "lucide-react";
import { NoteEditor } from "./NoteEditor";
import { toast } from "sonner";
import type { Note } from "@/server/db/schema";

interface NotesMainPaneProps {
  contactId: string;
  notes: Note[];
  isLoading: boolean;
  isAddingNote: boolean;
  setIsAddingNote: (value: boolean) => void;
  createNote: (data: { content: string }) => void;
}

export function NotesMainPane({
  contactId,
  notes,
  isLoading,
  isAddingNote,
  setIsAddingNote,
  createNote,
}: NotesMainPaneProps): JSX.Element {
  const router = useRouter();
  const [newNoteContent, setNewNoteContent] = useState("");

  const handleAddNote = (): void => {
    const content = newNoteContent?.trim();

    if (!content) {
      toast.error("Please enter a note");
      return;
    }

    createNote({ content });

    // Close editor and reset
    setIsAddingNote(false);
    setNewNoteContent("");
  };

  const handleNoteChange = (_html: string, text: string): void => {
    setNewNoteContent(text || "");
  };

  return (
    <div className="space-y-6">
      {/* Latest Note Preview */}
      {!isLoading && notes && notes.length > 0 && notes[0] && (
        <Card className="border-l-4 border-l-blue-500">
          <CardHeader className="pb-3">
            <div className="flex items-center justify-between">
              <CardTitle className="text-base flex items-center gap-2">
                <MessageSquare className="h-4 w-4" />
                Latest Note
              </CardTitle>
            </div>
            <CardDescription className="text-xs">
              {notes[0].createdAt &&
                formatDistanceToNow(new Date(notes[0].createdAt), { addSuffix: true })}
            </CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-sm whitespace-pre-wrap line-clamp-3">
              {notes[0].contentPlain?.slice(0, 500)}
              {(notes[0].contentPlain?.length ?? 0) > 500 && "..."}
            </p>
            <div className="flex items-center justify-between mt-3">
              <Button
                variant="link"
                size="sm"
                onClick={() => router.push(`/contacts/${contactId}/notes/${notes[0]?.id ?? ""}`)}
                className="px-0 text-xs"
              >
                View full note →
              </Button>
              <Button
                variant="ghost"
                size="sm"
                className="h-6 px-2 text-xs"
                onClick={(e) => {
                  e.stopPropagation();
                  const noteUrl = `${window.location.origin}/contacts/${contactId}/notes/${notes[0]?.id ?? ""}`;
                  navigator.clipboard.writeText(noteUrl);
                  toast.success("Link copied to clipboard");
                }}
              >
                <Link2 className="h-3 w-3 mr-1" />
                Copy Link
              </Button>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Add Note Section */}
      {isAddingNote && (
        <Card className="border-2 border-primary">
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              <div className="flex items-center">
                <NotebookPen className="h-5 w-5 mr-2" />
                New Note
              </div>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => {
                  setIsAddingNote(false);
                  setNewNoteContent("");
                }}
              >
                Cancel
              </Button>
            </CardTitle>
          </CardHeader>
          <CardContent>
            <NoteEditor
              key={isAddingNote ? "adding" : "closed"}
              content={newNoteContent}
              onChange={handleNoteChange}
              onSave={handleAddNote}
              placeholder="Document your session, observations, treatment, and next steps..."
              className="min-h-[300px]"
            />
          </CardContent>
        </Card>
      )}

      {/* All Notes Feed */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <div className="flex items-center">
              <MessageSquare className="h-5 w-5 mr-2" />
              Session Notes ({notes?.length ?? 0})
            </div>
            {!isAddingNote && (
              <Button onClick={() => setIsAddingNote(true)}>
                <Plus className="h-4 w-4 mr-2" />
                Add Note
              </Button>
            )}
          </CardTitle>
        </CardHeader>
        <CardContent>
          {isLoading ? (
            <div className="text-muted-foreground text-center py-8">Loading notes...</div>
          ) : notes && notes.length > 0 ? (
            <div className="space-y-4">
              {notes.map((note) => {
                if (!note || !note.contentPlain) return null;

                return (
                  <div
                    key={note.id}
                    className="border rounded-lg p-4 hover:bg-accent/50 transition-colors cursor-pointer"
                    onClick={() => router.push(`/contacts/${contactId}/notes/${note.id}`)}
                  >
                    <p className="whitespace-pre-wrap line-clamp-3">{note.contentPlain}</p>
                    <div className="flex items-center justify-between mt-3 text-xs text-muted-foreground">
                      <span>
                        {note.createdAt &&
                          formatDistanceToNow(new Date(note.createdAt), { addSuffix: true })}
                      </span>
                      <div className="flex items-center gap-2">
                        {note.updatedAt && note.createdAt && note.updatedAt !== note.createdAt && (
                          <span>
                            Edited{" "}
                            {formatDistanceToNow(new Date(note.updatedAt), { addSuffix: true })}
                          </span>
                        )}
                        <Button
                          variant="ghost"
                          size="sm"
                          className="h-6 px-2"
                          onClick={(e) => {
                            e.stopPropagation();
                            const noteUrl = `${window.location.origin}/contacts/${contactId}/notes/${note.id}`;
                            navigator.clipboard.writeText(noteUrl);
                            toast.success("Link copied to clipboard");
                          }}
                        >
                          <Link2 className="h-3 w-3" />
                        </Button>
                      </div>
                    </div>
                    {note.contentPlain.length > 300 && (
                      <Button
                        variant="link"
                        size="sm"
                        className="px-0 text-xs mt-2"
                        onClick={(e) => {
                          e.stopPropagation();
                          router.push(`/contacts/${contactId}/notes/${note.id}`);
                        }}
                      >
                        Read more →
                      </Button>
                    )}
                  </div>
                );
              })}
            </div>
          ) : (
            <div className="text-center py-12">
              <MessageSquare className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p className="text-muted-foreground font-medium">No notes yet</p>
              <p className="text-sm text-muted-foreground mt-1">
                Add your first note to track interactions with this client
              </p>
              <Button onClick={() => setIsAddingNote(true)} className="mt-4">
                <Plus className="h-4 w-4 mr-2" />
                Add First Note
              </Button>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}



===== src/app/(authorisedRoute)/contacts/[contactId]/notes/[noteId]/_components/NotesHoverCard.tsx =====
"use client";

import { useState } from "react";
import { HoverCard, HoverCardContent, HoverCardTrigger } from "@/components/ui/hover-card";
import { Skeleton } from "@/components/ui/skeleton";
import { formatDistanceToNow } from "date-fns";
import { get } from "@/lib/api/client";

interface Note {
  id: string;
  contentPlain: string;
  createdAt: string;
  updatedAt: string;
}

interface NotesResponse {
  notes: Note[];
  total: number;
}

interface NotesHoverCardProps {
  contactId: string;
  contactName: string;
  children: React.ReactNode;
  "data-testid"?: string;
}

export function NotesHoverCard({
  contactId,
  contactName,
  children,
  "data-testid": testId,
}: NotesHoverCardProps): JSX.Element {
  const [notes, setNotes] = useState<Note[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasFetched, setHasFetched] = useState(false);

  const fetchNotes = async (): Promise<void> => {
    if (!contactId || hasFetched) return;

    setLoading(true);
    setError(null);
    setHasFetched(true);

    try {
      const data = await get<NotesResponse>(`/api/notes?contactId=${contactId}`);
      setNotes(data?.notes || []);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load notes");
    } finally {
      setLoading(false);
    }
  };

  return (
    <HoverCard openDelay={150} closeDelay={200}>
      <HoverCardTrigger asChild onMouseEnter={fetchNotes} onFocus={fetchNotes} data-testid={testId}>
        {children}
      </HoverCardTrigger>
      <HoverCardContent
        className="w-96 p-4 min-h-[120px]"
        side="top"
        align="center"
        sideOffset={10}
        avoidCollisions={false}
      >
        <div className="space-y-3">
          <h4 className="text-sm font-semibold text-foreground">Last Note for {contactName}</h4>

          {loading && (
            <div className="space-y-2">
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-3/4" />
              <Skeleton className="h-4 w-1/2" />
            </div>
          )}

          {error && <p className="text-sm text-destructive">{error}</p>}

          {!loading && !error && (
            <>
              {notes.length > 0 && notes[0] ? (
                <div className="space-y-2">
                  <div className="text-xs text-muted-foreground">
                    <time dateTime={notes[0].createdAt}>
                      {formatDistanceToNow(new Date(notes[0].createdAt), { addSuffix: true })}
                    </time>
                  </div>
                  <p className="text-sm leading-relaxed break-words whitespace-pre-wrap">
                    {notes[0].contentPlain.slice(0, 500)}
                    {notes[0].contentPlain.length > 500 && "..."}
                  </p>
                </div>
              ) : (
                <p className="text-sm text-muted-foreground italic">No notes yet</p>
              )}
            </>
          )}
        </div>
      </HoverCardContent>
    </HoverCard>
  );
}



===== src/hooks/use-notes.ts =====
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useToast } from "@/hooks/use-toast";
import { apiClient } from "@/lib/api/client";
// Direct retry logic (no abstraction)
const shouldRetry = (error: unknown, retryCount: number): boolean => {
  // Don't retry auth errors (401, 403)
  if (error instanceof Error && error.message.includes("401")) return false;
  if (error instanceof Error && error.message.includes("403")) return false;

  // Retry network errors up to 3 times
  if (
    error instanceof Error &&
    (error.message.includes("fetch") || error.message.includes("network"))
  ) {
    return retryCount < 3;
  }

  // Retry other errors up to 2 times
  return retryCount < 2;
};
import type { Note } from "@/server/db/schema";

interface UseNotesOptions {
  contactId: string;
}

interface CreateNoteData {
  content: string;
}

interface UpdateNoteData {
  noteId: string;
  content: string;
}

interface DeleteNoteData {
  noteId: string;
}

interface UseNotesReturn {
  notes: Note[];
  isLoading: boolean;
  error: unknown;
  createNote: (data: CreateNoteData) => void;
  updateNote: (data: UpdateNoteData) => void;
  deleteNote: (data: DeleteNoteData) => void;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  refetch: () => Promise<{ data: Note[] | undefined; error: unknown }>;
}

export function useNotes({ contactId }: UseNotesOptions): UseNotesReturn {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Fetch notes for a contact
  const notesQuery = useQuery({
    queryKey: ["/api/notes", contactId],
    queryFn: async (): Promise<Note[]> => {
      // API returns { notes: Note[], total: number }
      const response = await apiClient.get<{ notes: Note[]; total: number }>(`/api/notes?contactId=${contactId}`);
      return response?.notes ?? [];
    },
    enabled: !!contactId,
    retry: (failureCount, error) => shouldRetry(error, failureCount),
    staleTime: 30 * 60 * 1000, // 30 minutes - data stays fresh and won't refetch
    gcTime: 35 * 60 * 1000, // 35 minutes - cache persists slightly longer than staleTime
  });

  // Create new note
  const createNoteMutation = useMutation({
    mutationFn: async (data: CreateNoteData): Promise<Note> => {
      // apiClient automatically unwraps { success: true, data: T } → returns T
      const note = await apiClient.post<Note>("/api/notes", {
        contactId,
        contentPlain: data.content,
        sourceType: "typed" as const,
      });
      return note;
    },
    onMutate: async (newNote) => {
      await queryClient.cancelQueries({ queryKey: ["/api/notes", contactId] });

      const previousNotes = queryClient.getQueryData<Note[]>(["/api/notes", contactId]);

      // Optimistically update with temporary note
      const tempNote: Note = {
        id: `temp-${Date.now()}`,
        userId: "",
        contactId,
        contentPlain: newNote.content,
        contentRich: {},
        tags: [],
        piiEntities: [],
        sourceType: "typed",
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      queryClient.setQueryData<Note[]>(["/api/notes", contactId], (old) => [
        tempNote,
        ...(old ?? []),
      ]);

      return { previousNotes };
    },
    onError: (_error, _variables, context) => {
      if (context?.previousNotes) {
        queryClient.setQueryData(["/api/notes", contactId], context.previousNotes);
      }
      toast({
        title: "Error",
        description: "Failed to create note",
        variant: "destructive",
      });
    },
    onSuccess: (newNote) => {
      // Update cache with real note (replace temp note)
      queryClient.setQueryData<Note[]>(["/api/notes", contactId], (old) => {
        if (!old) return [newNote];
        return old.map((note) => (note.id.startsWith("temp-") ? newNote : note));
      });
      // Don't invalidate - we just set the correct data above
      toast({
        title: "Success",
        description: "Note created successfully",
      });
    },
  });

  // Update existing note
  const updateNoteMutation = useMutation({
    mutationFn: async (data: UpdateNoteData): Promise<Note> => {
      // apiClient automatically unwraps { success: true, data: T } → returns T
      const note = await apiClient.put<Note>(`/api/notes/${data.noteId}`, {
        contentPlain: data.content,
      });
      return note;
    },
    onMutate: async (updatedNote) => {
      await queryClient.cancelQueries({ queryKey: ["/api/notes", contactId] });

      const previousNotes = queryClient.getQueryData<Note[]>(["/api/notes", contactId]);

      queryClient.setQueryData<Note[]>(["/api/notes", contactId], (old) => {
        if (!old) return [];
        return old.map((note) =>
          note.id === updatedNote.noteId
            ? { ...note, contentPlain: updatedNote.content, updatedAt: new Date() }
            : note,
        );
      });

      return { previousNotes };
    },
    onError: (_error, _variables, context) => {
      if (context?.previousNotes) {
        queryClient.setQueryData(["/api/notes", contactId], context.previousNotes);
      }
      toast({
        title: "Error",
        description: "Failed to update note",
        variant: "destructive",
      });
    },
    onSuccess: () => {
      // Optimistic update already applied in onMutate, no need to invalidate
      toast({
        title: "Success",
        description: "Note updated successfully",
      });
    },
  });

  // Delete note
  const deleteNoteMutation = useMutation({
    mutationFn: async (data: DeleteNoteData): Promise<{ deleted: boolean }> => {
      // apiClient automatically unwraps { success: true, data: T } → returns T
      const result = await apiClient.delete<{ deleted: boolean }>(`/api/notes/${data.noteId}`);
      return result;
    },
    onMutate: async (deletedNote) => {
      await queryClient.cancelQueries({ queryKey: ["/api/notes", contactId] });

      const previousNotes = queryClient.getQueryData<Note[]>(["/api/notes", contactId]);

      queryClient.setQueryData<Note[]>(["/api/notes", contactId], (old) => {
        if (!old) return [];
        return old.filter((note) => note.id !== deletedNote.noteId);
      });

      return { previousNotes };
    },
    onError: (_error, _variables, context) => {
      if (context?.previousNotes) {
        queryClient.setQueryData(["/api/notes", contactId], context.previousNotes);
      }
      toast({
        title: "Error",
        description: "Failed to delete note",
        variant: "destructive",
      });
    },
    onSuccess: () => {
      // Optimistic update already applied in onMutate, no need to invalidate
      toast({
        title: "Success",
        description: "Note deleted successfully",
      });
    },
  });

  return {
    notes: notesQuery.data ?? [],
    isLoading: notesQuery.isLoading,
    error: notesQuery.error,
    createNote: createNoteMutation.mutate,
    updateNote: updateNoteMutation.mutate,
    deleteNote: deleteNoteMutation.mutate,
    isCreating: createNoteMutation.isPending,
    isUpdating: updateNoteMutation.isPending,
    isDeleting: deleteNoteMutation.isPending,
    refetch: async (): Promise<{ data: Note[] | undefined; error: unknown }> => {
      const result = await notesQuery.refetch();
      return {
        data: result.data,
        error: result.error,
      };
    },
  };
}



===== src/lib/validation/jsonb.ts =====
/**
 * JSONB Validation and Sanitization Helpers
 *
 * Provides safe validation and sanitization for JSONB fields to prevent
 * sensitive data exposure and ensure type safety at the schema boundary.
 *
 * Per architecture blueprint: JSONB fields should not be exposed as z.unknown()
 * without validation. Use these helpers to create scoped, validated schemas.
 */

import { z } from "zod";

// ============================================================================
// CONTACT JSONB SCHEMAS
// ============================================================================

/**
 * Contact Address Schema
 * Validates address JSONB field structure
 */
export const ContactAddressSchema = z
  .object({
    street: z.string().optional(),
    city: z.string().optional(),
    state: z.string().optional(),
    postalCode: z.string().optional(),
    country: z.string().optional(),
  })
  .strict()
  .optional();

export type ContactAddress = z.infer<typeof ContactAddressSchema>;

/**
 * Contact Health Context Schema
 * Validates healthContext JSONB field - contains sensitive PII
 */
export const ContactHealthContextSchema = z
  .object({
    conditions: z.array(z.string()).optional(),
    medications: z.array(z.string()).optional(),
    allergies: z.array(z.string()).optional(),
    notes: z.string().optional(),
  })
  .strict()
  .optional();

export type ContactHealthContext = z.infer<typeof ContactHealthContextSchema>;

/**
 * Contact Preferences Schema
 * Validates preferences JSONB field
 */
export const ContactPreferencesSchema = z
  .object({
    communicationMethod: z.enum(["email", "phone", "sms", "any"]).optional(),
    preferredTime: z.string().optional(),
    timezone: z.string().optional(),
    language: z.string().optional(),
    marketingOptIn: z.boolean().optional(),
  })
  .strict()
  .optional();

export type ContactPreferences = z.infer<typeof ContactPreferencesSchema>;

/**
 * Contact Tags Schema
 * Validates tags as array of strings
 */
export const ContactTagsSchema = z.array(z.string()).optional();

// ============================================================================
// CONTACT DETAILS SCHEMA
// ============================================================================

/**
 * Contact Details Schema
 * Validates contacts.details JSONB field with unknown input handling
 */
export const ContactDetailsSchema = z
  .object({
    description: z.string().optional(),
    notes: z.string().optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    tags: z.array(z.string()).optional(),
    customFields: z.record(z.string(), z.unknown()).optional(),
  })
  .catchall(z.unknown()); // Allow extra fields

export type ContactDetails = z.infer<typeof ContactDetailsSchema>;

// ============================================================================
// TASK DETAILS SCHEMA
// ============================================================================

/**
 * Task Details Schema
 * Validates tasks.details JSONB field with unknown input handling
 */
export const TaskDetailsSchema = z
  .object({
    description: z.string().optional(),
    notes: z.string().optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    priority: z.enum(["low", "medium", "high", "urgent"]).optional(),
    estimatedDuration: z.number().optional(),
    customFields: z.record(z.string(), z.unknown()).optional(),
  })
  .catchall(z.unknown()); // Allow extra fields

export type TaskDetails = z.infer<typeof TaskDetailsSchema>;

// ============================================================================
// PROJECT DETAILS SCHEMA
// ============================================================================

/**
 * Project Details Schema
 * Validates projects.details JSONB field with unknown input handling
 */
export const ProjectDetailsSchema = z
  .object({
    description: z.string().optional(),
    metadata: z.record(z.string(), z.unknown()).optional(),
    status: z.enum(["planning", "active", "on-hold", "completed", "cancelled"]).optional(),
    startDate: z.string().optional(),
    endDate: z.string().optional(),
    budget: z.number().optional(),
    customFields: z.record(z.string(), z.unknown()).optional(),
  })
  .catchall(z.unknown()); // Allow extra fields

export type ProjectDetails = z.infer<typeof ProjectDetailsSchema>;

// ============================================================================
// LEGACY SCHEMAS (for backward compatibility)
// ============================================================================

/**
 * Task/Project Details Schema
 * Validates generic details JSONB field
 */
export const EntityDetailsSchema = z.record(z.string(), z.unknown()).optional();

/**
 * Safe transformation for nullable details to empty object
 */
export const NullableEntityDetailsSchema = z
  .union([z.record(z.string(), z.unknown()), z.null(), z.undefined()])
  .transform((value) => (value == null ? {} : value));

// ============================================================================
// AI INSIGHT CONTENT SCHEMAS
// ============================================================================

/**
 * AI Insight Content Schema (String or Object)
 * Validates AI-generated content which can be string or structured object
 */
export const AiInsightContentSchema = z.union([z.string(), z.record(z.string(), z.unknown())]);

export type AiInsightContent = z.infer<typeof AiInsightContentSchema>;

// ============================================================================
// SOURCE METADATA SCHEMAS
// ============================================================================

/**
 * Gmail Source Metadata Schema
 */
export const GmailSourceMetaSchema = z
  .object({
    from: z.string().optional(),
    to: z.array(z.string()).optional(),
    cc: z.array(z.string()).optional(),
    bcc: z.array(z.string()).optional(),
    subject: z.string().optional(),
    threadId: z.string().optional(),
    messageId: z.string().optional(),
    labelIds: z.array(z.string()).optional(),
    fetchedAt: z.string().optional(),
    matchedQuery: z.string().optional(),
  })
  .strict()
  .optional();

export type GmailSourceMeta = z.infer<typeof GmailSourceMetaSchema>;

/**
 * Calendar Source Metadata Schema
 */
export const CalendarSourceMetaSchema = z
  .object({
    attendees: z
      .array(
        z.object({
          email: z.string(),
          name: z.string().optional(),
          responseStatus: z.string().optional(),
        }),
      )
      .optional(),
    organizer: z
      .object({
        email: z.string(),
        name: z.string().optional(),
      })
      .optional(),
    eventId: z.string().optional(),
    calendarId: z.string().optional(),
    summary: z.string().optional(),
    description: z.string().optional(),
    location: z.string().optional(),
    startTime: z.string().optional(),
    endTime: z.string().optional(),
    isAllDay: z.boolean().optional(),
    recurring: z.boolean().optional(),
    status: z.string().optional(),
    fetchedAt: z.string().optional(),
  })
  .strict()
  .optional();

export type CalendarSourceMeta = z.infer<typeof CalendarSourceMetaSchema>;

/**
 * Generic Source Metadata Schema (fallback)
 */
export const GenericSourceMetaSchema = z.record(z.string(), z.unknown()).optional();

/**
 * Union of all source metadata types
 */
export const SourceMetaSchema = z.union([
  GmailSourceMetaSchema,
  CalendarSourceMetaSchema,
  GenericSourceMetaSchema,
]);

export type SourceMeta = z.infer<typeof SourceMetaSchema>;

// ============================================================================
// RAW EVENT PAYLOAD SCHEMAS
// ============================================================================

/**
 * Raw Event Payload Schema
 * Generic validation for raw event payloads
 */
export const RawEventPayloadSchema = z.record(z.string(), z.unknown());

export type RawEventPayload = z.infer<typeof RawEventPayloadSchema>;

// ============================================================================
// SANITIZATION HELPERS
// ============================================================================

/**
 * Redacts sensitive fields from JSONB objects before exposure
 */
export function redactSensitiveFields<T extends Record<string, unknown>>(
  data: T,
  sensitiveFields: string[],
): T {
  const redacted = { ...data } as T;
  for (const field of sensitiveFields) {
    if (field in redacted) {
      (redacted as Record<string, unknown>)[field] = "[REDACTED]";
    }
  }
  return redacted;
}

/**
 * Validates and sanitizes contact health context
 * Redacts sensitive fields for non-admin users
 */
export function sanitizeHealthContext(
  healthContext: unknown,
  includeFullDetails = false,
): ContactHealthContext | undefined {
  if (!healthContext) return undefined;

  const parsed = ContactHealthContextSchema.parse(healthContext);
  if (!includeFullDetails && parsed) {
    // Redact sensitive details for non-admin contexts
    return {
      ...parsed,
      medications: parsed.medications ? ["[REDACTED]"] : undefined,
      notes: parsed.notes ? "[REDACTED]" : undefined,
    };
  }

  return parsed;
}

/**
 * Safe JSONB parsing with schema validation
 * Takes unknown JSONB data, validates against schema, returns validated data or safe default
 * Does NOT throw - always returns a safe value
 */
export function safeParseJsonb<T>(data: unknown, schema: z.ZodSchema<T>): T {
  try {
    const result = schema.safeParse(data);
    if (result.success) {
      return result.data;
    }

    // If validation fails, return empty default based on schema type
    if (schema instanceof z.ZodObject) {
      return {} as T;
    }
    if (schema instanceof z.ZodArray) {
      return [] as T;
    }
    if (schema instanceof z.ZodRecord) {
      return {} as T;
    }

    // Fallback to null/undefined for other types
    return null as T;
  } catch {
    // If parsing completely fails, return safe default
    return null as T;
  }
}

/**
 * Sanitizes unknown JSONB data to safe object
 * Removes dangerous keys and ensures safe structure
 * Returns Record<string, unknown> or empty object
 */
export function sanitizeJsonb(data: unknown): Record<string, unknown> {
  try {
    // Handle null/undefined
    if (data == null) {
      return {};
    }

    // Handle non-objects
    if (typeof data !== "object") {
      return {};
    }

    // Handle arrays (convert to object with numeric keys)
    if (Array.isArray(data)) {
      const result: Record<string, unknown> = {};
      data.forEach((item, index) => {
        if (typeof item === "object" && item !== null) {
          result[index.toString()] = sanitizeJsonb(item);
        } else {
          result[index.toString()] = item;
        }
      });
      return result;
    }

    // Handle objects
    const result: Record<string, unknown> = {};
    const obj = data as Record<string, unknown>;

    for (const [key, value] of Object.entries(obj)) {
      // Skip dangerous keys that could cause prototype pollution
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        continue;
      }

      // Recursively sanitize nested objects
      if (typeof value === "object" && value !== null) {
        result[key] = sanitizeJsonb(value);
      } else {
        result[key] = value;
      }
    }

    return result;
  } catch {
    // If sanitization fails, return empty object
    return {};
  }
}

/**
 * Legacy safeParseJsonb function (for backward compatibility)
 * @deprecated Use the new safeParseJsonb function with proper typing
 */
export function safeParseJsonbLegacy<T extends z.ZodTypeAny>(
  schema: T,
  data: unknown,
): z.infer<T> | null {
  try {
    // Parse and validate
    return schema.parse(data);
  } catch {
    // Invalid JSONB structure
    return null;
  }
}



===== src/server/ai/contacts/utils/contact-utils.ts =====
// Utility for getting contact context

import { getDb } from "@/server/db/client";
import { contacts, interactions, notes, calendarEvents, contactTimeline } from "@/server/db/schema";
import { eq, sql } from "drizzle-orm";
import { logger } from "@/lib/observability";
import type { InferSelectModel } from "drizzle-orm";

interface FetchOptions {
  includeEvents?: boolean;
  includeInteractions?: boolean;
  includeNotes?: boolean;
  includeTimeline?: boolean;
  limit?: number;
}

// Default fetch options - immutable constant
const DEFAULT_FETCH_OPTIONS: Readonly<FetchOptions> = {
  includeEvents: true,
  includeInteractions: true,
  includeNotes: true,
  includeTimeline: true,
  limit: 20,
} as const;

export interface ContactWithContext {
  contact: InferSelectModel<typeof contacts> | null;
  calendarEvents: InferSelectModel<typeof calendarEvents>[];
  interactions: InferSelectModel<typeof interactions>[];
  notes: InferSelectModel<typeof notes>[];
  timeline: InferSelectModel<typeof contactTimeline>[];
}

export async function getContactData( // Renamed for generality
  userId: string,
  contactId: string,
  options: FetchOptions = {},
): Promise<ContactWithContext> {
  // Merge provided options with defaults
  const mergedOptions = { ...DEFAULT_FETCH_OPTIONS, ...options };
  const db = await getDb();

  const contact = await db.query.contacts.findFirst({
    where: eq(contacts.id, contactId),
  });

  if (!contact || contact.userId !== userId) {
    return { contact: null, calendarEvents: [], interactions: [], notes: [], timeline: [] };
  }

  // Calendar events query (adapted from raw SQL)
  const eventsResult = contact.primaryEmail
    ? await db.execute(sql`
        SELECT 
          ce.title,
          ce.description,
          ce.location,
          ce.start_time,
          ce.end_time,
          ce.event_type,
          ce.business_category,
          ce.attendees,
          ce.created_at
        FROM calendar_events ce
        WHERE ce.user_id = ${userId}
          AND ce.attendees IS NOT NULL
          AND ce.attendees::text LIKE ${`%${contact.primaryEmail}%`}
        ORDER BY ce.start_time DESC
        LIMIT ${mergedOptions.limit}
      `)
    : await db.execute(sql`
        SELECT 
          ce.title,
          ce.description,
          ce.location,
          ce.start_time,
          ce.end_time,
          ce.event_type,
          ce.business_category,
          ce.attendees,
          ce.created_at
        FROM calendar_events ce
        WHERE ce.user_id = ${userId}
          AND ce.attendees IS NOT NULL
        ORDER BY ce.start_time DESC
        LIMIT ${mergedOptions.limit}
      `);

  const contactInteractions = await db.query.interactions.findMany({
    where: sql`user_id = ${userId} AND contact_id = ${contactId}`,
    orderBy: sql`occurred_at DESC`,
    limit: mergedOptions.limit,
  });

  const contactNotes = await db.query.notes.findMany({
    where: sql`user_id = ${userId} AND contact_id = ${contactId}`,
    orderBy: sql`created_at DESC`,
    limit: mergedOptions.limit,
  });

  const timeline = await db.query.contactTimeline.findMany({
    where: sql`contact_id = ${contactId}`,
    orderBy: sql`occurred_at DESC`,
    limit: mergedOptions.limit,
  });

  logger.info("Contact data loaded", {
    operation: "load_contact_context",
  });

  return {
    contact,
    calendarEvents: (eventsResult.rows as InferSelectModel<typeof calendarEvents>[]) || [],
    interactions: contactInteractions,
    notes: contactNotes,
    timeline,
  };
}



===== src/server/ai/contacts/utils/validation-utils.ts =====
// Validation utilities for clients domain

import { CONTACT_STAGES } from "@/constants/contactStages";

// Maximum number of wellness tags allowed per client
const MAX_WELLNESS_TAGS = 8;

// Define ClientStage type from CONTACT_STAGES
type ClientStage = (typeof CONTACT_STAGES)[number];

// Type guard to check if a string is a valid ClientStage
function isClientStage(stage: string): stage is ClientStage {
  return (CONTACT_STAGES as readonly string[]).includes(stage);
}

export function validateStage(stage: string): ClientStage {
  return isClientStage(stage) ? stage : "Prospect";
}

export function validateTags(tags: string[], maxTags: number = MAX_WELLNESS_TAGS): string[] {
  // Define valid wellness tags
  const validTags: readonly string[] = ["Yoga", "Massage", "Meditation", "Pilates", "Reiki", "Acupuncture"] as const;
  return tags
    .filter((tag): tag is string => validTags.includes(tag))
    .slice(0, maxTags);
}



===== packages/repo/src/search.repo.ts =====
import { eq, and, ilike, or } from "drizzle-orm";
import { contacts, notes, interactions, tasks, embeddings } from "@/server/db/schema";
import { DbClient } from "@/server/db/client";

export interface SearchResultDTO {
  id: string;
  type: "contact" | "note" | "interaction" | "calendar_event" | "task";
  title: string;
  content: string;
  metadata: Record<string, unknown>;
  similarity?: number;
  score?: number;
  source?: "traditional" | "semantic" | "hybrid";
  createdAt?: Date | null;
  updatedAt?: Date | null;
}

export interface TraditionalSearchParams {
  userId: string;
  query: string;
  limit: number;
  types?: Array<"contact" | "note" | "interaction" | "calendar_event" | "task">;
}

export interface SemanticSearchParams {
  userId: string;
  embedding: number[];
  limit: number;
  similarityThreshold?: number;
  types?: Array<"contact" | "note" | "interaction" | "calendar_event" | "task">;
}

export class SearchRepository {
  constructor(private readonly db: DbClient) {}

  /**
   * Perform traditional text-based search across multiple entity types
   */
  async searchTraditional(params: TraditionalSearchParams): Promise<SearchResultDTO[]> {
    const { userId, query, limit, types } = params;
    const searchTerm = `%${query}%`;
    const results: SearchResultDTO[] = [];

    // Calculate limit per type - distribute evenly
    const enabledTypes = types || ["contact", "note", "interaction", "calendar_event", "task"];
    const limitPerType = Math.max(1, Math.ceil(limit / enabledTypes.length));

    // Search contacts
    if (enabledTypes.includes("contact")) {
      const contactRows = await this.db
        .select()
        .from(contacts)
        .where(
          and(
            eq(contacts.userId, userId),
            or(
              ilike(contacts.displayName, searchTerm),
              ilike(contacts.primaryEmail, searchTerm),
              ilike(contacts.primaryPhone, searchTerm),
            ),
          ),
        )
        .limit(limitPerType);

      for (const row of contactRows) {
        results.push({
          id: row.id,
          type: "contact",
          title: row.displayName,
          content: "", // Let service layer format content from metadata
          metadata: {
            email: row.primaryEmail,
            phone: row.primaryPhone,
            lifecycleStage: row.lifecycleStage,
            tags: row.tags,
          },
          score: 1,
          source: "traditional",
          createdAt: row.createdAt,
          updatedAt: row.updatedAt,
        });
      }
    }

    // Search notes
    if (enabledTypes.includes("note")) {
      const noteRows = await this.db
        .select({
          note: notes,
          contact: contacts,
        })
        .from(notes)
        .leftJoin(contacts, eq(notes.contactId, contacts.id))
        .where(and(eq(notes.userId, userId), ilike(notes.contentPlain, searchTerm)))
        .limit(limitPerType);

      for (const row of noteRows) {
        results.push({
          id: row.note.id,
          type: "note",
          title:
            row.note.contentPlain.slice(0, 50) + (row.note.contentPlain.length > 50 ? "..." : ""),
          content: row.note.contentPlain,
          metadata: {
            contactId: row.note.contactId,
            contactName: row.contact?.displayName,
            tags: row.note.tags,
            sourceType: row.note.sourceType,
          },
          score: 1,
          source: "traditional",
          createdAt: row.note.createdAt,
          updatedAt: row.note.updatedAt,
        });
      }
    }

    // Search interactions
    if (enabledTypes.includes("interaction")) {
      const interactionRows = await this.db
        .select({
          interaction: interactions,
          contact: contacts,
        })
        .from(interactions)
        .leftJoin(contacts, eq(interactions.contactId, contacts.id))
        .where(
          and(
            eq(interactions.userId, userId),
            or(ilike(interactions.subject, searchTerm), ilike(interactions.bodyText, searchTerm)),
          ),
        )
        .limit(limitPerType);

      for (const row of interactionRows) {
        results.push({
          id: row.interaction.id,
          type: "interaction",
          title: row.interaction.subject || `${row.interaction.type} interaction`,
          content: row.interaction.bodyText || "",
          metadata: {
            type: row.interaction.type,
            contactId: row.interaction.contactId,
            contactName: row.contact?.displayName,
            occurredAt: row.interaction.occurredAt,
            source: row.interaction.source,
          },
          score: 1,
          source: "traditional",
          createdAt: row.interaction.createdAt,
        });
      }
    }

    // Search calendar events - DISABLED: calendar_events table removed
    // Calendar data is now in raw_events with provider='calendar'
    // TODO: Implement calendar search via raw_events/interactions when needed
    if (enabledTypes.includes("calendar_event")) {
      // Placeholder - calendar events search not yet implemented for new architecture
    }

    // Search tasks
    if (enabledTypes.includes("task")) {
      const taskRows = await this.db
        .select()
        .from(tasks)
        .where(and(eq(tasks.userId, userId), or(ilike(tasks.name, searchTerm))))
        .limit(limitPerType);

      for (const row of taskRows) {
        results.push({
          id: row["id"],
          type: "task",
          title: row["name"],
          content: JSON.stringify(row["details"] || {}),
          metadata: {
            status: row["status"],
            priority: row["priority"],
            dueDate: row["dueDate"],
            projectId: row["projectId"],
          },
          score: 1,
          source: "traditional",
          createdAt: row["createdAt"],
          updatedAt: row["updatedAt"],
        });
      }
    }

    // Sort by creation date (most recent first) and limit
    const sortedResults = results
      .sort((a, b) => {
        const aTime = a.createdAt?.getTime() || 0;
        const bTime = b.createdAt?.getTime() || 0;
        return bTime - aTime;
      })
      .slice(0, limit);

    return sortedResults;
  }

  /**
   * Perform semantic search using embeddings
   */
  async searchSemantic(params: SemanticSearchParams): Promise<SearchResultDTO[]> {
    const { userId, embedding, limit, similarityThreshold = 0.7 } = params;

    // Use the semantic_search RPC function if it exists
    // For now, let's implement a basic embeddings search
    const embeddingRows = await this.db
      .select()
      .from(embeddings)
      .where(eq(embeddings.userId, userId))
      .limit(limit * 2); // Get more results to filter

    // Convert embedding string back to array and calculate similarity
    const results: SearchResultDTO[] = [];

    for (const row of embeddingRows) {
      if (!row.embedding) continue;

      // Skip if types filter is provided and this row's ownerType is not included
      if (
        params.types &&
        params.types.length > 0 &&
        !params.types.includes(
          row.ownerType as "contact" | "note" | "interaction" | "calendar_event" | "task",
        )
      ) {
        continue;
      }

      try {
        const rowEmbedding = JSON.parse(row.embedding) as number[];
        const similarity = calculateCosineSimilarity(embedding, rowEmbedding);

        if (similarity >= similarityThreshold) {
          // Get the actual entity based on ownerType and ownerId
          const entityData = await this.getEntityById(userId, row.ownerType, row.ownerId);

          if (entityData) {
            results.push({
              ...entityData,
              similarity,
              score: similarity,
              source: "semantic",
            });
          }
        }
      } catch (_error) {
        // Skip malformed embedding data
        continue;
      }
    }

    // Sort by similarity (highest first) and limit
    const sortedResults = results
      .sort((a, b) => (b.similarity || 0) - (a.similarity || 0))
      .slice(0, limit);

    return sortedResults;
  }

  /**
   * Get entity by type and ID for semantic search results
   */
  private async getEntityById(
    userId: string,
    ownerType: string,
    ownerId: string,
  ): Promise<SearchResultDTO | null> {
    switch (ownerType) {
      case "contact": {
        const [contact] = await this.db
          .select()
          .from(contacts)
          .where(and(eq(contacts.userId, userId), eq(contacts.id, ownerId)))
          .limit(1);

        if (!contact) return null;

        return {
          id: contact.id,
          type: "contact",
          title: contact.displayName,
          content: "", // Let service layer format content from metadata
          metadata: {
            email: contact.primaryEmail,
            phone: contact.primaryPhone,
            lifecycleStage: contact.lifecycleStage,
            tags: contact.tags,
          },
          createdAt: contact.createdAt,
          updatedAt: contact.updatedAt,
        };
      }

      case "note": {
        const noteRows = await this.db
          .select({
            note: notes,
            contact: contacts,
          })
          .from(notes)
          .leftJoin(contacts, eq(notes.contactId, contacts.id))
          .where(and(eq(notes.userId, userId), eq(notes.id, ownerId)))
          .limit(1);

        const row = noteRows[0];
        if (!row) return null;

        return {
          id: row.note.id,
          type: "note",
          title:
            row.note.contentPlain.slice(0, 50) + (row.note.contentPlain.length > 50 ? "..." : ""),
          content: row.note.contentPlain,
          metadata: {
            contactId: row.note.contactId,
            contactName: row.contact?.displayName,
            tags: row.note.tags,
            sourceType: row.note.sourceType,
          },
          createdAt: row.note.createdAt,
          updatedAt: row.note.updatedAt,
        };
      }

      case "interaction": {
        const interactionRows = await this.db
          .select({
            interaction: interactions,
            contact: contacts,
          })
          .from(interactions)
          .leftJoin(contacts, eq(interactions.contactId, contacts.id))
          .where(and(eq(interactions.userId, userId), eq(interactions.id, ownerId)))
          .limit(1);

        const row = interactionRows[0];
        if (!row) return null;

        return {
          id: row.interaction.id,
          type: "interaction",
          title: row.interaction.subject || `${row.interaction.type} interaction`,
          content: row.interaction.bodyText || "",
          metadata: {
            type: row.interaction.type,
            contactId: row.interaction.contactId,
            contactName: row.contact?.displayName,
            occurredAt: row.interaction.occurredAt,
            source: row.interaction.source,
          },
          createdAt: row.interaction.createdAt,
        };
      }

      case "calendar_event": {
        // Calendar events table removed - data is now in raw_events
        // TODO: Implement calendar event retrieval via raw_events/interactions
        return null;
      }

      case "task": {
        const [task] = await this.db
          .select()
          .from(tasks)
          .where(and(eq(tasks.userId, userId), eq(tasks.id, ownerId)))
          .limit(1);

        if (!task) return null;

        return {
          id: task["id"],
          type: "task",
          title: task["name"],
          content: JSON.stringify(task["details"] || {}),
          metadata: {
            status: task["status"],
            priority: task["priority"],
            dueDate: task["dueDate"],
            projectId: task["projectId"],
          },
          createdAt: task["createdAt"],
          updatedAt: task["updatedAt"],
        };
      }

      default:
        return null;
    }
  }
}

/**
 * Calculate cosine similarity between two embedding vectors
 */
function calculateCosineSimilarity(a: number[], b: number[]): number {
  if (a.length !== b.length) return 0;

  let dotProduct = 0;
  let normA = 0;
  let normB = 0;

  for (let i = 0; i < a.length; i++) {
    const aVal = a[i] ?? 0;
    const bVal = b[i] ?? 0;
    dotProduct += aVal * bVal;
    normA += aVal * aVal;
    normB += bVal * bVal;
  }

  if (normA === 0 || normB === 0) return 0;

  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}

/**
 * Factory function to create SearchRepository instance
 */
export function createSearchRepository(db: DbClient): SearchRepository {
  return new SearchRepository(db);
}



===== src/server/jobs/processors/insight.ts =====
import type { JobRecord } from "@/server/jobs/types";
import { getDb } from "@/server/db/client";
import { contacts, interactions } from "@/server/db/schema";
import { eq, desc, and } from "drizzle-orm";
import { sql } from "drizzle-orm";
import { logger } from "@/lib/observability";
import {
  generateNextSteps,
  generateRiskAssessment,
  generatePersonaInsight,
} from "@/server/ai/core/llm.service"; // Added /core
import { generateContactInsights } from "@/server/ai/contacts/generate-contact-insights";

// Extended insight types from insight-writer
type InsightKind =
  | "summary"
  | "next_step"
  | "risk"
  | "persona"
  | "thread_summary"
  | "next_best_action"
  | "weekly_digest"
  | "lead_score"
  | "duplicate_contact_suspected";
type InsightSubjectType = "contact" | "segment" | "inbox";

// Generated insight structure from insight-writer

// Insight generation task structure

// Context types for different insight kinds
interface SummaryContext {
  contactId: string;
  recentInteractions: string[];
  lastContactDate?: string;
}

interface NextStepContext {
  contactId: string;
  currentStage: string;
  recentActivities: string[];
}

interface RiskContext {
  contactId: string;
  warningSignals: string[];
  lastInteractionDate?: string;
}

interface PersonaContext {
  contactId: string;
  demographics: Record<string, unknown>;
  preferences: string[];
}

type InsightContext = SummaryContext | NextStepContext | RiskContext | PersonaContext;

interface InsightRequest {
  subjectType: string;
  subjectId: string;
  kind: "summary" | "next_step" | "risk" | "persona";
  context: InsightContext;
}

/**
 * InsightWriter class - handles all insight generation and management
 * Merged functionality from insight-writer.ts
 */
export class InsightWriter {
  /**
   * Generate and store AI insight
   */
  async generateInsight(task: InsightGenerationTask): Promise<string | null> {
    try {
      // 1. Generate insight content based on type and context
      const insight = await this.generateInsightContent(task);
      if (!insight) return null;

      // 2. Create AI insight record
      const aiInsight: NewAiInsight = {
        userId: task.userId,
        subjectType: task.subjectType,
        subjectId: task.subjectId,
        kind: task.kind,
        content: {
          title: insight.title,
          summary: insight.summary,
          confidence: insight.confidence,
          tags: insight.tags,
          priority: insight.priority,
          status: "new",
          props: insight.props,
          actions: insight.actions,
        },
        model: this.getModelForInsightType(task.kind),
      };

      // 3. Store insight with automatic fingerprinting
      const insightId = await this.storeInsight(aiInsight);
      return insightId;
    } catch (error) {
      await logger.error(
        "Failed to generate insight",
        {
          operation: "jobs.insight.generate",
          additionalData: {
            taskKind: task.kind,
            userId: task.userId?.slice(0, 8) + "..." ?? "unknown",
          },
        },
        error instanceof Error ? error : undefined,
      );
      return null;
    }
  }

  /**
   * Generate thread summary insight
   */
  async generateThreadSummary(
    userId: string,
    contactId: string,
    interactionIds: string[],
  ): Promise<string | null> {
    const task: InsightGenerationTask = {
      userId,
      subjectType: "contact",
      subjectId: contactId,
      kind: "thread_summary",
      context: { interactionIds },
    };

    return await this.generateInsight(task);
  }

  /**
   * Generate next best action insight
   */
  async generateNextBestAction(
    userId: string,
    contactId: string,
    context?: Record<string, unknown>,
  ): Promise<string | null> {
    const task: InsightGenerationTask = {
      userId,
      subjectType: "contact",
      subjectId: contactId,
      kind: "next_best_action",
      context,
    };

    return await this.generateInsight(task);
  }

  /**
   * Generate weekly digest insight
   */
  async generateWeeklyDigest(userId: string): Promise<string | null> {
    const task: InsightGenerationTask = {
      userId,
      subjectType: "inbox",
      subjectId: null,
      kind: "weekly_digest",
    };

    return await this.generateInsight(task);
  }

  private async generateInsightContent(
    task: InsightGenerationTask,
  ): Promise<GeneratedInsight | null> {
    // Generate insights based on kind
    switch (task.kind) {
      case "thread_summary":
        return this.generateThreadSummaryContent(task);

      case "next_best_action":
        return this.generateNextBestActionContent(task);

      case "weekly_digest":
        return this.generateWeeklyDigestContent(task);

      case "lead_score":
        return this.generateLeadScoreContent(task);

      case "summary":
      case "next_step":
      case "risk":
      case "persona":
        // Use existing LLM service for these types
        return await this.generateLLMInsight(task);

      default:
        await logger.warn("Insight generation not implemented", {
          operation: "jobs.insight.generate_by_kind",
          additionalData: { taskKind: task.kind },
        });
        return null;
    }
  }

  private async generateLLMInsight(task: InsightGenerationTask): Promise<GeneratedInsight | null> {
    const db = await getDb();

    if (task.subjectType === "contact" && task.subjectId) {
      // Get contact and interactions for LLM service
      const [contact] = await db
        .select()
        .from(contacts)
        .where(and(eq(contacts.id, task.subjectId), eq(contacts.userId, task.userId)))
        .limit(1);

      if (!contact) return null;

      const contactInteractions = await db
        .select({
          type: interactions.type,
          subject: interactions.subject,
          bodyText: interactions.bodyText,
          occurredAt: interactions.occurredAt,
          source: interactions.source,
        })
        .from(interactions)
        .where(
          and(eq(interactions.userId, task.userId), eq(interactions.contactId, task.subjectId)),
        )
        .orderBy(desc(interactions.occurredAt))
        .limit(50);

      const request: InsightRequest = {
        subjectType: "contact",
        subjectId: task.subjectId,
        kind: task.kind as "summary" | "next_step" | "risk" | "persona",
        context: {
          contact: {
            displayName: contact.displayName,
            ...(contact.primaryEmail ? { primaryEmail: contact.primaryEmail } : {}),
            ...(contact.primaryPhone ? { primaryPhone: contact.primaryPhone } : {}),
          },
          interactions: contactInteractions.map((i) => ({
            type: i.type,
            ...(i.subject ? { subject: i.subject } : {}),
            ...(i.bodyText ? { bodyText: i.bodyText } : {}),
            occurredAt: i.occurredAt,
            ...(i.source ? { source: i.source } : {}),
          })),
        },
      };

      let llmResult: unknown;
      if (task.kind === "summary") {
        // Validate email before processing
        const email = request.context.contact.primaryEmail;
        if (!email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
          throw new Error("Invalid or missing email address for contact summary generation");
        }

        // Use generateContactInsights for contact summaries
        llmResult = await generateContactInsights(task.userId, email, {});
      } else {
        switch (task.kind) {
          case "next_step":
            llmResult = await generateNextSteps(task.userId, request);
            break;
          case "risk":
            llmResult = await generateRiskAssessment(task.userId, request);
            break;
          case "persona":
            llmResult = await generatePersonaInsight(task.userId, request);
            break;
        }
      }

      // Convert LLM result to GeneratedInsight format
      if (typeof llmResult === "object" && llmResult !== null) {
        const result = llmResult as Record<string, unknown>;
        const actions = Array.isArray(result["actions"])
          ? (result["actions"] as Array<{
              type: string;
              label: string;
              payload: Record<string, unknown>;
            }>)
          : [];
        return {
          title: String(result["title"] ?? `${task.kind} insight`),
          summary: String(result["summary"] ?? result["content"] ?? "Generated insight"),
          confidence: Number(result["confidence"] ?? 0.7),
          tags: Array.isArray(result["tags"]) ? (result["tags"] as string[]) : [task.kind],
          priority: (result["priority"] as "low" | "medium" | "high" | "critical") ?? "medium",
          props: (result["props"] as Record<string, unknown>) ?? result,
          actions,
        };
      }
    }

    return null;
  }

  private async generateThreadSummaryContent(
    task: InsightGenerationTask,
  ): Promise<GeneratedInsight> {
    const db = await getDb();

    if (!task.subjectId || !task.context?.["interactionIds"]) {
      throw new Error("Thread summary requires contact ID and interaction IDs");
    }

    // interactionIds available in context if needed: task.context['interactionIds']

    // Get the specified interactions
    const threadInteractions = await db
      .select({
        type: interactions.type,
        subject: interactions.subject,
        bodyText: interactions.bodyText,
        occurredAt: interactions.occurredAt,
        source: interactions.source,
      })
      .from(interactions)
      .where(and(eq(interactions.userId, task.userId), eq(interactions.contactId, task.subjectId)))
      .orderBy(desc(interactions.occurredAt))
      .limit(20);

    // Generate summary based on actual interaction data
    const totalInteractions = threadInteractions.length;
    const interactionTypes = Array.from(new Set(threadInteractions.map((i) => i.type)));
    const hasEmailContent = threadInteractions.some((i) => i.bodyText);

    return {
      title: `Thread Summary: ${totalInteractions} interactions`,
      summary: `Recent thread contains ${totalInteractions} ${interactionTypes.join(", ")} interactions${hasEmailContent ? " with detailed content" : ""}.`,
      confidence: 0.8,
      tags: ["thread", "summary", ...interactionTypes],
      priority: "medium",
      props: {
        totalInteractions,
        interactionTypes,
        dateRange: {
          from: threadInteractions[threadInteractions.length - 1]?.occurredAt,
          to: threadInteractions[0]?.occurredAt,
        },
        hasContent: hasEmailContent,
      },
    };
  }

  private async generateNextBestActionContent(
    task: InsightGenerationTask,
  ): Promise<GeneratedInsight> {
    const db = await getDb();

    if (!task.subjectId) {
      throw new Error("Next best action requires contact ID");
    }

    // Get contact and recent interactions to determine best action
    const [contact] = await db
      .select()
      .from(contacts)
      .where(and(eq(contacts.id, task.subjectId), eq(contacts.userId, task.userId)))
      .limit(1);

    if (!contact) {
      throw new Error(`Contact not found: ${task.subjectId}`);
    }

    const recentInteractions = await db
      .select({
        type: interactions.type,
        subject: interactions.subject,
        occurredAt: interactions.occurredAt,
      })
      .from(interactions)
      .where(and(eq(interactions.userId, task.userId), eq(interactions.contactId, task.subjectId)))
      .orderBy(desc(interactions.occurredAt))
      .limit(10);

    const hasRecentActivity = recentInteractions.length > 0;
    const lastInteractionDays = hasRecentActivity
      ? (() => {
          const firstInteraction = recentInteractions[0];
          if (!firstInteraction) {
            throw new Error(
              "Unexpected: recentInteractions has length > 0 but first element is undefined",
            );
          }
          return Math.floor(
            (Date.now() - new Date(firstInteraction.occurredAt).getTime()) / (1000 * 60 * 60 * 24),
          );
        })()
      : 999;

    let suggestion = "Follow up with contact";
    let priority: "low" | "medium" | "high" | "critical" = "medium";

    if (lastInteractionDays > 30) {
      suggestion = "Re-engage with contact - no recent activity";
      priority = "high";
    } else if (lastInteractionDays < 7) {
      suggestion = "Continue active conversation";
      priority = "high";
    }

    return {
      title: suggestion,
      summary: `Contact has ${recentInteractions.length} recent interactions. Last activity: ${lastInteractionDays} days ago.`,
      confidence: 0.7,
      tags: ["follow-up", "engagement", contact.stage ?? "unknown"],
      priority,
      props: {
        contactName: contact.displayName,
        lastInteractionDays,
        recentInteractionCount: recentInteractions.length,
        interactionTypes: Array.from(new Set(recentInteractions.map((i) => i.type))),
      },
      actions: [
        {
          type: "create_task",
          label: "Create follow-up task",
          payload: {
            title: `Follow up with ${contact.displayName}`,
            priority,
            contactId: contact.id,
          },
        },
      ],
    };
  }

  private async generateWeeklyDigestContent(
    task: InsightGenerationTask,
  ): Promise<GeneratedInsight> {
    const db = await getDb();

    // Get interactions from the last 7 days
    const weekAgo = new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);

    const weeklyInteractions = await db
      .select({
        contactId: interactions.contactId,
        type: interactions.type,
        occurredAt: interactions.occurredAt,
      })
      .from(interactions)
      .where(and(eq(interactions.userId, task.userId)))
      .orderBy(desc(interactions.occurredAt))
      .limit(200);

    // Get all contacts for the user
    const allContacts = await db
      .select({
        id: contacts.id,
        displayName: contacts.displayName,
        stage: contacts.stage,
        createdAt: contacts.createdAt,
      })
      .from(contacts)
      .where(eq(contacts.userId, task.userId));

    const totalInteractions = weeklyInteractions.length;
    const uniqueContacts = new Set(weeklyInteractions.map((i) => i.contactId).filter(Boolean)).size;
    const newContacts = allContacts.filter(
      (c) => new Date(c.createdAt).getTime() > weekAgo.getTime(),
    ).length;

    // Find active contacts (interactions in last 7 days)
    const activeContactIds = new Set(
      weeklyInteractions
        .filter((i) => new Date(i.occurredAt).getTime() > weekAgo.getTime())
        .map((i) => i.contactId)
        .filter(Boolean),
    );

    const activeContacts = allContacts.filter((c) => activeContactIds.has(c.id));
    const opportunities = activeContacts.filter(
      (c) => c.stage === "Prospect" || c.stage === "New Client",
    );

    return {
      title: `Weekly digest: ${opportunities.length} opportunities, ${totalInteractions} interactions`,
      summary: `This week: ${totalInteractions} interactions with ${uniqueContacts} contacts. ${newContacts} new contacts added.`,
      confidence: 0.9,
      tags: ["digest", "weekly", "summary"],
      priority: "medium",
      props: {
        dateRange: {
          from: weekAgo.toISOString(),
          to: new Date().toISOString(),
        },
        metrics: {
          totalInteractions,
          uniqueContacts,
          newContacts,
          opportunityContacts: opportunities.length,
        },
        breakdown: weeklyInteractions.reduce(
          (acc, i) => {
            acc[i.type] = (acc[i.type] ?? 0) + 1;
            return acc;
          },
          {} as Record<string, number>,
        ),
      },
    };
  }

  private async generateLeadScoreContent(task: InsightGenerationTask): Promise<GeneratedInsight> {
    const db = await getDb();

    if (!task.subjectId) {
      throw new Error("Lead score requires contact ID");
    }

    // Get contact and interactions for scoring
    const [contact] = await db
      .select()
      .from(contacts)
      .where(and(eq(contacts.id, task.subjectId), eq(contacts.userId, task.userId)))
      .limit(1);

    if (!contact) {
      throw new Error(`Contact not found: ${task.subjectId}`);
    }

    const contactInteractions = await db
      .select({
        type: interactions.type,
        occurredAt: interactions.occurredAt,
        bodyText: interactions.bodyText,
      })
      .from(interactions)
      .where(and(eq(interactions.userId, task.userId), eq(interactions.contactId, task.subjectId)))
      .orderBy(desc(interactions.occurredAt))
      .limit(30);

    // Calculate lead score based on real data
    const totalInteractions = contactInteractions.length;
    const recentInteractions = contactInteractions.filter(
      (i) => new Date(i.occurredAt).getTime() > Date.now() - 30 * 24 * 60 * 60 * 1000, // last 30 days
    ).length;
    const hasEmailContent = contactInteractions.some((i) => i.bodyText);
    const hasContact = !!contact.primaryEmail || !!contact.primaryPhone;

    // Simple scoring algorithm
    let score = 0;
    score += Math.min(totalInteractions * 10, 40); // up to 40 points for interactions
    score += Math.min(recentInteractions * 15, 30); // up to 30 points for recent activity
    score += hasEmailContent ? 20 : 0; // 20 points for email content
    score += hasContact ? 10 : 0; // 10 points for contact info

    const scoreCategory = score >= 70 ? "high" : score >= 40 ? "medium" : "low";
    const priority: "low" | "medium" | "high" | "critical" =
      score >= 80 ? "critical" : score >= 60 ? "high" : "medium";

    return {
      title: `Lead score: ${score}/100`,
      summary: `${scoreCategory.charAt(0).toUpperCase() + scoreCategory.slice(1)}-scoring prospect with ${totalInteractions} total interactions, ${recentInteractions} recent.`,
      confidence: 0.8,
      tags: ["lead", "scoring", scoreCategory],
      priority,
      props: {
        score0To100: score,
        category: scoreCategory,
        breakdown: {
          totalInteractions,
          recentInteractions,
          hasEmailContent,
          hasContactInfo: hasContact,
        },
        reasons: [
          `${totalInteractions} total interactions`,
          `${recentInteractions} recent interactions`,
          ...(hasEmailContent ? ["Has detailed email content"] : []),
          ...(hasContact ? ["Complete contact information"] : []),
        ],
      },
      actions:
        score >= 70
          ? [
              {
                type: "create_task",
                label: "High priority follow-up",
                payload: {
                  title: `Follow up with high-scoring lead: ${contact.displayName}`,
                  priority: "high",
                  contactId: contact.id,
                },
              },
            ]
          : [],
    };
  }

  private getModelForInsightType(kind: InsightKind): string {
    // Map insight kinds to appropriate AI models
    const modelMappings: Record<string, string> = {
      thread_summary: "gpt-5",
      next_best_action: "gpt-5",
      lead_score: "omni.ml.rankerv2",
      weekly_digest: "omni.ml.digestv1",
      duplicate_contact_suspected: "omni.ml.dedupe-v3",
      summary: "openrouter/auto",
      next_step: "openrouter/auto",
      risk: "openrouter/auto",
      persona: "openrouter/auto",
    };

    return modelMappings[kind] ?? "gpt-5";
  }

  private async storeInsight(insight: NewAiInsight): Promise<string> {
    const db = await getDb();

    const result = await db.execute(sql`
      INSERT INTO ai_insights (
        user_id, subject_type, subject_id, kind, content, model, created_at
      ) VALUES (
        ${insight.userId}, ${insight.subjectType}, ${insight.subjectId},
        ${insight.kind}, ${JSON.stringify(insight.content)}, ${insight.model},
        ${new Date().toISOString()}
      )
      RETURNING id
    `);

    const row = result[0] as { id: string };
    return row.id;
  }

  /**
   * Get recent insights for user
   */
  async getRecentInsights(
    userId: string,
    options: {
      subjectType?: InsightSubjectType;
      subjectId?: string;
      kinds?: InsightKind[];
      limit?: number;
    } = {},
  ): Promise<Array<Record<string, unknown>>> {
    const db = await getDb();

    const result = await db.execute(sql`
      SELECT id, subject_type, subject_id, kind, content, model, created_at
      FROM ai_insights
      WHERE user_id = ${userId}
        ${options.subjectType ? sql`AND subject_type = ${options.subjectType}` : sql``}
        ${options.subjectId ? sql`AND subject_id = ${options.subjectId}` : sql``}
        ${options.kinds?.length ? sql`AND kind = ANY(${options.kinds})` : sql``}
      ORDER BY created_at DESC
      LIMIT ${options.limit ?? 20}
    `);

    return result as Array<Record<string, unknown>>;
  }

  /**
   * Mark insight as viewed/dismissed/applied
   */
  async updateInsightStatus(
    insightId: string,
    status: "viewed" | "dismissed" | "applied",
  ): Promise<void> {
    const db = await getDb();

    await db.execute(sql`
      UPDATE ai_insights
      SET content = jsonb_set(content, '{status}', ${JSON.stringify(status)})
      WHERE id = ${insightId}
    `);
  }
}

export async function runInsight(job: JobRecord<"insight">): Promise<void> {
  const startTime = Date.now();
  const insightWriter = new InsightWriter();

  try {
    // Parse job payload
    const payload = job.payload;
    const subjectType = payload.subjectType ?? "inbox";
    const subjectId = payload.subjectId;
    const kind = payload.kind ?? "summary";

    await logger.info("Starting insight generation", {
      operation: "insight_generate",
      additionalData: {
        userId: job.userId,
        subjectType,
        subjectId,
        kind,
        jobId: job.id,
      },
    });

    // Create task for InsightWriter
    const task: InsightGenerationTask = {
      userId: job.userId,
      subjectType,
      subjectId: subjectId ?? null,
      kind,
      context: payload.context,
    };

    // Generate insight using InsightWriter
    const insightId = await insightWriter.generateInsight(task);

    if (!insightId) {
      throw new Error(`Failed to generate insight for kind: ${kind}`);
    }

    const duration = Date.now() - startTime;
    await logger.info("Insight generation completed", {
      operation: "insight_generate",
      additionalData: {
        userId: job.userId,
        subjectType,
        kind,
        duration,
        insightId,
        jobId: job.id,
      },
    });
  } catch (error) {
    const duration = Date.now() - startTime;
    await logger.error(
      "Insight generation failed",
      {
        operation: "insight_generate",
        additionalData: {
          userId: job.userId,
          duration,
          jobId: job.id,
        },
      },
      error instanceof Error ? error : new Error(String(error)),
    );
    throw error;
  }
}



===== src/app/onboard/[token]/_components/PreferencesSection.tsx =====
"use client";

import { Control, FieldErrors, useController } from "react-hook-form";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Checkbox } from "@/components/ui/checkbox";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { OnboardingFormData } from "@/app/onboard/[token]/_components/OnboardingForm";

type SessionTime = "mornings" | "afternoons" | "evenings" | "weekends";
type CommunicationPref = "email" | "phone" | "text";

interface PreferencesSectionProps {
  control: Control<OnboardingFormData>;
  errors: FieldErrors<OnboardingFormData>;
}

export function PreferencesSection({ control, errors }: PreferencesSectionProps) {
  const sessionTimeController = useController({
    control,
    name: "preferences.sessionTimes",
    defaultValue: [],
  });

  const communicationController = useController({
    control,
    name: "preferences.communicationPrefs",
    defaultValue: [],
  });

  const sessionTimeOptions: Array<{ value: SessionTime; label: string }> = [
    { value: "mornings", label: "Mornings (6 AM - 12 PM)" },
    { value: "afternoons", label: "Afternoons (12 PM - 6 PM)" },
    { value: "evenings", label: "Evenings (6 PM - 10 PM)" },
    { value: "weekends", label: "Weekends" },
  ];

  const communicationOptions: Array<{ value: CommunicationPref; label: string }> = [
    { value: "email", label: "Email" },
    { value: "phone", label: "Phone Call" },
    { value: "text", label: "Text Message" },
  ];

  const handleSessionTimeChange = (value: SessionTime, checked: boolean) => {
    const currentValues = sessionTimeController.field.value ?? [];
    if (checked) {
      if (!currentValues.includes(value)) {
        sessionTimeController.field.onChange([...currentValues, value]);
      }
    } else {
      sessionTimeController.field.onChange(currentValues.filter((item) => item !== value));
    }
  };

  const handleCommunicationChange = (value: CommunicationPref, checked: boolean) => {
    const currentValues = communicationController.field.value ?? [];
    if (checked) {
      if (!currentValues.includes(value)) {
        communicationController.field.onChange([...currentValues, value]);
      }
    } else {
      communicationController.field.onChange(currentValues.filter((item) => item !== value));
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Preferences</CardTitle>
        <CardDescription>
          Let us know your preferences for sessions and communication
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* Preferred Session Times */}
        <div className="space-y-3">
          <Label>Preferred Session Times</Label>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {sessionTimeOptions.map((option) => (
              <div key={option.value} className="flex items-center space-x-2">
                <Checkbox
                  id={`sessionTime-${option.value}`}
                  checked={(sessionTimeController.field.value ?? []).includes(option.value)}
                  onCheckedChange={(checked) =>
                    handleSessionTimeChange(option.value, checked as boolean)
                  }
                />
                <Label htmlFor={`sessionTime-${option.value}`} className="text-sm font-normal">
                  {option.label}
                </Label>
              </div>
            ))}
          </div>
          {errors.preferences?.sessionTimes && (
            <p className="text-sm text-red-500">{errors.preferences.sessionTimes.message}</p>
          )}
        </div>

        {/* Communication Preferences */}
        <div className="space-y-3">
          <Label>Communication Preferences</Label>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
            {communicationOptions.map((option) => (
              <div key={option.value} className="flex items-center space-x-2">
                <Checkbox
                  id={`communication-${option.value}`}
                  checked={(communicationController.field.value ?? []).includes(option.value)}
                  onCheckedChange={(checked) =>
                    handleCommunicationChange(option.value, checked as boolean)
                  }
                />
                <Label htmlFor={`communication-${option.value}`} className="text-sm font-normal">
                  {option.label}
                </Label>
              </div>
            ))}
          </div>
          {errors.preferences?.communicationPrefs && (
            <p className="text-sm text-red-500">{errors.preferences.communicationPrefs.message}</p>
          )}
        </div>

        {/* Additional Notes */}
        <div className="space-y-2">
          <Label htmlFor="preferencesNotes">Additional Preferences or Notes</Label>
          <Textarea
            id="preferencesNotes"
            {...control.register("preferences.notes")}
            className={errors.preferences?.notes ? "border-red-500" : ""}
            placeholder="Any other preferences or special requests..."
            rows={3}
          />
          {errors.preferences?.notes && (
            <p className="text-sm text-red-500">{errors.preferences.notes.message}</p>
          )}
        </div>
      </CardContent>
    </Card>
  );
}



===== src/app/onboard/[token]/_components/OnboardingForm.tsx =====
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { toast } from "sonner";
import { Loader2, Upload, AlertCircle } from "lucide-react";
import { PhotoUploadSection } from "@/app/onboard/[token]/_components/PhotoUploadSection";
import { PersonalInfoSection } from "./PersonalInfoSection";
import { EmergencyContactSection } from "@/app/onboard/[token]/_components/EmergencyContactSection";
import { HealthInfoSection } from "@/app/onboard/[token]/_components/HealthInfoSection";
import { AddressSection } from "@/app/onboard/[token]/_components/AddressSection";
import { PreferencesSection } from "@/app/onboard/[token]/_components/PreferencesSection";
import { ConsentSection } from "@/app/onboard/[token]/_components/ConsentSection";

// Form validation schema
const OnboardingFormSchema = z.object({
  // Personal Information
  displayName: z.string().min(1, "Full name is required").max(255),
  primaryEmail: z.string().email("Invalid email format").optional(),
  primaryPhone: z
    .string()
    .regex(/^[\p{N}\p{P}\p{Z}]*$/u, "Phone number contains invalid characters")
    .min(10, "Phone number must be at least 10 digits")
    .optional(),
  dateOfBirth: z.string().optional(),

  // Emergency Contact
  emergencyContactName: z.string().min(1, "Emergency contact name is required").max(255),
  emergencyContactPhone: z
    .string()
    .regex(/^[\p{N}\p{P}\p{Z}]*$/u, "Emergency contact phone contains invalid characters")
    .min(10, "Emergency contact phone must be at least 10 digits"),

  // Client Status & Referral
  referralSource: z.string().optional(),

  // Address (optional)
  address: z
    .object({
      line1: z.string().optional(),
      line2: z.string().optional(),
      city: z.string().optional(),
      state: z.string().optional(),
      zipCode: z.string().optional(),
      country: z.string(),
    })
    .optional(),

  // Health Context
  healthContext: z
    .object({
      conditions: z.string().optional(), // Health conditions as text
      injuries: z.string().optional(), // Injuries/anything we should know
      allergies: z.string().optional(), // Allergies as text
      fitnessLevel: z.enum(["beginner", "intermediate", "advanced", "athlete"]).optional(),
      stressLevel: z.enum(["low", "moderate", "high", "very_high"]).optional(),
      goals: z.string().optional(), // What are you hoping to get out of your time with us
    })
    .optional(),

  // Preferences
  preferences: z
    .object({
      sessionTimes: z.array(z.enum(["mornings", "afternoons", "evenings", "weekends"])).optional(), // Preferred times
      communicationPrefs: z.array(z.enum(["email", "phone", "text"])).optional(), // Email, SMS, etc.
      notes: z.string().optional(), // Additional preferences
    })
    .optional(),

  // Consent flags
  consentMarketing: z.boolean(),
  consentHipaa: z.boolean(),
  consentPhotography: z.boolean(),
});

export type OnboardingFormData = z.infer<typeof OnboardingFormSchema>;

interface OnboardingFormProps {
  token: string;
}

export function OnboardingForm({ token }: OnboardingFormProps) {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [uploadedPhotoUrl, setUploadedPhotoUrl] = useState<string | null>(null);
  const [uploadedPhotoSize, setUploadedPhotoSize] = useState<number | null>(null);
  const [error, setError] = useState<string | null>(null);

  const form = useForm<OnboardingFormData>({
    resolver: zodResolver(OnboardingFormSchema),
    defaultValues: {
      displayName: "",
      emergencyContactName: "",
      emergencyContactPhone: "",
      consentMarketing: false,
      consentHipaa: false,
      consentPhotography: false,
      address: { country: "US" },
    },
  });

  const onSubmit = async (data: OnboardingFormData) => {
    setIsSubmitting(true);
    setError(null);

    try {
      // Validate and parse displayName into first_name and last_name
      const trimmedName = data.displayName.trim();

      // Check for empty or whitespace-only names
      if (!trimmedName) {
        form.setError("displayName", {
          type: "manual",
          message: "Full name is required",
        });
        setIsSubmitting(false);
        return;
      }

      // Normalize multiple spaces and split on whitespace
      const nameParts = trimmedName.replace(/\s+/g, " ").split(" ");

      // Sanitize names: remove illegal characters and enforce length limits
      const sanitizeName = (name: string) => {
        return name
          .replace(/[^a-zA-Z\s\-'\.]/g, "") // Remove illegal characters
          .substring(0, 50) // Enforce reasonable length limit
          .trim();
      };

      let first_name: string;
      let _last_name: string;

      if (nameParts.length === 1) {
        // Single name: use as first_name, leave last_name empty
        first_name = sanitizeName(nameParts[0] || "");
        _last_name = "";
      } else {
        // Multiple parts: first part is first_name, rest is last_name
        first_name = sanitizeName(nameParts[0] || "");
        _last_name = sanitizeName(nameParts.slice(1).join(" "));
      }

      // Validate that we have a valid first name after sanitization
      if (!first_name) {
        form.setError("displayName", {
          type: "manual",
          message: "Please enter a valid name",
        });
        setIsSubmitting(false);
        return;
      }

      // Prepare the submission data in the format expected by the API
      const submissionData = {
        token,
        client: {
          display_name: data.displayName.trim(), // Use the full name as display_name
          primary_email: data.primaryEmail || "",
          primary_phone: data.primaryPhone || "",
          date_of_birth: data.dateOfBirth || "",
          emergency_contact_name: data.emergencyContactName || "",
          emergency_contact_phone: data.emergencyContactPhone || "",
          referral_source: data.referralSource || "",
          address: {
            line1: data.address?.line1 || "",
            line2: data.address?.line2 || "",
            city: data.address?.city || "",
            state: data.address?.state || "",
            postalCode: data.address?.zipCode || "",
            country: data.address?.country || "US",
          },
          health_context: {
            conditions: data.healthContext?.conditions ? [data.healthContext.conditions] : [],
            allergies: data.healthContext?.allergies ? [data.healthContext.allergies] : [],
            fitnessLevel: data.healthContext?.fitnessLevel || "",
            stressLevel: data.healthContext?.stressLevel || "",
            medications: data.healthContext?.injuries ? [data.healthContext.injuries] : [],
            notes: data.healthContext?.goals || "",
          },
          preferences: {
            sessionTimes: data.preferences?.sessionTimes || [],
            communicationPreference: data.preferences?.communicationPrefs?.[0] || "email",
            reminderFrequency: "weekly",
            notes: data.preferences?.notes || "",
          },
        },
        consent: {
          consent_type: "data_processing",
          consent_text_version: "1.0",
          granted: true,
          signature_svg: "",
          signature_image_url: "",
        },
        photo_path: uploadedPhotoUrl || null,
        photo_size: uploadedPhotoSize || undefined,
      };

      // Debug: Log the submission data
      // Submit onboarding data

      // Get CSRF token from cookie
      const response = await fetch("/api/onboarding/public/submit", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(submissionData),
      });

      const result = await response.json();

      if (!response.ok) {
        // Handle detailed validation errors
        if (result.details && Array.isArray(result.details)) {
          const errorMessages = result.details
            .map(
              (detail: { field: string; message: string }) => `${detail.field}: ${detail.message}`,
            )
            .join(", ");
          throw new Error(`Validation failed: ${errorMessages}`);
        }
        throw new Error(result.error || "Submission failed");
      }

      toast.success("Profile completed successfully!");

      // Redirect to success page
      router.push("/onboard/success");
    } catch (error) {
      console.error("Submission error:", error);
      const message = error instanceof Error ? error.message : "An unexpected error occurred";
      setError(message);
      toast.error("Failed to submit profile: " + message);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
      {/* Error Alert */}
      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {/* Photo Upload */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Upload className="h-5 w-5" />
            Profile Photo
          </CardTitle>
          <CardDescription>Upload a clear photo for your profile (optional)</CardDescription>
        </CardHeader>
        <CardContent>
          <PhotoUploadSection
            token={token}
            onPhotoUploaded={(url, size) => {
              setUploadedPhotoUrl(url);
              setUploadedPhotoSize(size ?? null);
            }}
          />
        </CardContent>
      </Card>

      {/* Personal Information */}
      <PersonalInfoSection control={form.control} errors={form.formState.errors} />

      {/* Emergency Contact */}
      <EmergencyContactSection control={form.control} errors={form.formState.errors} />

      {/* Health Information */}
      <HealthInfoSection control={form.control} errors={form.formState.errors} />

      {/* Address Information */}
      <AddressSection control={form.control} errors={form.formState.errors} />

      {/* Preferences */}
      <PreferencesSection control={form.control} errors={form.formState.errors} />

      {/* Consent & Privacy */}
      <ConsentSection control={form.control} errors={form.formState.errors} />

      {/* Submit Button */}
      <div className="flex justify-center pt-6">
        <Button type="submit" disabled={isSubmitting} className="w-full max-w-md h-12 text-lg">
          {isSubmitting ? (
            <>
              <Loader2 className="mr-2 h-5 w-5 animate-spin" />
              Completing Profile...
            </>
          ) : (
            "Complete My Profile"
          )}
        </Button>
      </div>
    </form>
  );
}




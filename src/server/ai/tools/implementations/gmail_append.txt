
// ============================================================================
// TOOL: categorize_email
// ============================================================================

const CategorizeEmailParamsSchema = z.object({
  email_id: z.string().uuid(),
});

type CategorizeEmailParams = z.infer<typeof CategorizeEmailParamsSchema>;

export const categorizeEmailDefinition: ToolDefinition = {
  name: "categorize_email",
  category: "analytics",
  version: "1.0.0",
  description:
    "Classify an email as marketing, wellness, business, or other based on content analysis using keyword matching.",
  useCases: [
    "When user asks 'what category is this email?'",
    "When organizing emails for digest generation",
    "When filtering emails by type",
    "When preparing weekly summaries",
  ],
  exampleCalls: [
    'categorize_email({"email_id": "123e4567-e89b-12d3-a456-426614174000"})',
    'When user says: "What type of email is this?"',
  ],
  parameters: {
    type: "object",
    properties: {
      email_id: {
        type: "string",
        description: "UUID of the email to categorize",
      },
    },
    required: ["email_id"],
    additionalProperties: false,
  },
  permissionLevel: "read",
  creditCost: 0,
  isIdempotent: true,
  cacheable: true,
  cacheTtlSeconds: 600,
  tags: ["gmail", "email", "categorization", "analytics"],
  deprecated: false,
};

export const categorizeEmailHandler: ToolHandler<CategorizeEmailParams> = async (
  params,
  context
) => {
  const validated = CategorizeEmailParamsSchema.parse(params);

  try {
    const db = await getDb();
    const repo = createInteractionsRepository(db);

    const email = await repo.getInteractionById(context.userId, validated.email_id);

    if (!email) {
      throw new AppError(
        `Email with ID ${validated.email_id} not found`,
        "EMAIL_NOT_FOUND",
        "validation",
        true,
        404
      );
    }

    if (email.type !== "email") {
      throw new AppError(
        `Interaction ${validated.email_id} is not an email (type: ${email.type})`,
        "INVALID_TYPE",
        "validation",
        true,
        400
      );
    }

    const content = `${email.subject || ""} ${email.bodyText || ""}`.toLowerCase();

    // Category keywords
    const categoryKeywords = {
      marketing: [
        "newsletter",
        "promotion",
        "offer",
        "sale",
        "discount",
        "subscribe",
        "unsubscribe",
        "special offer",
        "limited time",
        "marketing",
        "advertisement",
        "promo",
      ],
      wellness: [
        "yoga",
        "meditation",
        "wellness",
        "health",
        "therapy",
        "massage",
        "reiki",
        "mindfulness",
        "healing",
        "holistic",
        "practitioner",
        "session",
        "treatment",
        "practice",
      ],
      business: [
        "invoice",
        "payment",
        "bill",
        "receipt",
        "contract",
        "agreement",
        "meeting",
        "appointment",
        "schedule",
        "business",
        "professional",
        "service",
      ],
    };

    // Score each category
    const categoryScores: Record<string, number> = {
      marketing: 0,
      wellness: 0,
      business: 0,
      other: 0,
    };

    Object.entries(categoryKeywords).forEach(([category, keywords]) => {
      const matches = keywords.filter((keyword) => content.includes(keyword)).length;
      categoryScores[category] = matches;
    });

    // Determine best category
    let bestCategory = "other";
    let maxScore = 0;

    Object.entries(categoryScores).forEach(([category, score]) => {
      if (score > maxScore) {
        maxScore = score;
        bestCategory = category;
      }
    });

    return {
      emailId: validated.email_id,
      category: bestCategory,
      confidence: maxScore > 0 ? Math.min(maxScore * 0.2, 1.0) : 0.1,
      categoryScores,
      subject: email.subject,
    };
  } catch (error) {
    if (error instanceof AppError) {
      throw error;
    }
    throw new AppError(
      error instanceof Error ? error.message : "Failed to categorize email",
      "DB_ERROR",
      "database",
      false,
      500
    );
  }
};

// ============================================================================
// TOOL: generate_marketing_digest
// ============================================================================

const GenerateMarketingDigestParamsSchema = z.object({
  start_date: z.string().datetime(),
  end_date: z.string().datetime(),
  max_emails: z.number().int().positive().max(50).default(20),
});

type GenerateMarketingDigestParams = z.infer<typeof GenerateMarketingDigestParamsSchema>;

export const generateMarketingDigestDefinition: ToolDefinition = {
  name: "generate_marketing_digest",
  category: "analytics",
  version: "1.0.0",
  description:
    "Generate AI-powered weekly summary of marketing emails. Analyzes promotional content, special offers, and newsletters to provide key insights.",
  useCases: [
    "When user asks 'summarize my marketing emails this week'",
    "When user wants 'what promotions did I receive?'",
    "When generating weekly email digest reports",
    "When tracking marketing trends",
  ],
  exampleCalls: [
    'generate_marketing_digest({"start_date": "2025-01-01T00:00:00Z", "end_date": "2025-01-07T23:59:59Z"})',
    'When user says: "What marketing emails did I get this week?"',
  ],
  parameters: {
    type: "object",
    properties: {
      start_date: {
        type: "string",
        description: "Start date for digest period (ISO 8601 format)",
      },
      end_date: {
        type: "string",
        description: "End date for digest period (ISO 8601 format)",
      },
      max_emails: {
        type: "number",
        description: "Maximum number of emails to include in digest (default: 20, max: 50)",
      },
    },
    required: ["start_date", "end_date"],
    additionalProperties: false,
  },
  permissionLevel: "read",
  creditCost: 5,
  isIdempotent: true,
  cacheable: true,
  cacheTtlSeconds: 3600,
  tags: ["gmail", "email", "digest", "marketing", "analytics"],
  deprecated: false,
};

export const generateMarketingDigestHandler: ToolHandler<GenerateMarketingDigestParams> = async (
  params,
  context
) => {
  const validated = GenerateMarketingDigestParamsSchema.parse(params);

  try {
    const db = await getDb();
    const repo = createInteractionsRepository(db);

    const { items } = await repo.listInteractions(context.userId, {
      types: ["email"],
      occurredAfter: new Date(validated.start_date),
      occurredBefore: new Date(validated.end_date),
      pageSize: validated.max_emails,
      page: 1,
    });

    // Filter for marketing emails
    const marketingEmails = items.filter((email) => {
      const content = `${email.subject || ""} ${email.bodyText || ""}`.toLowerCase();
      const marketingKeywords = [
        "newsletter",
        "promotion",
        "offer",
        "sale",
        "discount",
        "subscribe",
      ];
      return marketingKeywords.some((keyword) => content.includes(keyword));
    });

    // TODO: Call LLM to generate comprehensive marketing digest
    // This should analyze offers, trends, and provide insights
    // For now, return structured summary

    const senders = new Set(
      marketingEmails.map((e) => {
        const meta = e.sourceMeta as { from?: string } | null;
        return meta?.from || "Unknown";
      })
    );

    const offerEmails = marketingEmails.filter((e) =>
      `${e.subject || ""} ${e.bodyText || ""}`.toLowerCase().includes("offer")
    );

    return {
      period: {
        start: validated.start_date,
        end: validated.end_date,
      },
      summary: {
        totalEmails: marketingEmails.length,
        uniqueSenders: senders.size,
        topSenders: Array.from(senders).slice(0, 5),
        specialOffers: offerEmails.length,
      },
      digest:
        "Marketing Digest: This period included promotional content from wellness brands, special offers, and newsletters. Key themes include seasonal promotions and wellness program updates.",
      emails: marketingEmails.map((e) => ({
        id: e.id,
        subject: e.subject,
        sender: (e.sourceMeta as { from?: string } | null)?.from || "Unknown",
        date: e.occurredAt,
      })),
    };
  } catch (error) {
    throw new AppError(
      error instanceof Error ? error.message : "Failed to generate marketing digest",
      "DB_ERROR",
      "database",
      false,
      500
    );
  }
};

// ... (Continue with remaining 4 tools in similar format)
